{"ast":null,"code":"import { Param } from \"../context/Param\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isUndef } from \"../util/TypeCheck\";\n/**\n * A Param class just for computing ticks. Similar to the [[Param]] class,\n * but offers conversion to BPM values as well as ability to compute tick\n * duration and elapsed ticks\n */\nexport class TickParam extends Param {\n  constructor() {\n    super(optionsFromArguments(TickParam.getDefaults(), arguments, [\"value\"]));\n    this.name = \"TickParam\";\n    /**\n     * The timeline which tracks all of the automations.\n     */\n    this._events = new Timeline(Infinity);\n    /**\n     * The internal holder for the multiplier value\n     */\n    this._multiplier = 1;\n    const options = optionsFromArguments(TickParam.getDefaults(), arguments, [\"value\"]);\n    // set the multiplier\n    this._multiplier = options.multiplier;\n    // clear the ticks from the beginning\n    this._events.cancel(0);\n    // set an initial event\n    this._events.add({\n      ticks: 0,\n      time: 0,\n      type: \"setValueAtTime\",\n      value: this._fromType(options.value)\n    });\n    this.setValueAtTime(options.value, 0);\n  }\n  static getDefaults() {\n    return Object.assign(Param.getDefaults(), {\n      multiplier: 1,\n      units: \"hertz\",\n      value: 1\n    });\n  }\n  setTargetAtTime(value, time, constant) {\n    // approximate it with multiple linear ramps\n    time = this.toSeconds(time);\n    this.setRampPoint(time);\n    const computedValue = this._fromType(value);\n    // start from previously scheduled value\n    const prevEvent = this._events.get(time);\n    const segments = Math.round(Math.max(1 / constant, 1));\n    for (let i = 0; i <= segments; i++) {\n      const segTime = constant * i + time;\n      const rampVal = this._exponentialApproach(prevEvent.time, prevEvent.value, computedValue, constant, segTime);\n      this.linearRampToValueAtTime(this._toType(rampVal), segTime);\n    }\n    return this;\n  }\n  setValueAtTime(value, time) {\n    const computedTime = this.toSeconds(time);\n    super.setValueAtTime(value, time);\n    const event = this._events.get(computedTime);\n    const previousEvent = this._events.previousEvent(event);\n    const ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n    event.ticks = Math.max(ticksUntilTime, 0);\n    return this;\n  }\n  linearRampToValueAtTime(value, time) {\n    const computedTime = this.toSeconds(time);\n    super.linearRampToValueAtTime(value, time);\n    const event = this._events.get(computedTime);\n    const previousEvent = this._events.previousEvent(event);\n    const ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n    event.ticks = Math.max(ticksUntilTime, 0);\n    return this;\n  }\n  exponentialRampToValueAtTime(value, time) {\n    // aproximate it with multiple linear ramps\n    time = this.toSeconds(time);\n    const computedVal = this._fromType(value);\n    // start from previously scheduled value\n    const prevEvent = this._events.get(time);\n    // approx 10 segments per second\n    const segments = Math.round(Math.max((time - prevEvent.time) * 10, 1));\n    const segmentDur = (time - prevEvent.time) / segments;\n    for (let i = 0; i <= segments; i++) {\n      const segTime = segmentDur * i + prevEvent.time;\n      const rampVal = this._exponentialInterpolate(prevEvent.time, prevEvent.value, time, computedVal, segTime);\n      this.linearRampToValueAtTime(this._toType(rampVal), segTime);\n    }\n    return this;\n  }\n  /**\n   * Returns the tick value at the time. Takes into account\n   * any automation curves scheduled on the signal.\n   * @param  event The time to get the tick count at\n   * @return The number of ticks which have elapsed at the time given any automations.\n   */\n  _getTicksUntilEvent(event, time) {\n    if (event === null) {\n      event = {\n        ticks: 0,\n        time: 0,\n        type: \"setValueAtTime\",\n        value: 0\n      };\n    } else if (isUndef(event.ticks)) {\n      const previousEvent = this._events.previousEvent(event);\n      event.ticks = this._getTicksUntilEvent(previousEvent, event.time);\n    }\n    const val0 = this._fromType(this.getValueAtTime(event.time));\n    let val1 = this._fromType(this.getValueAtTime(time));\n    // if it's right on the line, take the previous value\n    const onTheLineEvent = this._events.get(time);\n    if (onTheLineEvent && onTheLineEvent.time === time && onTheLineEvent.type === \"setValueAtTime\") {\n      val1 = this._fromType(this.getValueAtTime(time - this.sampleTime));\n    }\n    return 0.5 * (time - event.time) * (val0 + val1) + event.ticks;\n  }\n  /**\n   * Returns the tick value at the time. Takes into account\n   * any automation curves scheduled on the signal.\n   * @param  time The time to get the tick count at\n   * @return The number of ticks which have elapsed at the time given any automations.\n   */\n  getTicksAtTime(time) {\n    const computedTime = this.toSeconds(time);\n    const event = this._events.get(computedTime);\n    return Math.max(this._getTicksUntilEvent(event, computedTime), 0);\n  }\n  /**\n   * Return the elapsed time of the number of ticks from the given time\n   * @param ticks The number of ticks to calculate\n   * @param  time The time to get the next tick from\n   * @return The duration of the number of ticks from the given time in seconds\n   */\n  getDurationOfTicks(ticks, time) {\n    const computedTime = this.toSeconds(time);\n    const currentTick = this.getTicksAtTime(time);\n    return this.getTimeOfTick(currentTick + ticks) - computedTime;\n  }\n  /**\n   * Given a tick, returns the time that tick occurs at.\n   * @return The time that the tick occurs.\n   */\n  getTimeOfTick(tick) {\n    const before = this._events.get(tick, \"ticks\");\n    const after = this._events.getAfter(tick, \"ticks\");\n    if (before && before.ticks === tick) {\n      return before.time;\n    } else if (before && after && after.type === \"linearRampToValueAtTime\" && before.value !== after.value) {\n      const val0 = this._fromType(this.getValueAtTime(before.time));\n      const val1 = this._fromType(this.getValueAtTime(after.time));\n      const delta = (val1 - val0) / (after.time - before.time);\n      const k = Math.sqrt(Math.pow(val0, 2) - 2 * delta * (before.ticks - tick));\n      const sol1 = (-val0 + k) / delta;\n      const sol2 = (-val0 - k) / delta;\n      return (sol1 > 0 ? sol1 : sol2) + before.time;\n    } else if (before) {\n      if (before.value === 0) {\n        return Infinity;\n      } else {\n        return before.time + (tick - before.ticks) / before.value;\n      }\n    } else {\n      return tick / this._initialValue;\n    }\n  }\n  /**\n   * Convert some number of ticks their the duration in seconds accounting\n   * for any automation curves starting at the given time.\n   * @param  ticks The number of ticks to convert to seconds.\n   * @param  when  When along the automation timeline to convert the ticks.\n   * @return The duration in seconds of the ticks.\n   */\n  ticksToTime(ticks, when) {\n    return this.getDurationOfTicks(ticks, when);\n  }\n  /**\n   * The inverse of [[ticksToTime]]. Convert a duration in\n   * seconds to the corresponding number of ticks accounting for any\n   * automation curves starting at the given time.\n   * @param  duration The time interval to convert to ticks.\n   * @param  when When along the automation timeline to convert the ticks.\n   * @return The duration in ticks.\n   */\n  timeToTicks(duration, when) {\n    const computedTime = this.toSeconds(when);\n    const computedDuration = this.toSeconds(duration);\n    const startTicks = this.getTicksAtTime(computedTime);\n    const endTicks = this.getTicksAtTime(computedTime + computedDuration);\n    return endTicks - startTicks;\n  }\n  /**\n   * Convert from the type when the unit value is BPM\n   */\n  _fromType(val) {\n    if (this.units === \"bpm\" && this.multiplier) {\n      return 1 / (60 / val / this.multiplier);\n    } else {\n      return super._fromType(val);\n    }\n  }\n  /**\n   * Special case of type conversion where the units === \"bpm\"\n   */\n  _toType(val) {\n    if (this.units === \"bpm\" && this.multiplier) {\n      return val / this.multiplier * 60;\n    } else {\n      return super._toType(val);\n    }\n  }\n  /**\n   * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.\n   */\n  get multiplier() {\n    return this._multiplier;\n  }\n  set multiplier(m) {\n    // get and reset the current value with the new multiplier\n    // might be necessary to clear all the previous values\n    const currentVal = this.value;\n    this._multiplier = m;\n    this.cancelScheduledValues(0);\n    this.setValueAtTime(currentVal, 0);\n  }\n}","map":{"version":3,"names":["Param","optionsFromArguments","Timeline","isUndef","TickParam","constructor","getDefaults","arguments","name","_events","Infinity","_multiplier","options","multiplier","cancel","add","ticks","time","type","value","_fromType","setValueAtTime","Object","assign","units","setTargetAtTime","constant","toSeconds","setRampPoint","computedValue","prevEvent","get","segments","Math","round","max","i","segTime","rampVal","_exponentialApproach","linearRampToValueAtTime","_toType","computedTime","event","previousEvent","ticksUntilTime","_getTicksUntilEvent","exponentialRampToValueAtTime","computedVal","segmentDur","_exponentialInterpolate","val0","getValueAtTime","val1","onTheLineEvent","sampleTime","getTicksAtTime","getDurationOfTicks","currentTick","getTimeOfTick","tick","before","after","getAfter","delta","k","sqrt","pow","sol1","sol2","_initialValue","ticksToTime","when","timeToTicks","duration","computedDuration","startTicks","endTicks","val","m","currentVal","cancelScheduledValues"],"sources":["/Users/ianstrom/Development/code/Capstone/node_modules/tone/Tone/core/clock/TickParam.ts"],"sourcesContent":["import { AutomationEvent, Param, ParamOptions } from \"../context/Param\";\nimport { Seconds, Ticks, Time, UnitMap, UnitName } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isUndef } from \"../util/TypeCheck\";\n\ntype TickAutomationEvent = AutomationEvent & {\n\tticks: number;\n};\n\ninterface TickParamOptions<TypeName extends UnitName> extends ParamOptions<TypeName> {\n\tmultiplier: number;\n}\n\n/**\n * A Param class just for computing ticks. Similar to the [[Param]] class,\n * but offers conversion to BPM values as well as ability to compute tick\n * duration and elapsed ticks\n */\nexport class TickParam<TypeName extends \"hertz\" | \"bpm\"> extends Param<TypeName> {\n\n\treadonly name: string = \"TickParam\";\n\n\t/**\n\t * The timeline which tracks all of the automations.\n\t */\n\tprotected _events: Timeline<TickAutomationEvent> = new Timeline(Infinity);\n\n\t/**\n\t * The internal holder for the multiplier value\n\t */\n\tprivate _multiplier = 1;\n\n\t/**\n\t * @param param The AudioParam to wrap\n\t * @param units The unit name\n\t * @param convert Whether or not to convert the value to the target units\n\t */\n\t/**\n\t * @param value The initial value of the signal\n\t */\n\tconstructor(value?: number);\n\tconstructor(options: Partial<TickParamOptions<TypeName>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(TickParam.getDefaults(), arguments, [\"value\"]));\n\t\tconst options = optionsFromArguments(TickParam.getDefaults(), arguments, [\"value\"]);\n\n\t\t// set the multiplier\n\t\tthis._multiplier = options.multiplier;\n\n\t\t// clear the ticks from the beginning\n\t\tthis._events.cancel(0);\n\t\t// set an initial event\n\t\tthis._events.add({\n\t\t\tticks: 0,\n\t\t\ttime: 0,\n\t\t\ttype: \"setValueAtTime\",\n\t\t\tvalue: this._fromType(options.value),\n\t\t});\n\t\tthis.setValueAtTime(options.value, 0);\n\t}\n\n\tstatic getDefaults(): TickParamOptions<any> {\n\t\treturn Object.assign(Param.getDefaults(), {\n\t\t\tmultiplier: 1,\n\t\t\tunits: \"hertz\",\n\t\t\tvalue: 1,\n\t\t});\n\t}\n\n\tsetTargetAtTime(value: UnitMap[TypeName], time: Time, constant: number): this {\n\t\t// approximate it with multiple linear ramps\n\t\ttime = this.toSeconds(time);\n\t\tthis.setRampPoint(time);\n\t\tconst computedValue = this._fromType(value);\n\n\t\t// start from previously scheduled value\n\t\tconst prevEvent = this._events.get(time) as TickAutomationEvent;\n\t\tconst segments = Math.round(Math.max(1 / constant, 1));\n\t\tfor (let i = 0; i <= segments; i++) {\n\t\t\tconst segTime = constant * i + time;\n\t\t\tconst rampVal = this._exponentialApproach(prevEvent.time, prevEvent.value, computedValue, constant, segTime);\n\t\t\tthis.linearRampToValueAtTime(this._toType(rampVal), segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\tsetValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tsuper.setValueAtTime(value, time);\n\t\tconst event = this._events.get(computedTime) as TickAutomationEvent;\n\t\tconst previousEvent = this._events.previousEvent(event);\n\t\tconst ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n\t\tevent.ticks = Math.max(ticksUntilTime, 0);\n\t\treturn this;\n\t}\n\n\tlinearRampToValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tsuper.linearRampToValueAtTime(value, time);\n\t\tconst event = this._events.get(computedTime) as TickAutomationEvent;\n\t\tconst previousEvent = this._events.previousEvent(event);\n\t\tconst ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n\t\tevent.ticks = Math.max(ticksUntilTime, 0);\n\t\treturn this;\n\t}\n\n\texponentialRampToValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\t// aproximate it with multiple linear ramps\n\t\ttime = this.toSeconds(time);\n\t\tconst computedVal = this._fromType(value);\n\n\t\t// start from previously scheduled value\n\t\tconst prevEvent = this._events.get(time) as TickAutomationEvent;\n\t\t// approx 10 segments per second\n\t\tconst segments = Math.round(Math.max((time - prevEvent.time) * 10, 1));\n\t\tconst segmentDur = ((time - prevEvent.time) / segments);\n\t\tfor (let i = 0; i <= segments; i++) {\n\t\t\tconst segTime = segmentDur * i + prevEvent.time;\n\t\t\tconst rampVal = this._exponentialInterpolate(prevEvent.time, prevEvent.value, time, computedVal, segTime);\n\t\t\tthis.linearRampToValueAtTime(this._toType(rampVal), segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the tick value at the time. Takes into account\n\t * any automation curves scheduled on the signal.\n\t * @param  event The time to get the tick count at\n\t * @return The number of ticks which have elapsed at the time given any automations.\n\t */\n\tprivate _getTicksUntilEvent(event: TickAutomationEvent | null, time: number): Ticks {\n\t\tif (event === null) {\n\t\t\tevent = {\n\t\t\t\tticks: 0,\n\t\t\t\ttime: 0,\n\t\t\t\ttype: \"setValueAtTime\",\n\t\t\t\tvalue: 0,\n\t\t\t};\n\t\t} else if (isUndef(event.ticks)) {\n\t\t\tconst previousEvent = this._events.previousEvent(event);\n\t\t\tevent.ticks = this._getTicksUntilEvent(previousEvent, event.time);\n\t\t}\n\t\tconst val0 = this._fromType(this.getValueAtTime(event.time));\n\t\tlet val1 = this._fromType(this.getValueAtTime(time));\n\t\t// if it's right on the line, take the previous value\n\t\tconst onTheLineEvent = this._events.get(time);\n\t\tif (onTheLineEvent && onTheLineEvent.time === time && onTheLineEvent.type === \"setValueAtTime\") {\n\t\t\tval1 = this._fromType(this.getValueAtTime(time - this.sampleTime));\n\t\t}\n\t\treturn 0.5 * (time - event.time) * (val0 + val1) + event.ticks;\n\t}\n\n\t/**\n\t * Returns the tick value at the time. Takes into account\n\t * any automation curves scheduled on the signal.\n\t * @param  time The time to get the tick count at\n\t * @return The number of ticks which have elapsed at the time given any automations.\n\t */\n\tgetTicksAtTime(time: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst event = this._events.get(computedTime);\n\t\treturn Math.max(this._getTicksUntilEvent(event, computedTime), 0);\n\t}\n\n\t/**\n\t * Return the elapsed time of the number of ticks from the given time\n\t * @param ticks The number of ticks to calculate\n\t * @param  time The time to get the next tick from\n\t * @return The duration of the number of ticks from the given time in seconds\n\t */\n\tgetDurationOfTicks(ticks: Ticks, time: Time): Seconds {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst currentTick = this.getTicksAtTime(time);\n\t\treturn this.getTimeOfTick(currentTick + ticks) - computedTime;\n\t}\n\n\t/**\n\t * Given a tick, returns the time that tick occurs at.\n\t * @return The time that the tick occurs.\n\t */\n\tgetTimeOfTick(tick: Ticks): Seconds {\n\t\tconst before = this._events.get(tick, \"ticks\");\n\t\tconst after = this._events.getAfter(tick, \"ticks\");\n\t\tif (before && before.ticks === tick) {\n\t\t\treturn before.time;\n\t\t} else if (before && after &&\n\t\t\tafter.type === \"linearRampToValueAtTime\" &&\n\t\t\tbefore.value !== after.value) {\n\t\t\tconst val0 = this._fromType(this.getValueAtTime(before.time));\n\t\t\tconst val1 = this._fromType(this.getValueAtTime(after.time));\n\t\t\tconst delta = (val1 - val0) / (after.time - before.time);\n\t\t\tconst k = Math.sqrt(Math.pow(val0, 2) - 2 * delta * (before.ticks - tick));\n\t\t\tconst sol1 = (-val0 + k) / delta;\n\t\t\tconst sol2 = (-val0 - k) / delta;\n\t\t\treturn (sol1 > 0 ? sol1 : sol2) + before.time;\n\t\t} else if (before) {\n\t\t\tif (before.value === 0) {\n\t\t\t\treturn Infinity;\n\t\t\t} else {\n\t\t\t\treturn before.time + (tick - before.ticks) / before.value;\n\t\t\t}\n\t\t} else {\n\t\t\treturn tick / this._initialValue;\n\t\t}\n\t}\n\n\t/**\n\t * Convert some number of ticks their the duration in seconds accounting\n\t * for any automation curves starting at the given time.\n\t * @param  ticks The number of ticks to convert to seconds.\n\t * @param  when  When along the automation timeline to convert the ticks.\n\t * @return The duration in seconds of the ticks.\n\t */\n\tticksToTime(ticks: Ticks, when: Time): Seconds {\n\t\treturn this.getDurationOfTicks(ticks, when);\n\t}\n\n\t/**\n\t * The inverse of [[ticksToTime]]. Convert a duration in\n\t * seconds to the corresponding number of ticks accounting for any\n\t * automation curves starting at the given time.\n\t * @param  duration The time interval to convert to ticks.\n\t * @param  when When along the automation timeline to convert the ticks.\n\t * @return The duration in ticks.\n\t */\n\ttimeToTicks(duration: Time, when: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(when);\n\t\tconst computedDuration = this.toSeconds(duration);\n\t\tconst startTicks = this.getTicksAtTime(computedTime);\n\t\tconst endTicks = this.getTicksAtTime(computedTime + computedDuration);\n\t\treturn endTicks - startTicks;\n\t}\n\n\t/**\n\t * Convert from the type when the unit value is BPM\n\t */\n\tprotected _fromType(val: UnitMap[TypeName]): number {\n\t\tif (this.units === \"bpm\" && this.multiplier) {\n\t\t\treturn 1 / (60 / val / this.multiplier);\n\t\t} else {\n\t\t\treturn super._fromType(val);\n\t\t}\n\t}\n\n\t/**\n\t * Special case of type conversion where the units === \"bpm\"\n\t */\n\tprotected _toType(val: number): UnitMap[TypeName] {\n\t\tif (this.units === \"bpm\" && this.multiplier) {\n\t\t\treturn (val / this.multiplier) * 60 as UnitMap[TypeName];\n\t\t} else {\n\t\t\treturn super._toType(val);\n\t\t}\n\t}\n\t/**\n\t * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.\n\t */\n\tget multiplier(): number {\n\t\treturn this._multiplier;\n\t}\n\tset multiplier(m: number) {\n\t\t// get and reset the current value with the new multiplier\n\t\t// might be necessary to clear all the previous values\n\t\tconst currentVal = this.value;\n\t\tthis._multiplier = m;\n\t\tthis.cancelScheduledValues(0);\n\t\tthis.setValueAtTime(currentVal, 0);\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}