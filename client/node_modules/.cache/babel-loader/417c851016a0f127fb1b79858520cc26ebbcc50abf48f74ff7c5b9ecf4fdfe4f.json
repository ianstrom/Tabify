{"ast":null,"code":"import { __awaiter, __decorate } from \"tslib\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp } from \"../../core/util/Interface\";\nimport { isUndef } from \"../../core/util/TypeCheck\";\nimport { Source } from \"../Source\";\nimport { ToneBufferSource } from \"./ToneBufferSource\";\nimport { assertRange } from \"../../core/util/Debug\";\nimport { timeRange } from \"../../core/util/Decorator\";\n/**\n * Player is an audio file player with start, loop, and stop functions.\n * @example\n * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/gong_1.mp3\").toDestination();\n * // play as soon as the buffer is loaded\n * player.autostart = true;\n * @category Source\n */\nexport class Player extends Source {\n  constructor() {\n    super(optionsFromArguments(Player.getDefaults(), arguments, [\"url\", \"onload\"]));\n    this.name = \"Player\";\n    /**\n     * All of the active buffer source nodes\n     */\n    this._activeSources = new Set();\n    const options = optionsFromArguments(Player.getDefaults(), arguments, [\"url\", \"onload\"]);\n    this._buffer = new ToneAudioBuffer({\n      onload: this._onload.bind(this, options.onload),\n      onerror: options.onerror,\n      reverse: options.reverse,\n      url: options.url\n    });\n    this.autostart = options.autostart;\n    this._loop = options.loop;\n    this._loopStart = options.loopStart;\n    this._loopEnd = options.loopEnd;\n    this._playbackRate = options.playbackRate;\n    this.fadeIn = options.fadeIn;\n    this.fadeOut = options.fadeOut;\n  }\n  static getDefaults() {\n    return Object.assign(Source.getDefaults(), {\n      autostart: false,\n      fadeIn: 0,\n      fadeOut: 0,\n      loop: false,\n      loopEnd: 0,\n      loopStart: 0,\n      onload: noOp,\n      onerror: noOp,\n      playbackRate: 1,\n      reverse: false\n    });\n  }\n  /**\n   * Load the audio file as an audio buffer.\n   * Decodes the audio asynchronously and invokes\n   * the callback once the audio buffer loads.\n   * Note: this does not need to be called if a url\n   * was passed in to the constructor. Only use this\n   * if you want to manually load a new url.\n   * @param url The url of the buffer to load. Filetype support depends on the browser.\n   */\n  load(url) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this._buffer.load(url);\n      this._onload();\n      return this;\n    });\n  }\n  /**\n   * Internal callback when the buffer is loaded.\n   */\n  _onload() {\n    let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : noOp;\n    callback();\n    if (this.autostart) {\n      this.start();\n    }\n  }\n  /**\n   * Internal callback when the buffer is done playing.\n   */\n  _onSourceEnd(source) {\n    // invoke the onstop function\n    this.onstop(this);\n    // delete the source from the active sources\n    this._activeSources.delete(source);\n    if (this._activeSources.size === 0 && !this._synced && this._state.getValueAtTime(this.now()) === \"started\") {\n      // remove the 'implicitEnd' event and replace with an explicit end\n      this._state.cancel(this.now());\n      this._state.setStateAtTime(\"stopped\", this.now());\n    }\n  }\n  /**\n   * Play the buffer at the given startTime. Optionally add an offset\n   * and/or duration which will play the buffer from a position\n   * within the buffer for the given duration.\n   *\n   * @param  time When the player should start.\n   * @param  offset The offset from the beginning of the sample to start at.\n   * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)\n   */\n  start(time, offset, duration) {\n    super.start(time, offset, duration);\n    return this;\n  }\n  /**\n   * Internal start method\n   */\n  _start(startTime, offset, duration) {\n    // if it's a loop the default offset is the loopStart point\n    if (this._loop) {\n      offset = defaultArg(offset, this._loopStart);\n    } else {\n      // otherwise the default offset is 0\n      offset = defaultArg(offset, 0);\n    }\n    // compute the values in seconds\n    const computedOffset = this.toSeconds(offset);\n    // compute the duration which is either the passed in duration of the buffer.duration - offset\n    const origDuration = duration;\n    duration = defaultArg(duration, Math.max(this._buffer.duration - computedOffset, 0));\n    let computedDuration = this.toSeconds(duration);\n    // scale it by the playback rate\n    computedDuration = computedDuration / this._playbackRate;\n    // get the start time\n    startTime = this.toSeconds(startTime);\n    // make the source\n    const source = new ToneBufferSource({\n      url: this._buffer,\n      context: this.context,\n      fadeIn: this.fadeIn,\n      fadeOut: this.fadeOut,\n      loop: this._loop,\n      loopEnd: this._loopEnd,\n      loopStart: this._loopStart,\n      onended: this._onSourceEnd.bind(this),\n      playbackRate: this._playbackRate\n    }).connect(this.output);\n    // set the looping properties\n    if (!this._loop && !this._synced) {\n      // cancel the previous stop\n      this._state.cancel(startTime + computedDuration);\n      // if it's not looping, set the state change at the end of the sample\n      this._state.setStateAtTime(\"stopped\", startTime + computedDuration, {\n        implicitEnd: true\n      });\n    }\n    // add it to the array of active sources\n    this._activeSources.add(source);\n    // start it\n    if (this._loop && isUndef(origDuration)) {\n      source.start(startTime, computedOffset);\n    } else {\n      // subtract the fade out time\n      source.start(startTime, computedOffset, computedDuration - this.toSeconds(this.fadeOut));\n    }\n  }\n  /**\n   * Stop playback.\n   */\n  _stop(time) {\n    const computedTime = this.toSeconds(time);\n    this._activeSources.forEach(source => source.stop(computedTime));\n  }\n  /**\n   * Stop and then restart the player from the beginning (or offset)\n   * @param  time When the player should start.\n   * @param  offset The offset from the beginning of the sample to start at.\n   * @param  duration How long the sample should play. If no duration is given,\n   * \t\t\t\t\tit will default to the full length of the sample (minus any offset)\n   */\n  restart(time, offset, duration) {\n    super.restart(time, offset, duration);\n    return this;\n  }\n  _restart(time, offset, duration) {\n    this._stop(time);\n    this._start(time, offset, duration);\n  }\n  /**\n   * Seek to a specific time in the player's buffer. If the\n   * source is no longer playing at that time, it will stop.\n   * @param offset The time to seek to.\n   * @param when The time for the seek event to occur.\n   * @example\n   * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/gurgling_theremin_1.mp3\", () => {\n   * \tplayer.start();\n   * \t// seek to the offset in 1 second from now\n   * \tplayer.seek(0.4, \"+1\");\n   * }).toDestination();\n   */\n  seek(offset, when) {\n    const computedTime = this.toSeconds(when);\n    if (this._state.getValueAtTime(computedTime) === \"started\") {\n      const computedOffset = this.toSeconds(offset);\n      // if it's currently playing, stop it\n      this._stop(computedTime);\n      // restart it at the given time\n      this._start(computedTime, computedOffset);\n    }\n    return this;\n  }\n  /**\n   * Set the loop start and end. Will only loop if loop is set to true.\n   * @param loopStart The loop start time\n   * @param loopEnd The loop end time\n   * @example\n   * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/malevoices_aa2_F3.mp3\").toDestination();\n   * // loop between the given points\n   * player.setLoopPoints(0.2, 0.3);\n   * player.loop = true;\n   * player.autostart = true;\n   */\n  setLoopPoints(loopStart, loopEnd) {\n    this.loopStart = loopStart;\n    this.loopEnd = loopEnd;\n    return this;\n  }\n  /**\n   * If loop is true, the loop will start at this position.\n   */\n  get loopStart() {\n    return this._loopStart;\n  }\n  set loopStart(loopStart) {\n    this._loopStart = loopStart;\n    if (this.buffer.loaded) {\n      assertRange(this.toSeconds(loopStart), 0, this.buffer.duration);\n    }\n    // get the current source\n    this._activeSources.forEach(source => {\n      source.loopStart = loopStart;\n    });\n  }\n  /**\n   * If loop is true, the loop will end at this position.\n   */\n  get loopEnd() {\n    return this._loopEnd;\n  }\n  set loopEnd(loopEnd) {\n    this._loopEnd = loopEnd;\n    if (this.buffer.loaded) {\n      assertRange(this.toSeconds(loopEnd), 0, this.buffer.duration);\n    }\n    // get the current source\n    this._activeSources.forEach(source => {\n      source.loopEnd = loopEnd;\n    });\n  }\n  /**\n   * The audio buffer belonging to the player.\n   */\n  get buffer() {\n    return this._buffer;\n  }\n  set buffer(buffer) {\n    this._buffer.set(buffer);\n  }\n  /**\n   * If the buffer should loop once it's over.\n   * @example\n   * const player = new Tone.Player(\"https://tonejs.github.io/audio/drum-samples/breakbeat.mp3\").toDestination();\n   * player.loop = true;\n   * player.autostart = true;\n   */\n  get loop() {\n    return this._loop;\n  }\n  set loop(loop) {\n    // if no change, do nothing\n    if (this._loop === loop) {\n      return;\n    }\n    this._loop = loop;\n    // set the loop of all of the sources\n    this._activeSources.forEach(source => {\n      source.loop = loop;\n    });\n    if (loop) {\n      // remove the next stopEvent\n      const stopEvent = this._state.getNextState(\"stopped\", this.now());\n      if (stopEvent) {\n        this._state.cancel(stopEvent.time);\n      }\n    }\n  }\n  /**\n   * Normal speed is 1. The pitch will change with the playback rate.\n   * @example\n   * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/femalevoices_aa2_A5.mp3\").toDestination();\n   * // play at 1/4 speed\n   * player.playbackRate = 0.25;\n   * // play as soon as the buffer is loaded\n   * player.autostart = true;\n   */\n  get playbackRate() {\n    return this._playbackRate;\n  }\n  set playbackRate(rate) {\n    this._playbackRate = rate;\n    const now = this.now();\n    // cancel the stop event since it's at a different time now\n    const stopEvent = this._state.getNextState(\"stopped\", now);\n    if (stopEvent && stopEvent.implicitEnd) {\n      this._state.cancel(stopEvent.time);\n      this._activeSources.forEach(source => source.cancelStop());\n    }\n    // set all the sources\n    this._activeSources.forEach(source => {\n      source.playbackRate.setValueAtTime(rate, now);\n    });\n  }\n  /**\n   * If the buffer should be reversed\n   * @example\n   * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/chime_1.mp3\").toDestination();\n   * player.autostart = true;\n   * player.reverse = true;\n   */\n  get reverse() {\n    return this._buffer.reverse;\n  }\n  set reverse(rev) {\n    this._buffer.reverse = rev;\n  }\n  /**\n   * If the buffer is loaded\n   */\n  get loaded() {\n    return this._buffer.loaded;\n  }\n  dispose() {\n    super.dispose();\n    // disconnect all of the players\n    this._activeSources.forEach(source => source.dispose());\n    this._activeSources.clear();\n    this._buffer.dispose();\n    return this;\n  }\n}\n__decorate([timeRange(0)], Player.prototype, \"fadeIn\", void 0);\n__decorate([timeRange(0)], Player.prototype, \"fadeOut\", void 0);","map":{"version":3,"names":["ToneAudioBuffer","defaultArg","optionsFromArguments","noOp","isUndef","Source","ToneBufferSource","assertRange","timeRange","Player","constructor","getDefaults","arguments","name","_activeSources","Set","options","_buffer","onload","_onload","bind","onerror","reverse","url","autostart","_loop","loop","_loopStart","loopStart","_loopEnd","loopEnd","_playbackRate","playbackRate","fadeIn","fadeOut","Object","assign","load","callback","length","undefined","start","_onSourceEnd","source","onstop","delete","size","_synced","_state","getValueAtTime","now","cancel","setStateAtTime","time","offset","duration","_start","startTime","computedOffset","toSeconds","origDuration","Math","max","computedDuration","context","onended","connect","output","implicitEnd","add","_stop","computedTime","forEach","stop","restart","_restart","seek","when","setLoopPoints","buffer","loaded","set","stopEvent","getNextState","rate","cancelStop","setValueAtTime","rev","dispose","clear","__decorate"],"sources":["/Users/ianstrom/Development/code/Capstone/node_modules/tone/Tone/source/buffer/Player.ts"],"sourcesContent":["import { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { Positive, Seconds, Time } from \"../../core/type/Units\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp } from \"../../core/util/Interface\";\nimport { isUndef } from \"../../core/util/TypeCheck\";\nimport { Source, SourceOptions } from \"../Source\";\nimport { ToneBufferSource } from \"./ToneBufferSource\";\nimport { assertRange } from \"../../core/util/Debug\";\nimport { timeRange } from \"../../core/util/Decorator\";\n\nexport interface PlayerOptions extends SourceOptions {\n\tonload: () => void;\n\tonerror: (error: Error) => void;\n\tplaybackRate: Positive;\n\tloop: boolean;\n\tautostart: boolean;\n\tloopStart: Time;\n\tloopEnd: Time;\n\treverse: boolean;\n\tfadeIn: Time;\n\tfadeOut: Time;\n\turl?: ToneAudioBuffer | string | AudioBuffer;\n}\n\n/**\n * Player is an audio file player with start, loop, and stop functions.\n * @example\n * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/gong_1.mp3\").toDestination();\n * // play as soon as the buffer is loaded\n * player.autostart = true;\n * @category Source\n */\nexport class Player extends Source<PlayerOptions> {\n\n\treadonly name: string = \"Player\";\n\n\t/**\n\t * If the file should play as soon\n\t * as the buffer is loaded.\n\t */\n\tautostart: boolean;\n\n\t/**\n\t * The buffer\n\t */\n\tprivate _buffer: ToneAudioBuffer;\n\n\t/**\n\t * if the buffer should loop once it's over\n\t */\n\tprivate _loop: boolean;\n\n\t/**\n\t * if 'loop' is true, the loop will start at this position\n\t */\n\tprivate _loopStart: Time;\n\n\t/**\n\t * if 'loop' is true, the loop will end at this position\n\t */\n\tprivate _loopEnd: Time;\n\n\t/**\n\t * the playback rate\n\t */\n\tprivate _playbackRate: Positive;\n\n\t/**\n\t * All of the active buffer source nodes\n\t */\n\tprivate _activeSources: Set<ToneBufferSource> = new Set();\n\n\t/**\n\t * The fadeIn time of the amplitude envelope.\n\t */\n\t@timeRange(0)\n\tfadeIn: Time;\n\n\t/**\n\t * The fadeOut time of the amplitude envelope.\n\t */\n\t@timeRange(0)\n\tfadeOut: Time;\n\n\t/**\n\t * @param url Either the AudioBuffer or the url from which to load the AudioBuffer\n\t * @param onload The function to invoke when the buffer is loaded.\n\t */\n\tconstructor(url?: string | AudioBuffer | ToneAudioBuffer, onload?: () => void);\n\tconstructor(options?: Partial<PlayerOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Player.getDefaults(), arguments, [\"url\", \"onload\"]));\n\t\tconst options = optionsFromArguments(Player.getDefaults(), arguments, [\"url\", \"onload\"]);\n\n\t\tthis._buffer = new ToneAudioBuffer({\n\t\t\tonload: this._onload.bind(this, options.onload),\n\t\t\tonerror: options.onerror,\n\t\t\treverse: options.reverse,\n\t\t\turl: options.url,\n\t\t});\n\t\tthis.autostart = options.autostart;\n\t\tthis._loop = options.loop;\n\t\tthis._loopStart = options.loopStart;\n\t\tthis._loopEnd = options.loopEnd;\n\t\tthis._playbackRate = options.playbackRate;\n\t\tthis.fadeIn = options.fadeIn;\n\t\tthis.fadeOut = options.fadeOut;\n\t}\n\n\tstatic getDefaults(): PlayerOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tautostart: false,\n\t\t\tfadeIn: 0,\n\t\t\tfadeOut: 0,\n\t\t\tloop: false,\n\t\t\tloopEnd: 0,\n\t\t\tloopStart: 0,\n\t\t\tonload: noOp,\n\t\t\tonerror: noOp,\n\t\t\tplaybackRate: 1,\n\t\t\treverse: false,\n\t\t});\n\t}\n\n\t/**\n\t * Load the audio file as an audio buffer.\n\t * Decodes the audio asynchronously and invokes\n\t * the callback once the audio buffer loads.\n\t * Note: this does not need to be called if a url\n\t * was passed in to the constructor. Only use this\n\t * if you want to manually load a new url.\n\t * @param url The url of the buffer to load. Filetype support depends on the browser.\n\t */\n\tasync load(url: string): Promise<this> {\n\t\tawait this._buffer.load(url);\n\t\tthis._onload();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Internal callback when the buffer is loaded.\n\t */\n\tprivate _onload(callback: () => void = noOp): void {\n\t\tcallback();\n\t\tif (this.autostart) {\n\t\t\tthis.start();\n\t\t}\n\t}\n\n\t/**\n\t * Internal callback when the buffer is done playing.\n\t */\n\tprivate _onSourceEnd(source: ToneBufferSource): void {\n\t\t// invoke the onstop function\n\t\tthis.onstop(this);\n\n\t\t// delete the source from the active sources\n\t\tthis._activeSources.delete(source);\n\t\tif (this._activeSources.size === 0 && !this._synced &&\n\t\t\tthis._state.getValueAtTime(this.now()) === \"started\") {\n\t\t\t// remove the 'implicitEnd' event and replace with an explicit end\n\t\t\tthis._state.cancel(this.now());\n\t\t\tthis._state.setStateAtTime(\"stopped\", this.now());\n\t\t}\n\t}\n\n\t/**\n\t * Play the buffer at the given startTime. Optionally add an offset\n\t * and/or duration which will play the buffer from a position\n\t * within the buffer for the given duration.\n\t *\n\t * @param  time When the player should start.\n\t * @param  offset The offset from the beginning of the sample to start at.\n\t * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)\n\t */\n\tstart(time?: Time, offset?: Time, duration?: Time): this {\n\t\tsuper.start(time, offset, duration);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Internal start method\n\t */\n\tprotected _start(startTime?: Time, offset?: Time, duration?: Time): void {\n\t\t// if it's a loop the default offset is the loopStart point\n\t\tif (this._loop) {\n\t\t\toffset = defaultArg(offset, this._loopStart);\n\t\t} else {\n\t\t\t// otherwise the default offset is 0\n\t\t\toffset = defaultArg(offset, 0);\n\t\t}\n\n\t\t// compute the values in seconds\n\t\tconst computedOffset = this.toSeconds(offset);\n\n\t\t// compute the duration which is either the passed in duration of the buffer.duration - offset\n\t\tconst origDuration = duration;\n\t\tduration = defaultArg(duration, Math.max(this._buffer.duration - computedOffset, 0));\n\t\tlet computedDuration = this.toSeconds(duration);\n\n\t\t// scale it by the playback rate\n\t\tcomputedDuration = computedDuration / this._playbackRate;\n\n\t\t// get the start time\n\t\tstartTime = this.toSeconds(startTime);\n\n\t\t// make the source\n\t\tconst source = new ToneBufferSource({\n\t\t\turl: this._buffer,\n\t\t\tcontext: this.context,\n\t\t\tfadeIn: this.fadeIn,\n\t\t\tfadeOut: this.fadeOut,\n\t\t\tloop: this._loop,\n\t\t\tloopEnd: this._loopEnd,\n\t\t\tloopStart: this._loopStart,\n\t\t\tonended: this._onSourceEnd.bind(this),\n\t\t\tplaybackRate: this._playbackRate,\n\t\t}).connect(this.output);\n\n\t\t// set the looping properties\n\t\tif (!this._loop && !this._synced) {\n\t\t\t// cancel the previous stop\n\t\t\tthis._state.cancel(startTime + computedDuration);\n\t\t\t// if it's not looping, set the state change at the end of the sample\n\t\t\tthis._state.setStateAtTime(\"stopped\", startTime + computedDuration, {\n\t\t\t\timplicitEnd: true,\n\t\t\t});\n\t\t}\n\n\t\t// add it to the array of active sources\n\t\tthis._activeSources.add(source);\n\n\t\t// start it\n\t\tif (this._loop && isUndef(origDuration)) {\n\t\t\tsource.start(startTime, computedOffset);\n\t\t} else {\n\t\t\t// subtract the fade out time\n\t\t\tsource.start(startTime, computedOffset, computedDuration - this.toSeconds(this.fadeOut));\n\t\t}\n\t}\n\n\t/**\n\t * Stop playback.\n\t */\n\tprotected _stop(time?: Time): void {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._activeSources.forEach(source => source.stop(computedTime));\n\t}\n\n\t/**\n\t * Stop and then restart the player from the beginning (or offset)\n\t * @param  time When the player should start.\n\t * @param  offset The offset from the beginning of the sample to start at.\n\t * @param  duration How long the sample should play. If no duration is given, \n\t * \t\t\t\t\tit will default to the full length of the sample (minus any offset)\n\t */\n\trestart(time?: Seconds, offset?: Time, duration?: Time): this {\n\t\tsuper.restart(time, offset, duration);\n\t\treturn this;\n\t}\n\n\tprotected _restart(time?: Seconds, offset?: Time, duration?: Time): void {\n\t\tthis._stop(time);\n\t\tthis._start(time, offset, duration);\n\t}\n\n\t/**\n\t * Seek to a specific time in the player's buffer. If the\n\t * source is no longer playing at that time, it will stop.\n\t * @param offset The time to seek to.\n\t * @param when The time for the seek event to occur.\n\t * @example\n\t * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/gurgling_theremin_1.mp3\", () => {\n\t * \tplayer.start();\n\t * \t// seek to the offset in 1 second from now\n\t * \tplayer.seek(0.4, \"+1\");\n\t * }).toDestination();\n\t */\n\tseek(offset: Time, when?: Time): this {\n\t\tconst computedTime = this.toSeconds(when);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tconst computedOffset = this.toSeconds(offset);\n\t\t\t// if it's currently playing, stop it\n\t\t\tthis._stop(computedTime);\n\t\t\t// restart it at the given time\n\t\t\tthis._start(computedTime, computedOffset);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the loop start and end. Will only loop if loop is set to true.\n\t * @param loopStart The loop start time\n\t * @param loopEnd The loop end time\n\t * @example\n\t * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/malevoices_aa2_F3.mp3\").toDestination();\n\t * // loop between the given points\n\t * player.setLoopPoints(0.2, 0.3);\n\t * player.loop = true;\n\t * player.autostart = true;\n\t */\n\tsetLoopPoints(loopStart: Time, loopEnd: Time): this {\n\t\tthis.loopStart = loopStart;\n\t\tthis.loopEnd = loopEnd;\n\t\treturn this;\n\t}\n\n\t/**\n\t * If loop is true, the loop will start at this position.\n\t */\n\tget loopStart(): Time {\n\t\treturn this._loopStart;\n\t}\n\tset loopStart(loopStart) {\n\t\tthis._loopStart = loopStart;\n\t\tif (this.buffer.loaded) {\n\t\t\tassertRange(this.toSeconds(loopStart), 0, this.buffer.duration);\n\t\t}\n\t\t// get the current source\n\t\tthis._activeSources.forEach(source => {\n\t\t\tsource.loopStart = loopStart;\n\t\t});\n\t}\n\n\t/**\n\t * If loop is true, the loop will end at this position.\n\t */\n\tget loopEnd(): Time {\n\t\treturn this._loopEnd;\n\t}\n\tset loopEnd(loopEnd) {\n\t\tthis._loopEnd = loopEnd;\n\t\tif (this.buffer.loaded) {\n\t\t\tassertRange(this.toSeconds(loopEnd), 0, this.buffer.duration);\n\t\t}\n\t\t// get the current source\n\t\tthis._activeSources.forEach(source => {\n\t\t\tsource.loopEnd = loopEnd;\n\t\t});\n\t}\n\n\t/**\n\t * The audio buffer belonging to the player.\n\t */\n\tget buffer(): ToneAudioBuffer {\n\t\treturn this._buffer;\n\t}\n\tset buffer(buffer) {\n\t\tthis._buffer.set(buffer);\n\t}\n\n\t/**\n\t * If the buffer should loop once it's over.\n\t * @example\n\t * const player = new Tone.Player(\"https://tonejs.github.io/audio/drum-samples/breakbeat.mp3\").toDestination();\n\t * player.loop = true;\n\t * player.autostart = true;\n\t */\n\tget loop(): boolean {\n\t\treturn this._loop;\n\t}\n\tset loop(loop) {\n\t\t// if no change, do nothing\n\t\tif (this._loop === loop) {\n\t\t\treturn;\n\t\t}\n\t\tthis._loop = loop;\n\t\t// set the loop of all of the sources\n\t\tthis._activeSources.forEach(source => {\n\t\t\tsource.loop = loop;\n\t\t});\n\t\tif (loop) {\n\t\t\t// remove the next stopEvent\n\t\t\tconst stopEvent = this._state.getNextState(\"stopped\", this.now());\n\t\t\tif (stopEvent) {\n\t\t\t\tthis._state.cancel(stopEvent.time);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Normal speed is 1. The pitch will change with the playback rate.\n\t * @example\n\t * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/femalevoices_aa2_A5.mp3\").toDestination();\n\t * // play at 1/4 speed\n\t * player.playbackRate = 0.25;\n\t * // play as soon as the buffer is loaded\n\t * player.autostart = true;\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._playbackRate = rate;\n\t\tconst now = this.now();\n\n\t\t// cancel the stop event since it's at a different time now\n\t\tconst stopEvent = this._state.getNextState(\"stopped\", now);\n\t\tif (stopEvent && stopEvent.implicitEnd) {\n\t\t\tthis._state.cancel(stopEvent.time);\n\t\t\tthis._activeSources.forEach(source => source.cancelStop());\n\t\t}\n\n\t\t// set all the sources\n\t\tthis._activeSources.forEach(source => {\n\t\t\tsource.playbackRate.setValueAtTime(rate, now);\n\t\t});\n\t}\n\n\t/**\n\t * If the buffer should be reversed\n\t * @example\n\t * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/chime_1.mp3\").toDestination();\n\t * player.autostart = true;\n\t * player.reverse = true;\n\t */\n\tget reverse(): boolean {\n\t\treturn this._buffer.reverse;\n\t}\n\tset reverse(rev) {\n\t\tthis._buffer.reverse = rev;\n\t}\n\n\t/**\n\t * If the buffer is loaded\n\t */\n\tget loaded(): boolean {\n\t\treturn this._buffer.loaded;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\t// disconnect all of the players\n\t\tthis._activeSources.forEach(source => source.dispose());\n\t\tthis._activeSources.clear();\n\t\tthis._buffer.dispose();\n\t\treturn this;\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}