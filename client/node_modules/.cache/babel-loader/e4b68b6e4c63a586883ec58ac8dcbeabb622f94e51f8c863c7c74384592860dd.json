{"ast":null,"code":"import { ToneEvent } from \"./ToneEvent\";\nimport { ToneWithContext } from \"../core/context/ToneWithContext\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\n/**\n * Loop creates a looped callback at the\n * specified interval. The callback can be\n * started, stopped and scheduled along\n * the Transport's timeline.\n * @example\n * const loop = new Tone.Loop((time) => {\n * \t// triggered every eighth note.\n * \tconsole.log(time);\n * }, \"8n\").start(0);\n * Tone.Transport.start();\n * @category Event\n */\nexport class Loop extends ToneWithContext {\n  constructor() {\n    super(optionsFromArguments(Loop.getDefaults(), arguments, [\"callback\", \"interval\"]));\n    this.name = \"Loop\";\n    const options = optionsFromArguments(Loop.getDefaults(), arguments, [\"callback\", \"interval\"]);\n    this._event = new ToneEvent({\n      context: this.context,\n      callback: this._tick.bind(this),\n      loop: true,\n      loopEnd: options.interval,\n      playbackRate: options.playbackRate,\n      probability: options.probability\n    });\n    this.callback = options.callback;\n    // set the iterations\n    this.iterations = options.iterations;\n  }\n  static getDefaults() {\n    return Object.assign(ToneWithContext.getDefaults(), {\n      interval: \"4n\",\n      callback: noOp,\n      playbackRate: 1,\n      iterations: Infinity,\n      probability: 1,\n      mute: false,\n      humanize: false\n    });\n  }\n  /**\n   * Start the loop at the specified time along the Transport's timeline.\n   * @param  time  When to start the Loop.\n   */\n  start(time) {\n    this._event.start(time);\n    return this;\n  }\n  /**\n   * Stop the loop at the given time.\n   * @param  time  When to stop the Loop.\n   */\n  stop(time) {\n    this._event.stop(time);\n    return this;\n  }\n  /**\n   * Cancel all scheduled events greater than or equal to the given time\n   * @param  time  The time after which events will be cancel.\n   */\n  cancel(time) {\n    this._event.cancel(time);\n    return this;\n  }\n  /**\n   * Internal function called when the notes should be called\n   * @param time  The time the event occurs\n   */\n  _tick(time) {\n    this.callback(time);\n  }\n  /**\n   * The state of the Loop, either started or stopped.\n   */\n  get state() {\n    return this._event.state;\n  }\n  /**\n   * The progress of the loop as a value between 0-1. 0, when the loop is stopped or done iterating.\n   */\n  get progress() {\n    return this._event.progress;\n  }\n  /**\n   * The time between successive callbacks.\n   * @example\n   * const loop = new Tone.Loop();\n   * loop.interval = \"8n\"; // loop every 8n\n   */\n  get interval() {\n    return this._event.loopEnd;\n  }\n  set interval(interval) {\n    this._event.loopEnd = interval;\n  }\n  /**\n   * The playback rate of the loop. The normal playback rate is 1 (no change).\n   * A `playbackRate` of 2 would be twice as fast.\n   */\n  get playbackRate() {\n    return this._event.playbackRate;\n  }\n  set playbackRate(rate) {\n    this._event.playbackRate = rate;\n  }\n  /**\n   * Random variation +/-0.01s to the scheduled time.\n   * Or give it a time value which it will randomize by.\n   */\n  get humanize() {\n    return this._event.humanize;\n  }\n  set humanize(variation) {\n    this._event.humanize = variation;\n  }\n  /**\n   * The probably of the callback being invoked.\n   */\n  get probability() {\n    return this._event.probability;\n  }\n  set probability(prob) {\n    this._event.probability = prob;\n  }\n  /**\n   * Muting the Loop means that no callbacks are invoked.\n   */\n  get mute() {\n    return this._event.mute;\n  }\n  set mute(mute) {\n    this._event.mute = mute;\n  }\n  /**\n   * The number of iterations of the loop. The default value is `Infinity` (loop forever).\n   */\n  get iterations() {\n    if (this._event.loop === true) {\n      return Infinity;\n    } else {\n      return this._event.loop;\n    }\n  }\n  set iterations(iters) {\n    if (iters === Infinity) {\n      this._event.loop = true;\n    } else {\n      this._event.loop = iters;\n    }\n  }\n  dispose() {\n    super.dispose();\n    this._event.dispose();\n    return this;\n  }\n}","map":{"version":3,"names":["ToneEvent","ToneWithContext","optionsFromArguments","noOp","Loop","constructor","getDefaults","arguments","name","options","_event","context","callback","_tick","bind","loop","loopEnd","interval","playbackRate","probability","iterations","Object","assign","Infinity","mute","humanize","start","time","stop","cancel","state","progress","rate","variation","prob","iters","dispose"],"sources":["/Users/ianstrom/Development/code/Capstone/node_modules/tone/Tone/event/Loop.ts"],"sourcesContent":["import { ToneEvent } from \"./ToneEvent\";\nimport { NormalRange, Positive, Seconds, Time, TransportTime } from \"../core/type/Units\";\nimport { ToneWithContext, ToneWithContextOptions } from \"../core/context/ToneWithContext\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { BasicPlaybackState } from \"../core/util/StateTimeline\";\n\nexport interface LoopOptions extends ToneWithContextOptions {\n\tcallback: (time: Seconds) => void;\n\tinterval: Time;\n\tplaybackRate: Positive;\n\titerations: number;\n\tprobability: NormalRange;\n\tmute: boolean;\n\thumanize: boolean | Time;\n}\n\n/**\n * Loop creates a looped callback at the \n * specified interval. The callback can be \n * started, stopped and scheduled along\n * the Transport's timeline. \n * @example\n * const loop = new Tone.Loop((time) => {\n * \t// triggered every eighth note. \n * \tconsole.log(time);\n * }, \"8n\").start(0);\n * Tone.Transport.start();\n * @category Event\n */\nexport class Loop<Options extends LoopOptions = LoopOptions> extends ToneWithContext<Options> {\n\n\treadonly name: string = \"Loop\";\n\n\t/**\n\t * The event which produces the callbacks\n\t */\n\tprivate _event: ToneEvent;\n\n\t/**\n\t * The callback to invoke with the next event in the pattern\n\t */\n\tcallback: (time: Seconds) => void\n\n\t/**\n\t * @param callback The callback to invoke at the time.\n\t * @param interval The time between successive callback calls. \n\t */\n\tconstructor(callback?: (time: Seconds) => void, interval?: Time);\n\tconstructor(options?: Partial<LoopOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Loop.getDefaults(), arguments, [\"callback\", \"interval\"]));\n\t\tconst options = optionsFromArguments(Loop.getDefaults(), arguments, [\"callback\", \"interval\"]);\n\n\t\tthis._event = new ToneEvent({\n\t\t\tcontext: this.context,\n\t\t\tcallback: this._tick.bind(this),\n\t\t\tloop: true,\n\t\t\tloopEnd: options.interval,\n\t\t\tplaybackRate: options.playbackRate,\n\t\t\tprobability: options.probability\n\t\t});\n\n\t\tthis.callback = options.callback;\n\t\t// set the iterations\n\t\tthis.iterations = options.iterations;\n\t}\n\n\tstatic getDefaults(): LoopOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tinterval: \"4n\",\n\t\t\tcallback: noOp,\n\t\t\tplaybackRate: 1,\n\t\t\titerations: Infinity,\n\t\t\tprobability: 1,\n\t\t\tmute: false,\n\t\t\thumanize: false\n\t\t});\n\t}\n\n\t/**\n\t * Start the loop at the specified time along the Transport's timeline.\n\t * @param  time  When to start the Loop.\n\t */\n\tstart(time?: TransportTime): this {\n\t\tthis._event.start(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the loop at the given time.\n\t * @param  time  When to stop the Loop.\n\t */\n\tstop(time?: TransportTime): this {\n\t\tthis._event.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel all scheduled events greater than or equal to the given time\n\t * @param  time  The time after which events will be cancel.\n\t */\n\tcancel(time?: TransportTime): this {\n\t\tthis._event.cancel(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Internal function called when the notes should be called\n\t * @param time  The time the event occurs\n\t */\n\tprotected _tick(time: Seconds): void {\n\t\tthis.callback(time);\n\t}\n\n\t/**\n\t * The state of the Loop, either started or stopped.\n\t */\n\tget state(): BasicPlaybackState {\n\t\treturn this._event.state;\n\t}\n\n\t/**\n\t * The progress of the loop as a value between 0-1. 0, when the loop is stopped or done iterating. \n\t */\n\tget progress(): NormalRange {\n\t\treturn this._event.progress;\n\t}\n\n\t/**\n\t * The time between successive callbacks. \n\t * @example\n\t * const loop = new Tone.Loop();\n\t * loop.interval = \"8n\"; // loop every 8n\n\t */\n\tget interval(): Time {\n\t\treturn this._event.loopEnd;\n\t}\n\tset interval(interval) {\n\t\tthis._event.loopEnd = interval;\n\t}\n\n\t/**\n\t * The playback rate of the loop. The normal playback rate is 1 (no change). \n\t * A `playbackRate` of 2 would be twice as fast. \n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._event.playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._event.playbackRate = rate;\n\t}\n\n\t/**\n\t * Random variation +/-0.01s to the scheduled time. \n\t * Or give it a time value which it will randomize by.\n\t */\n\tget humanize(): boolean | Time {\n\t\treturn this._event.humanize;\n\t}\n\tset humanize(variation) {\n\t\tthis._event.humanize = variation;\n\t}\n\n\t/**\n\t * The probably of the callback being invoked.\n\t */\n\tget probability(): NormalRange {\n\t\treturn this._event.probability;\n\t}\n\n\tset probability(prob) {\n\t\tthis._event.probability = prob;\n\t}\n\n\t/**\n\t * Muting the Loop means that no callbacks are invoked.\n\t */\n\tget mute(): boolean {\n\t\treturn this._event.mute;\n\t}\n\n\tset mute(mute) {\n\t\tthis._event.mute = mute;\n\t}\n\n\t/**\n\t * The number of iterations of the loop. The default value is `Infinity` (loop forever).\n\t */\n\tget iterations(): number {\n\t\tif (this._event.loop === true) {\n\t\t\treturn Infinity;\n\t\t} else {\n\t\t\treturn this._event.loop as number;\n\t\t}\n\t}\n\tset iterations(iters) {\n\t\tif (iters === Infinity) {\n\t\t\tthis._event.loop = true;\n\t\t} else {\n\t\t\tthis._event.loop = iters;\n\t\t}\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._event.dispose();\n\t\treturn this;\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}