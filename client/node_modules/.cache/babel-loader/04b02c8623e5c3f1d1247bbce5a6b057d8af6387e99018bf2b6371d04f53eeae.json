{"ast":null,"code":"import { connect } from \"../../core/context/ToneAudioNode\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { assert } from \"../../core/util/Debug\";\nimport { OneShotSource } from \"../OneShotSource\";\nimport { EQ, GTE, LT } from \"../../core/util/Math\";\n/**\n * Wrapper around the native BufferSourceNode.\n * @category Source\n */\nexport class ToneBufferSource extends OneShotSource {\n  constructor() {\n    super(optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"url\", \"onload\"]));\n    this.name = \"ToneBufferSource\";\n    /**\n     * The oscillator\n     */\n    this._source = this.context.createBufferSource();\n    this._internalChannels = [this._source];\n    /**\n     * indicators if the source has started/stopped\n     */\n    this._sourceStarted = false;\n    this._sourceStopped = false;\n    const options = optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"url\", \"onload\"]);\n    connect(this._source, this._gainNode);\n    this._source.onended = () => this._stopSource();\n    /**\n     * The playbackRate of the buffer\n     */\n    this.playbackRate = new Param({\n      context: this.context,\n      param: this._source.playbackRate,\n      units: \"positive\",\n      value: options.playbackRate\n    });\n    // set some values initially\n    this.loop = options.loop;\n    this.loopStart = options.loopStart;\n    this.loopEnd = options.loopEnd;\n    this._buffer = new ToneAudioBuffer(options.url, options.onload, options.onerror);\n    this._internalChannels.push(this._source);\n  }\n  static getDefaults() {\n    return Object.assign(OneShotSource.getDefaults(), {\n      url: new ToneAudioBuffer(),\n      loop: false,\n      loopEnd: 0,\n      loopStart: 0,\n      onload: noOp,\n      onerror: noOp,\n      playbackRate: 1\n    });\n  }\n  /**\n   * The fadeIn time of the amplitude envelope.\n   */\n  get fadeIn() {\n    return this._fadeIn;\n  }\n  set fadeIn(t) {\n    this._fadeIn = t;\n  }\n  /**\n   * The fadeOut time of the amplitude envelope.\n   */\n  get fadeOut() {\n    return this._fadeOut;\n  }\n  set fadeOut(t) {\n    this._fadeOut = t;\n  }\n  /**\n   * The curve applied to the fades, either \"linear\" or \"exponential\"\n   */\n  get curve() {\n    return this._curve;\n  }\n  set curve(t) {\n    this._curve = t;\n  }\n  /**\n   * Start the buffer\n   * @param  time When the player should start.\n   * @param  offset The offset from the beginning of the sample to start at.\n   * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)\n   * @param  gain  The gain to play the buffer back at.\n   */\n  start(time, offset, duration) {\n    let gain = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    assert(this.buffer.loaded, \"buffer is either not set or not loaded\");\n    const computedTime = this.toSeconds(time);\n    // apply the gain envelope\n    this._startGain(computedTime, gain);\n    // if it's a loop the default offset is the loopstart point\n    if (this.loop) {\n      offset = defaultArg(offset, this.loopStart);\n    } else {\n      // otherwise the default offset is 0\n      offset = defaultArg(offset, 0);\n    }\n    // make sure the offset is not less than 0\n    let computedOffset = Math.max(this.toSeconds(offset), 0);\n    // start the buffer source\n    if (this.loop) {\n      // modify the offset if it's greater than the loop time\n      const loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n      const loopStart = this.toSeconds(this.loopStart);\n      const loopDuration = loopEnd - loopStart;\n      // move the offset back\n      if (GTE(computedOffset, loopEnd)) {\n        computedOffset = (computedOffset - loopStart) % loopDuration + loopStart;\n      }\n      // when the offset is very close to the duration, set it to 0\n      if (EQ(computedOffset, this.buffer.duration)) {\n        computedOffset = 0;\n      }\n    }\n    // this.buffer.loaded would have return false if the AudioBuffer was undefined\n    this._source.buffer = this.buffer.get();\n    this._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n    if (LT(computedOffset, this.buffer.duration)) {\n      this._sourceStarted = true;\n      this._source.start(computedTime, computedOffset);\n    }\n    // if a duration is given, schedule a stop\n    if (isDefined(duration)) {\n      let computedDur = this.toSeconds(duration);\n      // make sure it's never negative\n      computedDur = Math.max(computedDur, 0);\n      this.stop(computedTime + computedDur);\n    }\n    return this;\n  }\n  _stopSource(time) {\n    if (!this._sourceStopped && this._sourceStarted) {\n      this._sourceStopped = true;\n      this._source.stop(this.toSeconds(time));\n      this._onended();\n    }\n  }\n  /**\n   * If loop is true, the loop will start at this position.\n   */\n  get loopStart() {\n    return this._source.loopStart;\n  }\n  set loopStart(loopStart) {\n    this._source.loopStart = this.toSeconds(loopStart);\n  }\n  /**\n   * If loop is true, the loop will end at this position.\n   */\n  get loopEnd() {\n    return this._source.loopEnd;\n  }\n  set loopEnd(loopEnd) {\n    this._source.loopEnd = this.toSeconds(loopEnd);\n  }\n  /**\n   * The audio buffer belonging to the player.\n   */\n  get buffer() {\n    return this._buffer;\n  }\n  set buffer(buffer) {\n    this._buffer.set(buffer);\n  }\n  /**\n   * If the buffer should loop once it's over.\n   */\n  get loop() {\n    return this._source.loop;\n  }\n  set loop(loop) {\n    this._source.loop = loop;\n    if (this._sourceStarted) {\n      this.cancelStop();\n    }\n  }\n  /**\n   * Clean up.\n   */\n  dispose() {\n    super.dispose();\n    this._source.onended = null;\n    this._source.disconnect();\n    this._buffer.dispose();\n    this.playbackRate.dispose();\n    return this;\n  }\n}","map":{"version":3,"names":["connect","Param","ToneAudioBuffer","defaultArg","optionsFromArguments","noOp","isDefined","assert","OneShotSource","EQ","GTE","LT","ToneBufferSource","constructor","getDefaults","arguments","name","_source","context","createBufferSource","_internalChannels","_sourceStarted","_sourceStopped","options","_gainNode","onended","_stopSource","playbackRate","param","units","value","loop","loopStart","loopEnd","_buffer","url","onload","onerror","push","Object","assign","fadeIn","_fadeIn","t","fadeOut","_fadeOut","curve","_curve","start","time","offset","duration","gain","length","undefined","buffer","loaded","computedTime","toSeconds","_startGain","computedOffset","Math","max","loopDuration","get","computedDur","stop","_onended","set","cancelStop","dispose","disconnect"],"sources":["/Users/ianstrom/Development/code/Capstone/node_modules/tone/Tone/source/buffer/ToneBufferSource.ts"],"sourcesContent":["import { connect } from \"../../core/context/ToneAudioNode\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { GainFactor, Positive, Seconds, Time } from \"../../core/type/Units\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { assert } from \"../../core/util/Debug\";\nimport { OneShotSource, OneShotSourceCurve, OneShotSourceOptions } from \"../OneShotSource\";\nimport { EQ, GTE, LT } from \"../../core/util/Math\";\n\nexport type ToneBufferSourceCurve = OneShotSourceCurve;\n\nexport interface ToneBufferSourceOptions extends OneShotSourceOptions {\n\turl: string | AudioBuffer | ToneAudioBuffer;\n\tcurve: ToneBufferSourceCurve;\n\tplaybackRate: Positive;\n\tfadeIn: Time;\n\tfadeOut: Time;\n\tloopStart: Time;\n\tloopEnd: Time;\n\tloop: boolean;\n\tonload: () => void;\n\tonerror: (error: Error) => void;\n}\n\n/**\n * Wrapper around the native BufferSourceNode.\n * @category Source\n */\nexport class ToneBufferSource extends OneShotSource<ToneBufferSourceOptions> {\n\n\treadonly name: string = \"ToneBufferSource\";\n\n\t/**\n\t * The oscillator\n\t */\n\tprivate _source = this.context.createBufferSource();\n\tprotected _internalChannels = [this._source];\n\n\t/**\n\t * The frequency of the oscillator\n\t */\n\treadonly playbackRate: Param<\"positive\">;\n\n\t/**\n\t * The private instance of the buffer object\n\t */\n\tprivate _buffer: ToneAudioBuffer;\n\n\t/**\n\t * indicators if the source has started/stopped\n\t */\n\tprivate _sourceStarted = false;\n\tprivate _sourceStopped = false;\n\n\t/**\n\t * @param url The buffer to play or url to load\n\t * @param onload The callback to invoke when the buffer is done playing.\n\t */\n\tconstructor(url?: ToneAudioBuffer | AudioBuffer | string, onload?: () => void);\n\tconstructor(options?: Partial<ToneBufferSourceOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"url\", \"onload\"]));\n\t\tconst options = optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"url\", \"onload\"]);\n\n\t\tconnect(this._source, this._gainNode);\n\t\tthis._source.onended = () => this._stopSource();\n\n\t\t/**\n\t\t * The playbackRate of the buffer\n\t\t */\n\t\tthis.playbackRate = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._source.playbackRate,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.playbackRate,\n\t\t});\n\n\t\t// set some values initially\n\t\tthis.loop = options.loop;\n\t\tthis.loopStart = options.loopStart;\n\t\tthis.loopEnd = options.loopEnd;\n\t\tthis._buffer = new ToneAudioBuffer(options.url, options.onload, options.onerror);\n\n\t\tthis._internalChannels.push(this._source);\n\t}\n\n\tstatic getDefaults(): ToneBufferSourceOptions {\n\t\treturn Object.assign(OneShotSource.getDefaults(), {\n\t\t\turl: new ToneAudioBuffer(),\n\t\t\tloop: false,\n\t\t\tloopEnd: 0,\n\t\t\tloopStart: 0,\n\t\t\tonload: noOp,\n\t\t\tonerror: noOp,\n\t\t\tplaybackRate: 1,\n\t\t});\n\t}\n\n\t/**\n\t * The fadeIn time of the amplitude envelope.\n\t */\n\tget fadeIn(): Time {\n\t\treturn this._fadeIn;\n\t}\n\tset fadeIn(t: Time) {\n\t\tthis._fadeIn = t;\n\t}\n\n\t/**\n\t * The fadeOut time of the amplitude envelope.\n\t */\n\tget fadeOut(): Time {\n\t\treturn this._fadeOut;\n\t}\n\tset fadeOut(t: Time) {\n\t\tthis._fadeOut = t;\n\t}\n\n\t/**\n\t * The curve applied to the fades, either \"linear\" or \"exponential\"\n\t */\n\tget curve(): ToneBufferSourceCurve {\n\t\treturn this._curve;\n\t}\n\tset curve(t) {\n\t\tthis._curve = t;\n\t}\n\n\t/**\n\t * Start the buffer\n\t * @param  time When the player should start.\n\t * @param  offset The offset from the beginning of the sample to start at.\n\t * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)\n\t * @param  gain  The gain to play the buffer back at.\n\t */\n\tstart(time?: Time, offset?: Time, duration?: Time, gain: GainFactor = 1): this {\n\t\tassert(this.buffer.loaded, \"buffer is either not set or not loaded\");\n\t\tconst computedTime = this.toSeconds(time);\n\n\t\t// apply the gain envelope\n\t\tthis._startGain(computedTime, gain);\n\n\t\t// if it's a loop the default offset is the loopstart point\n\t\tif (this.loop) {\n\t\t\toffset = defaultArg(offset, this.loopStart);\n\t\t} else {\n\t\t\t// otherwise the default offset is 0\n\t\t\toffset = defaultArg(offset, 0);\n\t\t}\n\t\t// make sure the offset is not less than 0\n\t\tlet computedOffset = Math.max(this.toSeconds(offset), 0);\n\n\t\t// start the buffer source\n\t\tif (this.loop) {\n\t\t\t// modify the offset if it's greater than the loop time\n\t\t\tconst loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n\t\t\tconst loopStart = this.toSeconds(this.loopStart);\n\t\t\tconst loopDuration = loopEnd - loopStart;\n\t\t\t// move the offset back\n\t\t\tif (GTE(computedOffset, loopEnd)) {\n\t\t\t\tcomputedOffset = ((computedOffset - loopStart) % loopDuration) + loopStart;\n\t\t\t}\n\t\t\t// when the offset is very close to the duration, set it to 0\n\t\t\tif (EQ(computedOffset, this.buffer.duration)) {\n\t\t\t\tcomputedOffset = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// this.buffer.loaded would have return false if the AudioBuffer was undefined\n\t\tthis._source.buffer = this.buffer.get() as AudioBuffer;\n\t\tthis._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n\t\tif (LT(computedOffset, this.buffer.duration)) {\n\t\t\tthis._sourceStarted = true;\n\t\t\tthis._source.start(computedTime, computedOffset);\n\t\t}\n\n\t\t// if a duration is given, schedule a stop\n\t\tif (isDefined(duration)) {\n\t\t\tlet computedDur = this.toSeconds(duration);\n\t\t\t// make sure it's never negative\n\t\t\tcomputedDur = Math.max(computedDur, 0);\n\t\t\tthis.stop(computedTime + computedDur);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprotected _stopSource(time?: Seconds): void {\n\t\tif (!this._sourceStopped && this._sourceStarted) {\n\t\t\tthis._sourceStopped = true;\n\t\t\tthis._source.stop(this.toSeconds(time));\n\t\t\tthis._onended();\n\t\t}\n\t}\n\n\t/**\n\t * If loop is true, the loop will start at this position.\n\t */\n\tget loopStart(): Time {\n\t\treturn this._source.loopStart;\n\t}\n\tset loopStart(loopStart: Time) {\n\t\tthis._source.loopStart = this.toSeconds(loopStart);\n\t}\n\n\t/**\n\t * If loop is true, the loop will end at this position.\n\t */\n\tget loopEnd(): Time {\n\t\treturn this._source.loopEnd;\n\t}\n\tset loopEnd(loopEnd: Time) {\n\t\tthis._source.loopEnd = this.toSeconds(loopEnd);\n\t}\n\n\t/**\n\t * The audio buffer belonging to the player.\n\t */\n\tget buffer(): ToneAudioBuffer {\n\t\treturn this._buffer;\n\t}\n\tset buffer(buffer: ToneAudioBuffer) {\n\t\tthis._buffer.set(buffer);\n\t}\n\n\t/**\n\t * If the buffer should loop once it's over.\n\t */\n\tget loop(): boolean {\n\t\treturn this._source.loop;\n\t}\n\tset loop(loop: boolean) {\n\t\tthis._source.loop = loop;\n\t\tif (this._sourceStarted) {\n\t\t\tthis.cancelStop();\n\t\t}\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._source.onended = null;\n\t\tthis._source.disconnect();\n\t\tthis._buffer.dispose();\n\t\tthis.playbackRate.dispose();\n\t\treturn this;\n\t}\n}\n"],"mappings":"AAAA,SAASA,OAAO,QAAQ,kCAAkC;AAC1D,SAASC,KAAK,QAAQ,0BAA0B;AAChD,SAASC,eAAe,QAAQ,oCAAoC;AAEpE,SAASC,UAAU,EAAEC,oBAAoB,QAAQ,0BAA0B;AAC3E,SAASC,IAAI,QAAQ,2BAA2B;AAChD,SAASC,SAAS,QAAQ,2BAA2B;AACrD,SAASC,MAAM,QAAQ,uBAAuB;AAC9C,SAASC,aAAa,QAAkD,kBAAkB;AAC1F,SAASC,EAAE,EAAEC,GAAG,EAAEC,EAAE,QAAQ,sBAAsB;AAiBlD;;;;AAIA,OAAM,MAAOC,gBAAiB,SAAQJ,aAAsC;EAgC3EK,YAAA;IAEC,KAAK,CAACT,oBAAoB,CAACQ,gBAAgB,CAACE,WAAW,EAAE,EAAEC,SAAS,EAAE,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC,CAAC;IAhCjF,KAAAC,IAAI,GAAW,kBAAkB;IAE1C;;;IAGQ,KAAAC,OAAO,GAAG,IAAI,CAACC,OAAO,CAACC,kBAAkB,EAAE;IACzC,KAAAC,iBAAiB,GAAG,CAAC,IAAI,CAACH,OAAO,CAAC;IAY5C;;;IAGQ,KAAAI,cAAc,GAAG,KAAK;IACtB,KAAAC,cAAc,GAAG,KAAK;IAW7B,MAAMC,OAAO,GAAGnB,oBAAoB,CAACQ,gBAAgB,CAACE,WAAW,EAAE,EAAEC,SAAS,EAAE,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;IAElGf,OAAO,CAAC,IAAI,CAACiB,OAAO,EAAE,IAAI,CAACO,SAAS,CAAC;IACrC,IAAI,CAACP,OAAO,CAACQ,OAAO,GAAG,MAAM,IAAI,CAACC,WAAW,EAAE;IAE/C;;;IAGA,IAAI,CAACC,YAAY,GAAG,IAAI1B,KAAK,CAAC;MAC7BiB,OAAO,EAAE,IAAI,CAACA,OAAO;MACrBU,KAAK,EAAE,IAAI,CAACX,OAAO,CAACU,YAAY;MAChCE,KAAK,EAAE,UAAU;MACjBC,KAAK,EAAEP,OAAO,CAACI;KACf,CAAC;IAEF;IACA,IAAI,CAACI,IAAI,GAAGR,OAAO,CAACQ,IAAI;IACxB,IAAI,CAACC,SAAS,GAAGT,OAAO,CAACS,SAAS;IAClC,IAAI,CAACC,OAAO,GAAGV,OAAO,CAACU,OAAO;IAC9B,IAAI,CAACC,OAAO,GAAG,IAAIhC,eAAe,CAACqB,OAAO,CAACY,GAAG,EAAEZ,OAAO,CAACa,MAAM,EAAEb,OAAO,CAACc,OAAO,CAAC;IAEhF,IAAI,CAACjB,iBAAiB,CAACkB,IAAI,CAAC,IAAI,CAACrB,OAAO,CAAC;EAC1C;EAEA,OAAOH,WAAWA,CAAA;IACjB,OAAOyB,MAAM,CAACC,MAAM,CAAChC,aAAa,CAACM,WAAW,EAAE,EAAE;MACjDqB,GAAG,EAAE,IAAIjC,eAAe,EAAE;MAC1B6B,IAAI,EAAE,KAAK;MACXE,OAAO,EAAE,CAAC;MACVD,SAAS,EAAE,CAAC;MACZI,MAAM,EAAE/B,IAAI;MACZgC,OAAO,EAAEhC,IAAI;MACbsB,YAAY,EAAE;KACd,CAAC;EACH;EAEA;;;EAGA,IAAIc,MAAMA,CAAA;IACT,OAAO,IAAI,CAACC,OAAO;EACpB;EACA,IAAID,MAAMA,CAACE,CAAO;IACjB,IAAI,CAACD,OAAO,GAAGC,CAAC;EACjB;EAEA;;;EAGA,IAAIC,OAAOA,CAAA;IACV,OAAO,IAAI,CAACC,QAAQ;EACrB;EACA,IAAID,OAAOA,CAACD,CAAO;IAClB,IAAI,CAACE,QAAQ,GAAGF,CAAC;EAClB;EAEA;;;EAGA,IAAIG,KAAKA,CAAA;IACR,OAAO,IAAI,CAACC,MAAM;EACnB;EACA,IAAID,KAAKA,CAACH,CAAC;IACV,IAAI,CAACI,MAAM,GAAGJ,CAAC;EAChB;EAEA;;;;;;;EAOAK,KAAKA,CAACC,IAAW,EAAEC,MAAa,EAAEC,QAAe,EAAsB;IAAA,IAApBC,IAAA,GAAArC,SAAA,CAAAsC,MAAA,QAAAtC,SAAA,QAAAuC,SAAA,GAAAvC,SAAA,MAAmB,CAAC;IACtER,MAAM,CAAC,IAAI,CAACgD,MAAM,CAACC,MAAM,EAAE,wCAAwC,CAAC;IACpE,MAAMC,YAAY,GAAG,IAAI,CAACC,SAAS,CAACT,IAAI,CAAC;IAEzC;IACA,IAAI,CAACU,UAAU,CAACF,YAAY,EAAEL,IAAI,CAAC;IAEnC;IACA,IAAI,IAAI,CAACrB,IAAI,EAAE;MACdmB,MAAM,GAAG/C,UAAU,CAAC+C,MAAM,EAAE,IAAI,CAAClB,SAAS,CAAC;KAC3C,MAAM;MACN;MACAkB,MAAM,GAAG/C,UAAU,CAAC+C,MAAM,EAAE,CAAC,CAAC;;IAE/B;IACA,IAAIU,cAAc,GAAGC,IAAI,CAACC,GAAG,CAAC,IAAI,CAACJ,SAAS,CAACR,MAAM,CAAC,EAAE,CAAC,CAAC;IAExD;IACA,IAAI,IAAI,CAACnB,IAAI,EAAE;MACd;MACA,MAAME,OAAO,GAAG,IAAI,CAACyB,SAAS,CAAC,IAAI,CAACzB,OAAO,CAAC,IAAI,IAAI,CAACsB,MAAM,CAACJ,QAAQ;MACpE,MAAMnB,SAAS,GAAG,IAAI,CAAC0B,SAAS,CAAC,IAAI,CAAC1B,SAAS,CAAC;MAChD,MAAM+B,YAAY,GAAG9B,OAAO,GAAGD,SAAS;MACxC;MACA,IAAItB,GAAG,CAACkD,cAAc,EAAE3B,OAAO,CAAC,EAAE;QACjC2B,cAAc,GAAI,CAACA,cAAc,GAAG5B,SAAS,IAAI+B,YAAY,GAAI/B,SAAS;;MAE3E;MACA,IAAIvB,EAAE,CAACmD,cAAc,EAAE,IAAI,CAACL,MAAM,CAACJ,QAAQ,CAAC,EAAE;QAC7CS,cAAc,GAAG,CAAC;;;IAIpB;IACA,IAAI,CAAC3C,OAAO,CAACsC,MAAM,GAAG,IAAI,CAACA,MAAM,CAACS,GAAG,EAAiB;IACtD,IAAI,CAAC/C,OAAO,CAACgB,OAAO,GAAG,IAAI,CAACyB,SAAS,CAAC,IAAI,CAACzB,OAAO,CAAC,IAAI,IAAI,CAACsB,MAAM,CAACJ,QAAQ;IAC3E,IAAIxC,EAAE,CAACiD,cAAc,EAAE,IAAI,CAACL,MAAM,CAACJ,QAAQ,CAAC,EAAE;MAC7C,IAAI,CAAC9B,cAAc,GAAG,IAAI;MAC1B,IAAI,CAACJ,OAAO,CAAC+B,KAAK,CAACS,YAAY,EAAEG,cAAc,CAAC;;IAGjD;IACA,IAAItD,SAAS,CAAC6C,QAAQ,CAAC,EAAE;MACxB,IAAIc,WAAW,GAAG,IAAI,CAACP,SAAS,CAACP,QAAQ,CAAC;MAC1C;MACAc,WAAW,GAAGJ,IAAI,CAACC,GAAG,CAACG,WAAW,EAAE,CAAC,CAAC;MACtC,IAAI,CAACC,IAAI,CAACT,YAAY,GAAGQ,WAAW,CAAC;;IAGtC,OAAO,IAAI;EACZ;EAEUvC,WAAWA,CAACuB,IAAc;IACnC,IAAI,CAAC,IAAI,CAAC3B,cAAc,IAAI,IAAI,CAACD,cAAc,EAAE;MAChD,IAAI,CAACC,cAAc,GAAG,IAAI;MAC1B,IAAI,CAACL,OAAO,CAACiD,IAAI,CAAC,IAAI,CAACR,SAAS,CAACT,IAAI,CAAC,CAAC;MACvC,IAAI,CAACkB,QAAQ,EAAE;;EAEjB;EAEA;;;EAGA,IAAInC,SAASA,CAAA;IACZ,OAAO,IAAI,CAACf,OAAO,CAACe,SAAS;EAC9B;EACA,IAAIA,SAASA,CAACA,SAAe;IAC5B,IAAI,CAACf,OAAO,CAACe,SAAS,GAAG,IAAI,CAAC0B,SAAS,CAAC1B,SAAS,CAAC;EACnD;EAEA;;;EAGA,IAAIC,OAAOA,CAAA;IACV,OAAO,IAAI,CAAChB,OAAO,CAACgB,OAAO;EAC5B;EACA,IAAIA,OAAOA,CAACA,OAAa;IACxB,IAAI,CAAChB,OAAO,CAACgB,OAAO,GAAG,IAAI,CAACyB,SAAS,CAACzB,OAAO,CAAC;EAC/C;EAEA;;;EAGA,IAAIsB,MAAMA,CAAA;IACT,OAAO,IAAI,CAACrB,OAAO;EACpB;EACA,IAAIqB,MAAMA,CAACA,MAAuB;IACjC,IAAI,CAACrB,OAAO,CAACkC,GAAG,CAACb,MAAM,CAAC;EACzB;EAEA;;;EAGA,IAAIxB,IAAIA,CAAA;IACP,OAAO,IAAI,CAACd,OAAO,CAACc,IAAI;EACzB;EACA,IAAIA,IAAIA,CAACA,IAAa;IACrB,IAAI,CAACd,OAAO,CAACc,IAAI,GAAGA,IAAI;IACxB,IAAI,IAAI,CAACV,cAAc,EAAE;MACxB,IAAI,CAACgD,UAAU,EAAE;;EAEnB;EAEA;;;EAGAC,OAAOA,CAAA;IACN,KAAK,CAACA,OAAO,EAAE;IACf,IAAI,CAACrD,OAAO,CAACQ,OAAO,GAAG,IAAI;IAC3B,IAAI,CAACR,OAAO,CAACsD,UAAU,EAAE;IACzB,IAAI,CAACrC,OAAO,CAACoC,OAAO,EAAE;IACtB,IAAI,CAAC3C,YAAY,CAAC2C,OAAO,EAAE;IAC3B,OAAO,IAAI;EACZ"},"metadata":{},"sourceType":"module","externalDependencies":[]}