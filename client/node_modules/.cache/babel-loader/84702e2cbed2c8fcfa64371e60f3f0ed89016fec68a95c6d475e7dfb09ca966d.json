{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { Merge } from \"../component/channel/Merge\";\nimport { Gain } from \"../core/context/Gain\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Noise } from \"../source/Noise\";\nimport { Effect } from \"./Effect\";\nimport { OfflineContext } from \"../core/context/OfflineContext\";\nimport { noOp } from \"../core/util/Interface\";\nimport { assertRange } from \"../core/util/Debug\";\n/**\n * Simple convolution created with decaying noise.\n * Generates an Impulse Response Buffer\n * with Tone.Offline then feeds the IR into ConvolverNode.\n * The impulse response generation is async, so you have\n * to wait until [[ready]] resolves before it will make a sound.\n *\n * Inspiration from [ReverbGen](https://github.com/adelespinasse/reverbGen).\n * Copyright (c) 2014 Alan deLespinasse Apache 2.0 License.\n *\n * @category Effect\n */\nexport class Reverb extends Effect {\n  constructor() {\n    super(optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]));\n    this.name = \"Reverb\";\n    /**\n     * Convolver node\n     */\n    this._convolver = this.context.createConvolver();\n    /**\n     * Resolves when the reverb buffer is generated. Whenever either [[decay]]\n     * or [[preDelay]] are set, you have to wait until [[ready]] resolves\n     * before the IR is generated with the latest values.\n     */\n    this.ready = Promise.resolve();\n    const options = optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]);\n    this._decay = options.decay;\n    this._preDelay = options.preDelay;\n    this.generate();\n    this.connectEffect(this._convolver);\n  }\n  static getDefaults() {\n    return Object.assign(Effect.getDefaults(), {\n      decay: 1.5,\n      preDelay: 0.01\n    });\n  }\n  /**\n   * The duration of the reverb.\n   */\n  get decay() {\n    return this._decay;\n  }\n  set decay(time) {\n    time = this.toSeconds(time);\n    assertRange(time, 0.001);\n    this._decay = time;\n    this.generate();\n  }\n  /**\n   * The amount of time before the reverb is fully ramped in.\n   */\n  get preDelay() {\n    return this._preDelay;\n  }\n  set preDelay(time) {\n    time = this.toSeconds(time);\n    assertRange(time, 0);\n    this._preDelay = time;\n    this.generate();\n  }\n  /**\n   * Generate the Impulse Response. Returns a promise while the IR is being generated.\n   * @return Promise which returns this object.\n   */\n  generate() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const previousReady = this.ready;\n      // create a noise burst which decays over the duration in each channel\n      const context = new OfflineContext(2, this._decay + this._preDelay, this.context.sampleRate);\n      const noiseL = new Noise({\n        context\n      });\n      const noiseR = new Noise({\n        context\n      });\n      const merge = new Merge({\n        context\n      });\n      noiseL.connect(merge, 0, 0);\n      noiseR.connect(merge, 0, 1);\n      const gainNode = new Gain({\n        context\n      }).toDestination();\n      merge.connect(gainNode);\n      noiseL.start(0);\n      noiseR.start(0);\n      // predelay\n      gainNode.gain.setValueAtTime(0, 0);\n      gainNode.gain.setValueAtTime(1, this._preDelay);\n      // decay\n      gainNode.gain.exponentialApproachValueAtTime(0, this._preDelay, this.decay);\n      // render the buffer\n      const renderPromise = context.render();\n      this.ready = renderPromise.then(noOp);\n      // wait for the previous `ready` to resolve\n      yield previousReady;\n      // set the buffer\n      this._convolver.buffer = (yield renderPromise).get();\n      return this;\n    });\n  }\n  dispose() {\n    super.dispose();\n    this._convolver.disconnect();\n    return this;\n  }\n}","map":{"version":3,"names":["Merge","Gain","optionsFromArguments","Noise","Effect","OfflineContext","noOp","assertRange","Reverb","constructor","getDefaults","arguments","name","_convolver","context","createConvolver","ready","Promise","resolve","options","_decay","decay","_preDelay","preDelay","generate","connectEffect","Object","assign","time","toSeconds","previousReady","sampleRate","noiseL","noiseR","merge","connect","gainNode","toDestination","start","gain","setValueAtTime","exponentialApproachValueAtTime","renderPromise","render","then","buffer","get","dispose","disconnect"],"sources":["/Users/ianstrom/Development/code/Capstone/node_modules/tone/Tone/effect/Reverb.ts"],"sourcesContent":["import { Merge } from \"../component/channel/Merge\";\nimport { Gain } from \"../core/context/Gain\";\nimport { Seconds, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Noise } from \"../source/Noise\";\nimport { Effect, EffectOptions } from \"./Effect\";\nimport { OfflineContext } from \"../core/context/OfflineContext\";\nimport { noOp } from \"../core/util/Interface\";\nimport { assertRange } from \"../core/util/Debug\";\n\ninterface ReverbOptions extends EffectOptions {\n\tdecay: Seconds;\n\tpreDelay: Seconds;\n}\n\n/**\n * Simple convolution created with decaying noise.\n * Generates an Impulse Response Buffer\n * with Tone.Offline then feeds the IR into ConvolverNode.\n * The impulse response generation is async, so you have\n * to wait until [[ready]] resolves before it will make a sound. \n *\n * Inspiration from [ReverbGen](https://github.com/adelespinasse/reverbGen).\n * Copyright (c) 2014 Alan deLespinasse Apache 2.0 License.\n * \n * @category Effect\n */\nexport class Reverb extends Effect<ReverbOptions> {\n\n\treadonly name: string = \"Reverb\";\n\n\t/**\n\t * Convolver node\n\t */\n\tprivate _convolver: ConvolverNode = this.context.createConvolver();\n\n\t/**\n\t * The duration of the reverb.\n\t */\n\tprivate _decay: Seconds;\n\t\n\t/**\n\t * The amount of time before the reverb is fully ramped in.\n\t */\n\tprivate _preDelay: Seconds;\n\n\t/**\n\t * Resolves when the reverb buffer is generated. Whenever either [[decay]]\n\t * or [[preDelay]] are set, you have to wait until [[ready]] resolves\n\t * before the IR is generated with the latest values. \n\t */\n\tready: Promise<void> = Promise.resolve();\n\n\t/**\n\t * @param decay The amount of time it will reverberate for.\n\t */\n\tconstructor(decay?: Seconds);\n\tconstructor(options?: Partial<ReverbOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]));\n\t\tconst options = optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]);\n\n\t\tthis._decay = options.decay;\n\t\tthis._preDelay = options.preDelay;\n\t\tthis.generate();\n\n\t\tthis.connectEffect(this._convolver);\n\t}\n\n\tstatic getDefaults(): ReverbOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tdecay: 1.5,\n\t\t\tpreDelay: 0.01,\n\t\t});\n\t}\n\n\t/**\n\t * The duration of the reverb.\n\t */\n\tget decay(): Time {\n\t\treturn this._decay;\n\t}\n\tset decay(time) {\n\t\ttime = this.toSeconds(time);\n\t\tassertRange(time, 0.001);\n\t\tthis._decay = time;\n\t\tthis.generate();\n\t}\n\n\t/**\n\t * The amount of time before the reverb is fully ramped in.\n\t */\n\tget preDelay(): Time {\n\t\treturn this._preDelay;\n\t}\n\tset preDelay(time) {\n\t\ttime = this.toSeconds(time);\n\t\tassertRange(time, 0);\n\t\tthis._preDelay = time;\n\t\tthis.generate();\n\t}\n\n\t/**\n\t * Generate the Impulse Response. Returns a promise while the IR is being generated.\n\t * @return Promise which returns this object.\n\t */\n\tasync generate(): Promise<this> {\n\t\tconst previousReady = this.ready;\n\n\t\t// create a noise burst which decays over the duration in each channel\n\t\tconst context = new OfflineContext(2, this._decay + this._preDelay, this.context.sampleRate);\n\t\tconst noiseL = new Noise({ context });\n\t\tconst noiseR = new Noise({ context });\n\t\tconst merge = new Merge({ context });\n\t\tnoiseL.connect(merge, 0, 0);\n\t\tnoiseR.connect(merge, 0, 1);\n\t\tconst gainNode = new Gain({ context }).toDestination();\n\t\tmerge.connect(gainNode);\n\t\tnoiseL.start(0);\n\t\tnoiseR.start(0);\n\t\t// predelay\n\t\tgainNode.gain.setValueAtTime(0, 0);\n\t\tgainNode.gain.setValueAtTime(1, this._preDelay);\n\t\t// decay\n\t\tgainNode.gain.exponentialApproachValueAtTime(0, this._preDelay, this.decay);\n\t\t\n\t\t// render the buffer\n\t\tconst renderPromise = context.render();\n\t\tthis.ready = renderPromise.then(noOp);\n\t\t\n\t\t// wait for the previous `ready` to resolve\n\t\tawait previousReady;\n\t\t// set the buffer\n\t\tthis._convolver.buffer = (await renderPromise).get() as AudioBuffer;\n\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._convolver.disconnect();\n\t\treturn this;\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}