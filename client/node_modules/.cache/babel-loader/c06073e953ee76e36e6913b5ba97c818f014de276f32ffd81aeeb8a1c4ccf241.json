{"ast":null,"code":"import { MidiClass } from \"../core/type/Midi\";\nimport { deepMerge, omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isNumber } from \"../core/util/TypeCheck\";\nimport { Instrument } from \"./Instrument\";\nimport { Synth } from \"./Synth\";\nimport { assert, warn } from \"../core/util/Debug\";\n/**\n * PolySynth handles voice creation and allocation for any\n * instruments passed in as the second paramter. PolySynth is\n * not a synthesizer by itself, it merely manages voices of\n * one of the other types of synths, allowing any of the\n * monophonic synthesizers to be polyphonic.\n *\n * @example\n * const synth = new Tone.PolySynth().toDestination();\n * // set the attributes across all the voices using 'set'\n * synth.set({ detune: -1200 });\n * // play a chord\n * synth.triggerAttackRelease([\"C4\", \"E4\", \"A4\"], 1);\n * @category Instrument\n */\nexport class PolySynth extends Instrument {\n  constructor() {\n    super(optionsFromArguments(PolySynth.getDefaults(), arguments, [\"voice\", \"options\"]));\n    this.name = \"PolySynth\";\n    /**\n     * The voices which are not currently in use\n     */\n    this._availableVoices = [];\n    /**\n     * The currently active voices\n     */\n    this._activeVoices = [];\n    /**\n     * All of the allocated voices for this synth.\n     */\n    this._voices = [];\n    /**\n     * The GC timeout. Held so that it could be cancelled when the node is disposed.\n     */\n    this._gcTimeout = -1;\n    /**\n     * A moving average of the number of active voices\n     */\n    this._averageActiveVoices = 0;\n    const options = optionsFromArguments(PolySynth.getDefaults(), arguments, [\"voice\", \"options\"]);\n    // check against the old API (pre 14.3.0)\n    assert(!isNumber(options.voice), \"DEPRECATED: The polyphony count is no longer the first argument.\");\n    const defaults = options.voice.getDefaults();\n    this.options = Object.assign(defaults, options.options);\n    this.voice = options.voice;\n    this.maxPolyphony = options.maxPolyphony;\n    // create the first voice\n    this._dummyVoice = this._getNextAvailableVoice();\n    // remove it from the voices list\n    const index = this._voices.indexOf(this._dummyVoice);\n    this._voices.splice(index, 1);\n    // kick off the GC interval\n    this._gcTimeout = this.context.setInterval(this._collectGarbage.bind(this), 1);\n  }\n  static getDefaults() {\n    return Object.assign(Instrument.getDefaults(), {\n      maxPolyphony: 32,\n      options: {},\n      voice: Synth\n    });\n  }\n  /**\n   * The number of active voices.\n   */\n  get activeVoices() {\n    return this._activeVoices.length;\n  }\n  /**\n   * Invoked when the source is done making sound, so that it can be\n   * readded to the pool of available voices\n   */\n  _makeVoiceAvailable(voice) {\n    this._availableVoices.push(voice);\n    // remove the midi note from 'active voices'\n    const activeVoiceIndex = this._activeVoices.findIndex(e => e.voice === voice);\n    this._activeVoices.splice(activeVoiceIndex, 1);\n  }\n  /**\n   * Get an available voice from the pool of available voices.\n   * If one is not available and the maxPolyphony limit is reached,\n   * steal a voice, otherwise return null.\n   */\n  _getNextAvailableVoice() {\n    // if there are available voices, return the first one\n    if (this._availableVoices.length) {\n      return this._availableVoices.shift();\n    } else if (this._voices.length < this.maxPolyphony) {\n      // otherwise if there is still more maxPolyphony, make a new voice\n      const voice = new this.voice(Object.assign(this.options, {\n        context: this.context,\n        onsilence: this._makeVoiceAvailable.bind(this)\n      }));\n      voice.connect(this.output);\n      this._voices.push(voice);\n      return voice;\n    } else {\n      warn(\"Max polyphony exceeded. Note dropped.\");\n    }\n  }\n  /**\n   * Occasionally check if there are any allocated voices which can be cleaned up.\n   */\n  _collectGarbage() {\n    this._averageActiveVoices = Math.max(this._averageActiveVoices * 0.95, this.activeVoices);\n    if (this._availableVoices.length && this._voices.length > Math.ceil(this._averageActiveVoices + 1)) {\n      // take off an available note\n      const firstAvail = this._availableVoices.shift();\n      const index = this._voices.indexOf(firstAvail);\n      this._voices.splice(index, 1);\n      if (!this.context.isOffline) {\n        firstAvail.dispose();\n      }\n    }\n  }\n  /**\n   * Internal method which triggers the attack\n   */\n  _triggerAttack(notes, time, velocity) {\n    notes.forEach(note => {\n      const midiNote = new MidiClass(this.context, note).toMidi();\n      const voice = this._getNextAvailableVoice();\n      if (voice) {\n        voice.triggerAttack(note, time, velocity);\n        this._activeVoices.push({\n          midi: midiNote,\n          voice,\n          released: false\n        });\n        this.log(\"triggerAttack\", note, time);\n      }\n    });\n  }\n  /**\n   * Internal method which triggers the release\n   */\n  _triggerRelease(notes, time) {\n    notes.forEach(note => {\n      const midiNote = new MidiClass(this.context, note).toMidi();\n      const event = this._activeVoices.find(_ref => {\n        let {\n          midi,\n          released\n        } = _ref;\n        return midi === midiNote && !released;\n      });\n      if (event) {\n        // trigger release on that note\n        event.voice.triggerRelease(time);\n        // mark it as released\n        event.released = true;\n        this.log(\"triggerRelease\", note, time);\n      }\n    });\n  }\n  /**\n   * Schedule the attack/release events. If the time is in the future, then it should set a timeout\n   * to wait for just-in-time scheduling\n   */\n  _scheduleEvent(type, notes, time, velocity) {\n    assert(!this.disposed, \"Synth was already disposed\");\n    // if the notes are greater than this amount of time in the future, they should be scheduled with setTimeout\n    if (time <= this.now()) {\n      // do it immediately\n      if (type === \"attack\") {\n        this._triggerAttack(notes, time, velocity);\n      } else {\n        this._triggerRelease(notes, time);\n      }\n    } else {\n      // schedule it to start in the future\n      this.context.setTimeout(() => {\n        this._scheduleEvent(type, notes, time, velocity);\n      }, time - this.now());\n    }\n  }\n  /**\n   * Trigger the attack portion of the note\n   * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n   * @param  time  The start time of the note.\n   * @param velocity The velocity of the note.\n   * @example\n   * const synth = new Tone.PolySynth(Tone.FMSynth).toDestination();\n   * // trigger a chord immediately with a velocity of 0.2\n   * synth.triggerAttack([\"Ab3\", \"C4\", \"F5\"], Tone.now(), 0.2);\n   */\n  triggerAttack(notes, time, velocity) {\n    if (!Array.isArray(notes)) {\n      notes = [notes];\n    }\n    const computedTime = this.toSeconds(time);\n    this._scheduleEvent(\"attack\", notes, computedTime, velocity);\n    return this;\n  }\n  /**\n   * Trigger the release of the note. Unlike monophonic instruments,\n   * a note (or array of notes) needs to be passed in as the first argument.\n   * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n   * @param  time  When the release will be triggered.\n   * @example\n   * @example\n   * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();\n   * poly.triggerAttack([\"Ab3\", \"C4\", \"F5\"]);\n   * // trigger the release of the given notes.\n   * poly.triggerRelease([\"Ab3\", \"C4\"], \"+1\");\n   * poly.triggerRelease(\"F5\", \"+3\");\n   */\n  triggerRelease(notes, time) {\n    if (!Array.isArray(notes)) {\n      notes = [notes];\n    }\n    const computedTime = this.toSeconds(time);\n    this._scheduleEvent(\"release\", notes, computedTime);\n    return this;\n  }\n  /**\n   * Trigger the attack and release after the specified duration\n   * @param  notes The notes to play. Accepts a single  Frequency or an array of frequencies.\n   * @param  duration the duration of the note\n   * @param  time  if no time is given, defaults to now\n   * @param  velocity the velocity of the attack (0-1)\n   * @example\n   * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();\n   * // can pass in an array of durations as well\n   * poly.triggerAttackRelease([\"Eb3\", \"G4\", \"Bb4\", \"D5\"], [4, 3, 2, 1]);\n   */\n  triggerAttackRelease(notes, duration, time, velocity) {\n    const computedTime = this.toSeconds(time);\n    this.triggerAttack(notes, computedTime, velocity);\n    if (isArray(duration)) {\n      assert(isArray(notes), \"If the duration is an array, the notes must also be an array\");\n      notes = notes;\n      for (let i = 0; i < notes.length; i++) {\n        const d = duration[Math.min(i, duration.length - 1)];\n        const durationSeconds = this.toSeconds(d);\n        assert(durationSeconds > 0, \"The duration must be greater than 0\");\n        this.triggerRelease(notes[i], computedTime + durationSeconds);\n      }\n    } else {\n      const durationSeconds = this.toSeconds(duration);\n      assert(durationSeconds > 0, \"The duration must be greater than 0\");\n      this.triggerRelease(notes, computedTime + durationSeconds);\n    }\n    return this;\n  }\n  sync() {\n    if (this._syncState()) {\n      this._syncMethod(\"triggerAttack\", 1);\n      this._syncMethod(\"triggerRelease\", 1);\n    }\n    return this;\n  }\n  /**\n   * Set a member/attribute of the voices\n   * @example\n   * const poly = new Tone.PolySynth().toDestination();\n   * // set all of the voices using an options object for the synth type\n   * poly.set({\n   * \tenvelope: {\n   * \t\tattack: 0.25\n   * \t}\n   * });\n   * poly.triggerAttackRelease(\"Bb3\", 0.2);\n   */\n  set(options) {\n    // remove options which are controlled by the PolySynth\n    const sanitizedOptions = omitFromObject(options, [\"onsilence\", \"context\"]);\n    // store all of the options\n    this.options = deepMerge(this.options, sanitizedOptions);\n    this._voices.forEach(voice => voice.set(sanitizedOptions));\n    this._dummyVoice.set(sanitizedOptions);\n    return this;\n  }\n  get() {\n    return this._dummyVoice.get();\n  }\n  /**\n   * Trigger the release portion of all the currently active voices immediately.\n   * Useful for silencing the synth.\n   */\n  releaseAll(time) {\n    const computedTime = this.toSeconds(time);\n    this._activeVoices.forEach(_ref2 => {\n      let {\n        voice\n      } = _ref2;\n      voice.triggerRelease(computedTime);\n    });\n    return this;\n  }\n  dispose() {\n    super.dispose();\n    this._dummyVoice.dispose();\n    this._voices.forEach(v => v.dispose());\n    this._activeVoices = [];\n    this._availableVoices = [];\n    this.context.clearInterval(this._gcTimeout);\n    return this;\n  }\n}","map":{"version":3,"names":["MidiClass","deepMerge","omitFromObject","optionsFromArguments","isArray","isNumber","Instrument","Synth","assert","warn","PolySynth","constructor","getDefaults","arguments","name","_availableVoices","_activeVoices","_voices","_gcTimeout","_averageActiveVoices","options","voice","defaults","Object","assign","maxPolyphony","_dummyVoice","_getNextAvailableVoice","index","indexOf","splice","context","setInterval","_collectGarbage","bind","activeVoices","length","_makeVoiceAvailable","push","activeVoiceIndex","findIndex","e","shift","onsilence","connect","output","Math","max","ceil","firstAvail","isOffline","dispose","_triggerAttack","notes","time","velocity","forEach","note","midiNote","toMidi","triggerAttack","midi","released","log","_triggerRelease","event","find","_ref","triggerRelease","_scheduleEvent","type","disposed","now","setTimeout","Array","computedTime","toSeconds","triggerAttackRelease","duration","i","d","min","durationSeconds","sync","_syncState","_syncMethod","set","sanitizedOptions","get","releaseAll","_ref2","v","clearInterval"],"sources":["/Users/ianstrom/Development/code/Capstone/node_modules/tone/Tone/instrument/PolySynth.ts"],"sourcesContent":["import { MidiClass } from \"../core/type/Midi\";\nimport { Frequency, MidiNote, NormalRange, Seconds, Time } from \"../core/type/Units\";\nimport { deepMerge, omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { RecursivePartial } from \"../core/util/Interface\";\nimport { isArray, isNumber } from \"../core/util/TypeCheck\";\nimport { Instrument, InstrumentOptions } from \"./Instrument\";\nimport { MembraneSynth, MembraneSynthOptions } from \"./MembraneSynth\";\nimport { FMSynth, FMSynthOptions } from \"./FMSynth\";\nimport { AMSynth, AMSynthOptions } from \"./AMSynth\";\nimport { MonoSynth, MonoSynthOptions } from \"./MonoSynth\";\nimport { MetalSynth, MetalSynthOptions } from \"./MetalSynth\";\nimport { Monophonic } from \"./Monophonic\";\nimport { Synth, SynthOptions } from \"./Synth\";\nimport { assert, warn } from \"../core/util/Debug\";\n\ntype VoiceConstructor<V> = {\n\tgetDefaults: () => VoiceOptions<V>;\n} & (new (...args: any[]) => V);\n\ntype OmitMonophonicOptions<T> = Omit<T, \"context\" | \"onsilence\">;\n\ntype VoiceOptions<T> =\n\tT extends MembraneSynth ? MembraneSynthOptions :\n\t\tT extends MetalSynth ? MetalSynthOptions :\n\t\t\tT extends FMSynth ? FMSynthOptions :\n\t\t\t\tT extends MonoSynth ? MonoSynthOptions :\n\t\t\t\t\tT extends AMSynth ? AMSynthOptions :\n\t\t\t\t\t\tT extends Synth ? SynthOptions :\n\t\t\t\t\t\t\tnever;\n\n/**\n * The settable synth options. excludes monophonic options.\n */\ntype PartialVoiceOptions<T> = RecursivePartial<OmitMonophonicOptions<VoiceOptions<T>>>;\n\nexport interface PolySynthOptions<Voice> extends InstrumentOptions {\n\tmaxPolyphony: number;\n\tvoice: VoiceConstructor<Voice>;\n\toptions: PartialVoiceOptions<Voice>;\n}\n\n/**\n * PolySynth handles voice creation and allocation for any\n * instruments passed in as the second paramter. PolySynth is\n * not a synthesizer by itself, it merely manages voices of\n * one of the other types of synths, allowing any of the\n * monophonic synthesizers to be polyphonic.\n *\n * @example\n * const synth = new Tone.PolySynth().toDestination();\n * // set the attributes across all the voices using 'set'\n * synth.set({ detune: -1200 });\n * // play a chord\n * synth.triggerAttackRelease([\"C4\", \"E4\", \"A4\"], 1);\n * @category Instrument\n */\nexport class PolySynth<Voice extends Monophonic<any> = Synth> extends Instrument<VoiceOptions<Voice>> {\n\n\treadonly name: string = \"PolySynth\";\n\n\t/**\n\t * The voices which are not currently in use\n\t */\n\tprivate _availableVoices: Voice[] = [];\n\n\t/**\n\t * The currently active voices\n\t */\n\tprivate _activeVoices: Array<{ midi: MidiNote; voice: Voice; released: boolean }> = [];\n\n\t/**\n\t * All of the allocated voices for this synth.\n\t */\n\tprivate _voices: Voice[] = [];\n\n\t/**\n\t * The options that are set on the synth.\n\t */\n\tprivate options: VoiceOptions<Voice>;\n\n\t/**\n\t * The polyphony limit.\n\t */\n\tmaxPolyphony: number;\n\n\t/**\n\t * The voice constructor\n\t */\n\tprivate readonly voice: VoiceConstructor<Voice>;\n\n\t/**\n\t * A voice used for holding the get/set values\n\t */\n\tprivate _dummyVoice: Voice;\n\n\t/**\n\t * The GC timeout. Held so that it could be cancelled when the node is disposed.\n\t */\n\tprivate _gcTimeout = -1;\n\n\t/**\n\t * A moving average of the number of active voices\n\t */\n\tprivate _averageActiveVoices = 0;\n\n\t/**\n\t * @param voice The constructor of the voices\n\t * @param options\tThe options object to set the synth voice\n\t */\n\tconstructor(\n\t\tvoice?: VoiceConstructor<Voice>,\n\t\toptions?: PartialVoiceOptions<Voice>,\n\t);\n\tconstructor(options?: Partial<PolySynthOptions<Voice>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(PolySynth.getDefaults(), arguments, [\"voice\", \"options\"]));\n\t\tconst options = optionsFromArguments(PolySynth.getDefaults(), arguments, [\"voice\", \"options\"]);\n\n\t\t// check against the old API (pre 14.3.0)\n\t\tassert(!isNumber(options.voice), \"DEPRECATED: The polyphony count is no longer the first argument.\");\n\n\t\tconst defaults = options.voice.getDefaults();\n\t\tthis.options = Object.assign(defaults, options.options) as VoiceOptions<Voice>;\n\t\tthis.voice = options.voice as unknown as VoiceConstructor<Voice>;\n\t\tthis.maxPolyphony = options.maxPolyphony;\n\n\t\t// create the first voice\n\t\tthis._dummyVoice = this._getNextAvailableVoice() as Voice;\n\t\t// remove it from the voices list\n\t\tconst index = this._voices.indexOf(this._dummyVoice);\n\t\tthis._voices.splice(index, 1);\n\t\t// kick off the GC interval\n\t\tthis._gcTimeout = this.context.setInterval(this._collectGarbage.bind(this), 1);\n\t}\n\n\tstatic getDefaults(): PolySynthOptions<Synth> {\n\t\treturn Object.assign(Instrument.getDefaults(), {\n\t\t\tmaxPolyphony: 32,\n\t\t\toptions: {},\n\t\t\tvoice: Synth,\n\t\t});\n\t}\n\n\t/**\n\t * The number of active voices.\n\t */\n\tget activeVoices(): number {\n\t\treturn this._activeVoices.length;\n\t}\n\n\t/**\n\t * Invoked when the source is done making sound, so that it can be\n\t * readded to the pool of available voices\n\t */\n\tprivate _makeVoiceAvailable(voice: Voice): void {\n\t\tthis._availableVoices.push(voice);\n\t\t// remove the midi note from 'active voices'\n\t\tconst activeVoiceIndex = this._activeVoices.findIndex((e) => e.voice === voice);\n\t\tthis._activeVoices.splice(activeVoiceIndex, 1);\n\t}\n\n\t/**\n\t * Get an available voice from the pool of available voices.\n\t * If one is not available and the maxPolyphony limit is reached,\n\t * steal a voice, otherwise return null.\n\t */\n\tprivate _getNextAvailableVoice(): Voice | undefined {\n\t\t// if there are available voices, return the first one\n\t\tif (this._availableVoices.length) {\n\t\t\treturn this._availableVoices.shift();\n\t\t} else if (this._voices.length < this.maxPolyphony) {\n\t\t\t// otherwise if there is still more maxPolyphony, make a new voice\n\t\t\tconst voice = new this.voice(Object.assign(this.options, {\n\t\t\t\tcontext: this.context,\n\t\t\t\tonsilence: this._makeVoiceAvailable.bind(this),\n\t\t\t}));\n\t\t\tvoice.connect(this.output);\n\t\t\tthis._voices.push(voice);\n\t\t\treturn voice;\n\t\t} else {\n\t\t\twarn(\"Max polyphony exceeded. Note dropped.\");\n\t\t}\n\t}\n\n\t/**\n\t * Occasionally check if there are any allocated voices which can be cleaned up.\n\t */\n\tprivate _collectGarbage(): void {\n\t\tthis._averageActiveVoices = Math.max(this._averageActiveVoices * 0.95, this.activeVoices);\n\t\tif (this._availableVoices.length && this._voices.length > Math.ceil(this._averageActiveVoices + 1)) {\n\t\t\t// take off an available note\n\t\t\tconst firstAvail = this._availableVoices.shift() as Voice;\n\t\t\tconst index = this._voices.indexOf(firstAvail);\n\t\t\tthis._voices.splice(index, 1);\n\t\t\tif (!this.context.isOffline) {\n\t\t\t\tfirstAvail.dispose();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Internal method which triggers the attack\n\t */\n\tprivate _triggerAttack(notes: Frequency[], time: Seconds, velocity?: NormalRange): void {\n\t\tnotes.forEach(note => {\n\t\t\tconst midiNote = new MidiClass(this.context, note).toMidi();\n\t\t\tconst voice = this._getNextAvailableVoice();\n\t\t\tif (voice) {\n\t\t\t\tvoice.triggerAttack(note, time, velocity);\n\t\t\t\tthis._activeVoices.push({\n\t\t\t\t\tmidi: midiNote, voice, released: false,\n\t\t\t\t});\n\t\t\t\tthis.log(\"triggerAttack\", note, time);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Internal method which triggers the release\n\t */\n\tprivate _triggerRelease(notes: Frequency[], time: Seconds): void {\n\t\tnotes.forEach(note => {\n\t\t\tconst midiNote = new MidiClass(this.context, note).toMidi();\n\t\t\tconst event = this._activeVoices.find(({ midi, released }) => midi === midiNote && !released);\n\t\t\tif (event) {\n\t\t\t\t// trigger release on that note\n\t\t\t\tevent.voice.triggerRelease(time);\n\t\t\t\t// mark it as released\n\t\t\t\tevent.released = true;\n\t\t\t\tthis.log(\"triggerRelease\", note, time);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Schedule the attack/release events. If the time is in the future, then it should set a timeout\n\t * to wait for just-in-time scheduling\n\t */\n\tprivate _scheduleEvent(type: \"attack\" | \"release\", notes: Frequency[], time: Seconds, velocity?: NormalRange): void {\n\t\tassert(!this.disposed, \"Synth was already disposed\");\n\t\t// if the notes are greater than this amount of time in the future, they should be scheduled with setTimeout\n\t\tif (time <= this.now()) {\n\t\t\t// do it immediately\n\t\t\tif (type === \"attack\") {\n\t\t\t\tthis._triggerAttack(notes, time, velocity);\n\t\t\t} else {\n\t\t\t\tthis._triggerRelease(notes, time);\n\t\t\t}\n\t\t} else {\n\t\t\t// schedule it to start in the future\n\t\t\tthis.context.setTimeout(() => {\n\t\t\t\tthis._scheduleEvent(type, notes, time, velocity);\n\t\t\t}, time - this.now());\n\t\t}\n\t}\n\n\t/**\n\t * Trigger the attack portion of the note\n\t * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n\t * @param  time  The start time of the note.\n\t * @param velocity The velocity of the note.\n\t * @example\n\t * const synth = new Tone.PolySynth(Tone.FMSynth).toDestination();\n\t * // trigger a chord immediately with a velocity of 0.2\n\t * synth.triggerAttack([\"Ab3\", \"C4\", \"F5\"], Tone.now(), 0.2);\n\t */\n\ttriggerAttack(notes: Frequency | Frequency[], time?: Time, velocity?: NormalRange): this {\n\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._scheduleEvent(\"attack\", notes, computedTime, velocity);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the release of the note. Unlike monophonic instruments,\n\t * a note (or array of notes) needs to be passed in as the first argument.\n\t * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n\t * @param  time  When the release will be triggered.\n\t * @example\n\t * @example\n\t * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();\n\t * poly.triggerAttack([\"Ab3\", \"C4\", \"F5\"]);\n\t * // trigger the release of the given notes. \n\t * poly.triggerRelease([\"Ab3\", \"C4\"], \"+1\");\n\t * poly.triggerRelease(\"F5\", \"+3\");\n\t */\n\ttriggerRelease(notes: Frequency | Frequency[], time?: Time): this {\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._scheduleEvent(\"release\", notes, computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the attack and release after the specified duration\n\t * @param  notes The notes to play. Accepts a single  Frequency or an array of frequencies.\n\t * @param  duration the duration of the note\n\t * @param  time  if no time is given, defaults to now\n\t * @param  velocity the velocity of the attack (0-1)\n\t * @example\n\t * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();\n\t * // can pass in an array of durations as well\n\t * poly.triggerAttackRelease([\"Eb3\", \"G4\", \"Bb4\", \"D5\"], [4, 3, 2, 1]);\n\t */\n\ttriggerAttackRelease(\n\t\tnotes: Frequency | Frequency[],\n\t\tduration: Time | Time[],\n\t\ttime?: Time,\n\t\tvelocity?: NormalRange,\n\t): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.triggerAttack(notes, computedTime, velocity);\n\t\tif (isArray(duration)) {\n\t\t\tassert(isArray(notes), \"If the duration is an array, the notes must also be an array\");\n\t\t\tnotes = notes as Frequency[];\n\t\t\tfor (let i = 0; i < notes.length; i++) {\n\t\t\t\tconst d = duration[Math.min(i, duration.length - 1)];\n\t\t\t\tconst durationSeconds = this.toSeconds(d);\n\t\t\t\tassert(durationSeconds > 0, \"The duration must be greater than 0\");\n\t\t\t\tthis.triggerRelease(notes[i], computedTime + durationSeconds);\n\t\t\t}\n\t\t} else {\n\t\t\tconst durationSeconds = this.toSeconds(duration);\n\t\t\tassert(durationSeconds > 0, \"The duration must be greater than 0\");\n\t\t\tthis.triggerRelease(notes, computedTime + durationSeconds);\n\t\t}\n\t\treturn this;\n\t}\n\n\tsync(): this {\n\t\tif (this._syncState()) {\n\t\t\tthis._syncMethod(\"triggerAttack\", 1);\n\t\t\tthis._syncMethod(\"triggerRelease\", 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set a member/attribute of the voices\n\t * @example\n\t * const poly = new Tone.PolySynth().toDestination();\n\t * // set all of the voices using an options object for the synth type\n\t * poly.set({\n\t * \tenvelope: {\n\t * \t\tattack: 0.25\n\t * \t}\n\t * });\n\t * poly.triggerAttackRelease(\"Bb3\", 0.2);\n\t */\n\tset(options: RecursivePartial<VoiceOptions<Voice>>): this {\n\t\t// remove options which are controlled by the PolySynth\n\t\tconst sanitizedOptions = omitFromObject(options, [\"onsilence\", \"context\"]);\n\t\t// store all of the options\n\t\tthis.options = deepMerge(this.options, sanitizedOptions);\n\t\tthis._voices.forEach(voice => voice.set(sanitizedOptions));\n\t\tthis._dummyVoice.set(sanitizedOptions);\n\t\treturn this;\n\t}\n\n\tget(): VoiceOptions<Voice> {\n\t\treturn this._dummyVoice.get();\n\t}\n\n\t/**\n\t * Trigger the release portion of all the currently active voices immediately.\n\t * Useful for silencing the synth.\n\t */\n\treleaseAll(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._activeVoices.forEach(({ voice }) => {\n\t\t\tvoice.triggerRelease(computedTime);\n\t\t});\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._dummyVoice.dispose();\n\t\tthis._voices.forEach(v => v.dispose());\n\t\tthis._activeVoices = [];\n\t\tthis._availableVoices = [];\n\t\tthis.context.clearInterval(this._gcTimeout);\n\t\treturn this;\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}