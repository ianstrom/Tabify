{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@babel/runtime/helpers/slicedToArray'), require('@babel/runtime/helpers/classCallCheck'), require('@babel/runtime/helpers/createClass')) : typeof define === 'function' && define.amd ? define(['exports', '@babel/runtime/helpers/slicedToArray', '@babel/runtime/helpers/classCallCheck', '@babel/runtime/helpers/createClass'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.automationEvents = {}, global._slicedToArray, global._classCallCheck, global._createClass));\n})(this, function (exports, _slicedToArray, _classCallCheck, _createClass) {\n  'use strict';\n\n  var createExtendedExponentialRampToValueAutomationEvent = function createExtendedExponentialRampToValueAutomationEvent(value, endTime, insertTime) {\n    return {\n      endTime: endTime,\n      insertTime: insertTime,\n      type: 'exponentialRampToValue',\n      value: value\n    };\n  };\n  var createExtendedLinearRampToValueAutomationEvent = function createExtendedLinearRampToValueAutomationEvent(value, endTime, insertTime) {\n    return {\n      endTime: endTime,\n      insertTime: insertTime,\n      type: 'linearRampToValue',\n      value: value\n    };\n  };\n  var createSetValueAutomationEvent = function createSetValueAutomationEvent(value, startTime) {\n    return {\n      startTime: startTime,\n      type: 'setValue',\n      value: value\n    };\n  };\n  var createSetValueCurveAutomationEvent = function createSetValueCurveAutomationEvent(values, startTime, duration) {\n    return {\n      duration: duration,\n      startTime: startTime,\n      type: 'setValueCurve',\n      values: values\n    };\n  };\n  var getTargetValueAtTime = function getTargetValueAtTime(time, valueAtStartTime, _ref) {\n    var startTime = _ref.startTime,\n      target = _ref.target,\n      timeConstant = _ref.timeConstant;\n    return target + (valueAtStartTime - target) * Math.exp((startTime - time) / timeConstant);\n  };\n  var isExponentialRampToValueAutomationEvent = function isExponentialRampToValueAutomationEvent(automationEvent) {\n    return automationEvent.type === 'exponentialRampToValue';\n  };\n  var isLinearRampToValueAutomationEvent = function isLinearRampToValueAutomationEvent(automationEvent) {\n    return automationEvent.type === 'linearRampToValue';\n  };\n  var isAnyRampToValueAutomationEvent = function isAnyRampToValueAutomationEvent(automationEvent) {\n    return isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent);\n  };\n  var isSetValueAutomationEvent = function isSetValueAutomationEvent(automationEvent) {\n    return automationEvent.type === 'setValue';\n  };\n  var isSetValueCurveAutomationEvent = function isSetValueCurveAutomationEvent(automationEvent) {\n    return automationEvent.type === 'setValueCurve';\n  };\n  var getValueOfAutomationEventAtIndexAtTime = function getValueOfAutomationEventAtIndexAtTime(automationEvents, index, time, defaultValue) {\n    var automationEvent = automationEvents[index];\n    return automationEvent === undefined ? defaultValue : isAnyRampToValueAutomationEvent(automationEvent) || isSetValueAutomationEvent(automationEvent) ? automationEvent.value : isSetValueCurveAutomationEvent(automationEvent) ? automationEvent.values[automationEvent.values.length - 1] : getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, automationEvent.startTime, defaultValue), automationEvent);\n  };\n  var getEndTimeAndValueOfPreviousAutomationEvent = function getEndTimeAndValueOfPreviousAutomationEvent(automationEvents, index, currentAutomationEvent, nextAutomationEvent, defaultValue) {\n    return currentAutomationEvent === undefined ? [nextAutomationEvent.insertTime, defaultValue] : isAnyRampToValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.endTime, currentAutomationEvent.value] : isSetValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.startTime, currentAutomationEvent.value] : isSetValueCurveAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.startTime + currentAutomationEvent.duration, currentAutomationEvent.values[currentAutomationEvent.values.length - 1]] : [currentAutomationEvent.startTime, getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, currentAutomationEvent.startTime, defaultValue)];\n  };\n  var isCancelAndHoldAutomationEvent = function isCancelAndHoldAutomationEvent(automationEvent) {\n    return automationEvent.type === 'cancelAndHold';\n  };\n  var isCancelScheduledValuesAutomationEvent = function isCancelScheduledValuesAutomationEvent(automationEvent) {\n    return automationEvent.type === 'cancelScheduledValues';\n  };\n  var getEventTime = function getEventTime(automationEvent) {\n    if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {\n      return automationEvent.cancelTime;\n    }\n    if (isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent)) {\n      return automationEvent.endTime;\n    }\n    return automationEvent.startTime;\n  };\n  var getExponentialRampValueAtTime = function getExponentialRampValueAtTime(time, startTime, valueAtStartTime, _ref) {\n    var endTime = _ref.endTime,\n      value = _ref.value;\n    if (valueAtStartTime === value) {\n      return value;\n    }\n    if (0 < valueAtStartTime && 0 < value || valueAtStartTime < 0 && value < 0) {\n      return valueAtStartTime * Math.pow(value / valueAtStartTime, (time - startTime) / (endTime - startTime));\n    }\n    return 0;\n  };\n  var getLinearRampValueAtTime = function getLinearRampValueAtTime(time, startTime, valueAtStartTime, _ref) {\n    var endTime = _ref.endTime,\n      value = _ref.value;\n    return valueAtStartTime + (time - startTime) / (endTime - startTime) * (value - valueAtStartTime);\n  };\n  var interpolateValue = function interpolateValue(values, theoreticIndex) {\n    var lowerIndex = Math.floor(theoreticIndex);\n    var upperIndex = Math.ceil(theoreticIndex);\n    if (lowerIndex === upperIndex) {\n      return values[lowerIndex];\n    }\n    return (1 - (theoreticIndex - lowerIndex)) * values[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * values[upperIndex];\n  };\n  var getValueCurveValueAtTime = function getValueCurveValueAtTime(time, _ref) {\n    var duration = _ref.duration,\n      startTime = _ref.startTime,\n      values = _ref.values;\n    var theoreticIndex = (time - startTime) / duration * (values.length - 1);\n    return interpolateValue(values, theoreticIndex);\n  };\n  var isSetTargetAutomationEvent = function isSetTargetAutomationEvent(automationEvent) {\n    return automationEvent.type === 'setTarget';\n  };\n  var AutomationEventList = /*#__PURE__*/function (_Symbol$iterator) {\n    function AutomationEventList(defaultValue) {\n      _classCallCheck(this, AutomationEventList);\n      this._automationEvents = [];\n      this._currenTime = 0;\n      this._defaultValue = defaultValue;\n    }\n    _createClass(AutomationEventList, [{\n      key: _Symbol$iterator,\n      value: function value() {\n        return this._automationEvents[Symbol.iterator]();\n      }\n    }, {\n      key: \"add\",\n      value: function add(automationEvent) {\n        var eventTime = getEventTime(automationEvent);\n        if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {\n          var index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n            if (isCancelScheduledValuesAutomationEvent(automationEvent) && isSetValueCurveAutomationEvent(currentAutomationEvent)) {\n              return currentAutomationEvent.startTime + currentAutomationEvent.duration >= eventTime;\n            }\n            return getEventTime(currentAutomationEvent) >= eventTime;\n          });\n          var removedAutomationEvent = this._automationEvents[index];\n          if (index !== -1) {\n            this._automationEvents = this._automationEvents.slice(0, index);\n          }\n          if (isCancelAndHoldAutomationEvent(automationEvent)) {\n            var lastAutomationEvent = this._automationEvents[this._automationEvents.length - 1];\n            if (removedAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(removedAutomationEvent)) {\n              if (lastAutomationEvent !== undefined && isSetTargetAutomationEvent(lastAutomationEvent)) {\n                throw new Error('The internal list is malformed.');\n              }\n              var startTime = lastAutomationEvent === undefined ? removedAutomationEvent.insertTime : isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.startTime + lastAutomationEvent.duration : getEventTime(lastAutomationEvent);\n              var startValue = lastAutomationEvent === undefined ? this._defaultValue : isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.values[lastAutomationEvent.values.length - 1] : lastAutomationEvent.value;\n              var value = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? getExponentialRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent) : getLinearRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent);\n              var truncatedAutomationEvent = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? createExtendedExponentialRampToValueAutomationEvent(value, eventTime, this._currenTime) : createExtendedLinearRampToValueAutomationEvent(value, eventTime, this._currenTime);\n              this._automationEvents.push(truncatedAutomationEvent);\n            }\n            if (lastAutomationEvent !== undefined && isSetTargetAutomationEvent(lastAutomationEvent)) {\n              this._automationEvents.push(createSetValueAutomationEvent(this.getValue(eventTime), eventTime));\n            }\n            if (lastAutomationEvent !== undefined && isSetValueCurveAutomationEvent(lastAutomationEvent) && lastAutomationEvent.startTime + lastAutomationEvent.duration > eventTime) {\n              var duration = eventTime - lastAutomationEvent.startTime;\n              var ratio = (lastAutomationEvent.values.length - 1) / lastAutomationEvent.duration;\n              var length = Math.max(2, 1 + Math.ceil(duration * ratio));\n              var fraction = duration / (length - 1) * ratio;\n              var values = lastAutomationEvent.values.slice(0, length);\n              if (fraction < 1) {\n                for (var i = 1; i < length; i += 1) {\n                  var factor = fraction * i % 1;\n                  values[i] = lastAutomationEvent.values[i - 1] * (1 - factor) + lastAutomationEvent.values[i] * factor;\n                }\n              }\n              this._automationEvents[this._automationEvents.length - 1] = createSetValueCurveAutomationEvent(values, lastAutomationEvent.startTime, duration);\n            }\n          }\n        } else {\n          var _index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n            return getEventTime(currentAutomationEvent) > eventTime;\n          });\n          var previousAutomationEvent = _index === -1 ? this._automationEvents[this._automationEvents.length - 1] : this._automationEvents[_index - 1];\n          if (previousAutomationEvent !== undefined && isSetValueCurveAutomationEvent(previousAutomationEvent) && getEventTime(previousAutomationEvent) + previousAutomationEvent.duration > eventTime) {\n            return false;\n          }\n          var persistentAutomationEvent = isExponentialRampToValueAutomationEvent(automationEvent) ? createExtendedExponentialRampToValueAutomationEvent(automationEvent.value, automationEvent.endTime, this._currenTime) : isLinearRampToValueAutomationEvent(automationEvent) ? createExtendedLinearRampToValueAutomationEvent(automationEvent.value, eventTime, this._currenTime) : automationEvent;\n          if (_index === -1) {\n            this._automationEvents.push(persistentAutomationEvent);\n          } else {\n            if (isSetValueCurveAutomationEvent(automationEvent) && eventTime + automationEvent.duration > getEventTime(this._automationEvents[_index])) {\n              return false;\n            }\n            this._automationEvents.splice(_index, 0, persistentAutomationEvent);\n          }\n        }\n        return true;\n      }\n    }, {\n      key: \"flush\",\n      value: function flush(time) {\n        var index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n          return getEventTime(currentAutomationEvent) > time;\n        });\n        if (index > 1) {\n          var remainingAutomationEvents = this._automationEvents.slice(index - 1);\n          var firstRemainingAutomationEvent = remainingAutomationEvents[0];\n          if (isSetTargetAutomationEvent(firstRemainingAutomationEvent)) {\n            remainingAutomationEvents.unshift(createSetValueAutomationEvent(getValueOfAutomationEventAtIndexAtTime(this._automationEvents, index - 2, firstRemainingAutomationEvent.startTime, this._defaultValue), firstRemainingAutomationEvent.startTime));\n          }\n          this._automationEvents = remainingAutomationEvents;\n        }\n      }\n    }, {\n      key: \"getValue\",\n      value: function getValue(time) {\n        if (this._automationEvents.length === 0) {\n          return this._defaultValue;\n        }\n        var indexOfNextEvent = this._automationEvents.findIndex(function (automationEvent) {\n          return getEventTime(automationEvent) > time;\n        });\n        var nextAutomationEvent = this._automationEvents[indexOfNextEvent];\n        var indexOfCurrentEvent = (indexOfNextEvent === -1 ? this._automationEvents.length : indexOfNextEvent) - 1;\n        var currentAutomationEvent = this._automationEvents[indexOfCurrentEvent];\n        if (currentAutomationEvent !== undefined && isSetTargetAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || nextAutomationEvent.insertTime > time)) {\n          return getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(this._automationEvents, indexOfCurrentEvent - 1, currentAutomationEvent.startTime, this._defaultValue), currentAutomationEvent);\n        }\n        if (currentAutomationEvent !== undefined && isSetValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {\n          return currentAutomationEvent.value;\n        }\n        if (currentAutomationEvent !== undefined && isSetValueCurveAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || currentAutomationEvent.startTime + currentAutomationEvent.duration > time)) {\n          if (time < currentAutomationEvent.startTime + currentAutomationEvent.duration) {\n            return getValueCurveValueAtTime(time, currentAutomationEvent);\n          }\n          return currentAutomationEvent.values[currentAutomationEvent.values.length - 1];\n        }\n        if (currentAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {\n          return currentAutomationEvent.value;\n        }\n        if (nextAutomationEvent !== undefined && isExponentialRampToValueAutomationEvent(nextAutomationEvent)) {\n          var _getEndTimeAndValueOf = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, indexOfCurrentEvent, currentAutomationEvent, nextAutomationEvent, this._defaultValue),\n            _getEndTimeAndValueOf2 = _slicedToArray(_getEndTimeAndValueOf, 2),\n            startTime = _getEndTimeAndValueOf2[0],\n            value = _getEndTimeAndValueOf2[1];\n          return getExponentialRampValueAtTime(time, startTime, value, nextAutomationEvent);\n        }\n        if (nextAutomationEvent !== undefined && isLinearRampToValueAutomationEvent(nextAutomationEvent)) {\n          var _getEndTimeAndValueOf3 = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, indexOfCurrentEvent, currentAutomationEvent, nextAutomationEvent, this._defaultValue),\n            _getEndTimeAndValueOf4 = _slicedToArray(_getEndTimeAndValueOf3, 2),\n            _startTime = _getEndTimeAndValueOf4[0],\n            _value = _getEndTimeAndValueOf4[1];\n          return getLinearRampValueAtTime(time, _startTime, _value, nextAutomationEvent);\n        }\n        return this._defaultValue;\n      }\n    }]);\n    return AutomationEventList;\n  }(Symbol.iterator);\n  var createCancelAndHoldAutomationEvent = function createCancelAndHoldAutomationEvent(cancelTime) {\n    return {\n      cancelTime: cancelTime,\n      type: 'cancelAndHold'\n    };\n  };\n  var createCancelScheduledValuesAutomationEvent = function createCancelScheduledValuesAutomationEvent(cancelTime) {\n    return {\n      cancelTime: cancelTime,\n      type: 'cancelScheduledValues'\n    };\n  };\n  var createExponentialRampToValueAutomationEvent = function createExponentialRampToValueAutomationEvent(value, endTime) {\n    return {\n      endTime: endTime,\n      type: 'exponentialRampToValue',\n      value: value\n    };\n  };\n  var createLinearRampToValueAutomationEvent = function createLinearRampToValueAutomationEvent(value, endTime) {\n    return {\n      endTime: endTime,\n      type: 'linearRampToValue',\n      value: value\n    };\n  };\n  var createSetTargetAutomationEvent = function createSetTargetAutomationEvent(target, startTime, timeConstant) {\n    return {\n      startTime: startTime,\n      target: target,\n      timeConstant: timeConstant,\n      type: 'setTarget'\n    };\n  };\n  exports.AutomationEventList = AutomationEventList;\n  exports.createCancelAndHoldAutomationEvent = createCancelAndHoldAutomationEvent;\n  exports.createCancelScheduledValuesAutomationEvent = createCancelScheduledValuesAutomationEvent;\n  exports.createExponentialRampToValueAutomationEvent = createExponentialRampToValueAutomationEvent;\n  exports.createLinearRampToValueAutomationEvent = createLinearRampToValueAutomationEvent;\n  exports.createSetTargetAutomationEvent = createSetTargetAutomationEvent;\n  exports.createSetValueAutomationEvent = createSetValueAutomationEvent;\n  exports.createSetValueCurveAutomationEvent = createSetValueCurveAutomationEvent;\n});","map":{"version":3,"names":["global","factory","exports","module","require","define","amd","globalThis","self","automationEvents","_slicedToArray","_classCallCheck","_createClass","createExtendedExponentialRampToValueAutomationEvent","value","endTime","insertTime","type","createExtendedLinearRampToValueAutomationEvent","createSetValueAutomationEvent","startTime","createSetValueCurveAutomationEvent","values","duration","getTargetValueAtTime","time","valueAtStartTime","_ref","target","timeConstant","Math","exp","isExponentialRampToValueAutomationEvent","automationEvent","isLinearRampToValueAutomationEvent","isAnyRampToValueAutomationEvent","isSetValueAutomationEvent","isSetValueCurveAutomationEvent","getValueOfAutomationEventAtIndexAtTime","index","defaultValue","undefined","length","getEndTimeAndValueOfPreviousAutomationEvent","currentAutomationEvent","nextAutomationEvent","isCancelAndHoldAutomationEvent","isCancelScheduledValuesAutomationEvent","getEventTime","cancelTime","getExponentialRampValueAtTime","pow","getLinearRampValueAtTime","interpolateValue","theoreticIndex","lowerIndex","floor","upperIndex","ceil","getValueCurveValueAtTime","isSetTargetAutomationEvent","AutomationEventList","_Symbol$iterator","_automationEvents","_currenTime","_defaultValue","key","Symbol","iterator","add","eventTime","findIndex","removedAutomationEvent","slice","lastAutomationEvent","Error","startValue","truncatedAutomationEvent","push","getValue","ratio","max","fraction","i","factor","_index","previousAutomationEvent","persistentAutomationEvent","splice","flush","remainingAutomationEvents","firstRemainingAutomationEvent","unshift","indexOfNextEvent","indexOfCurrentEvent","_getEndTimeAndValueOf","_getEndTimeAndValueOf2","_getEndTimeAndValueOf3","_getEndTimeAndValueOf4","_startTime","_value","createCancelAndHoldAutomationEvent","createCancelScheduledValuesAutomationEvent","createExponentialRampToValueAutomationEvent","createLinearRampToValueAutomationEvent","createSetTargetAutomationEvent"],"sources":["/Users/ianstrom/Development/code/Capstone/client/node_modules/automation-events/build/es5/bundle.js"],"sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@babel/runtime/helpers/slicedToArray'), require('@babel/runtime/helpers/classCallCheck'), require('@babel/runtime/helpers/createClass')) :\n    typeof define === 'function' && define.amd ? define(['exports', '@babel/runtime/helpers/slicedToArray', '@babel/runtime/helpers/classCallCheck', '@babel/runtime/helpers/createClass'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.automationEvents = {}, global._slicedToArray, global._classCallCheck, global._createClass));\n})(this, (function (exports, _slicedToArray, _classCallCheck, _createClass) { 'use strict';\n\n    var createExtendedExponentialRampToValueAutomationEvent = function createExtendedExponentialRampToValueAutomationEvent(value, endTime, insertTime) {\n      return {\n        endTime: endTime,\n        insertTime: insertTime,\n        type: 'exponentialRampToValue',\n        value: value\n      };\n    };\n\n    var createExtendedLinearRampToValueAutomationEvent = function createExtendedLinearRampToValueAutomationEvent(value, endTime, insertTime) {\n      return {\n        endTime: endTime,\n        insertTime: insertTime,\n        type: 'linearRampToValue',\n        value: value\n      };\n    };\n\n    var createSetValueAutomationEvent = function createSetValueAutomationEvent(value, startTime) {\n      return {\n        startTime: startTime,\n        type: 'setValue',\n        value: value\n      };\n    };\n\n    var createSetValueCurveAutomationEvent = function createSetValueCurveAutomationEvent(values, startTime, duration) {\n      return {\n        duration: duration,\n        startTime: startTime,\n        type: 'setValueCurve',\n        values: values\n      };\n    };\n\n    var getTargetValueAtTime = function getTargetValueAtTime(time, valueAtStartTime, _ref) {\n      var startTime = _ref.startTime,\n        target = _ref.target,\n        timeConstant = _ref.timeConstant;\n      return target + (valueAtStartTime - target) * Math.exp((startTime - time) / timeConstant);\n    };\n\n    var isExponentialRampToValueAutomationEvent = function isExponentialRampToValueAutomationEvent(automationEvent) {\n      return automationEvent.type === 'exponentialRampToValue';\n    };\n\n    var isLinearRampToValueAutomationEvent = function isLinearRampToValueAutomationEvent(automationEvent) {\n      return automationEvent.type === 'linearRampToValue';\n    };\n\n    var isAnyRampToValueAutomationEvent = function isAnyRampToValueAutomationEvent(automationEvent) {\n      return isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent);\n    };\n\n    var isSetValueAutomationEvent = function isSetValueAutomationEvent(automationEvent) {\n      return automationEvent.type === 'setValue';\n    };\n\n    var isSetValueCurveAutomationEvent = function isSetValueCurveAutomationEvent(automationEvent) {\n      return automationEvent.type === 'setValueCurve';\n    };\n\n    var getValueOfAutomationEventAtIndexAtTime = function getValueOfAutomationEventAtIndexAtTime(automationEvents, index, time, defaultValue) {\n      var automationEvent = automationEvents[index];\n      return automationEvent === undefined ? defaultValue : isAnyRampToValueAutomationEvent(automationEvent) || isSetValueAutomationEvent(automationEvent) ? automationEvent.value : isSetValueCurveAutomationEvent(automationEvent) ? automationEvent.values[automationEvent.values.length - 1] : getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, automationEvent.startTime, defaultValue), automationEvent);\n    };\n\n    var getEndTimeAndValueOfPreviousAutomationEvent = function getEndTimeAndValueOfPreviousAutomationEvent(automationEvents, index, currentAutomationEvent, nextAutomationEvent, defaultValue) {\n      return currentAutomationEvent === undefined ? [nextAutomationEvent.insertTime, defaultValue] : isAnyRampToValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.endTime, currentAutomationEvent.value] : isSetValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.startTime, currentAutomationEvent.value] : isSetValueCurveAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.startTime + currentAutomationEvent.duration, currentAutomationEvent.values[currentAutomationEvent.values.length - 1]] : [currentAutomationEvent.startTime, getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, currentAutomationEvent.startTime, defaultValue)];\n    };\n\n    var isCancelAndHoldAutomationEvent = function isCancelAndHoldAutomationEvent(automationEvent) {\n      return automationEvent.type === 'cancelAndHold';\n    };\n\n    var isCancelScheduledValuesAutomationEvent = function isCancelScheduledValuesAutomationEvent(automationEvent) {\n      return automationEvent.type === 'cancelScheduledValues';\n    };\n\n    var getEventTime = function getEventTime(automationEvent) {\n      if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {\n        return automationEvent.cancelTime;\n      }\n      if (isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent)) {\n        return automationEvent.endTime;\n      }\n      return automationEvent.startTime;\n    };\n\n    var getExponentialRampValueAtTime = function getExponentialRampValueAtTime(time, startTime, valueAtStartTime, _ref) {\n      var endTime = _ref.endTime,\n        value = _ref.value;\n      if (valueAtStartTime === value) {\n        return value;\n      }\n      if (0 < valueAtStartTime && 0 < value || valueAtStartTime < 0 && value < 0) {\n        return valueAtStartTime * Math.pow(value / valueAtStartTime, (time - startTime) / (endTime - startTime));\n      }\n      return 0;\n    };\n\n    var getLinearRampValueAtTime = function getLinearRampValueAtTime(time, startTime, valueAtStartTime, _ref) {\n      var endTime = _ref.endTime,\n        value = _ref.value;\n      return valueAtStartTime + (time - startTime) / (endTime - startTime) * (value - valueAtStartTime);\n    };\n\n    var interpolateValue = function interpolateValue(values, theoreticIndex) {\n      var lowerIndex = Math.floor(theoreticIndex);\n      var upperIndex = Math.ceil(theoreticIndex);\n      if (lowerIndex === upperIndex) {\n        return values[lowerIndex];\n      }\n      return (1 - (theoreticIndex - lowerIndex)) * values[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * values[upperIndex];\n    };\n\n    var getValueCurveValueAtTime = function getValueCurveValueAtTime(time, _ref) {\n      var duration = _ref.duration,\n        startTime = _ref.startTime,\n        values = _ref.values;\n      var theoreticIndex = (time - startTime) / duration * (values.length - 1);\n      return interpolateValue(values, theoreticIndex);\n    };\n\n    var isSetTargetAutomationEvent = function isSetTargetAutomationEvent(automationEvent) {\n      return automationEvent.type === 'setTarget';\n    };\n\n    var AutomationEventList = /*#__PURE__*/function (_Symbol$iterator) {\n      function AutomationEventList(defaultValue) {\n        _classCallCheck(this, AutomationEventList);\n        this._automationEvents = [];\n        this._currenTime = 0;\n        this._defaultValue = defaultValue;\n      }\n      _createClass(AutomationEventList, [{\n        key: _Symbol$iterator,\n        value: function value() {\n          return this._automationEvents[Symbol.iterator]();\n        }\n      }, {\n        key: \"add\",\n        value: function add(automationEvent) {\n          var eventTime = getEventTime(automationEvent);\n          if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {\n            var index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n              if (isCancelScheduledValuesAutomationEvent(automationEvent) && isSetValueCurveAutomationEvent(currentAutomationEvent)) {\n                return currentAutomationEvent.startTime + currentAutomationEvent.duration >= eventTime;\n              }\n              return getEventTime(currentAutomationEvent) >= eventTime;\n            });\n            var removedAutomationEvent = this._automationEvents[index];\n            if (index !== -1) {\n              this._automationEvents = this._automationEvents.slice(0, index);\n            }\n            if (isCancelAndHoldAutomationEvent(automationEvent)) {\n              var lastAutomationEvent = this._automationEvents[this._automationEvents.length - 1];\n              if (removedAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(removedAutomationEvent)) {\n                if (lastAutomationEvent !== undefined && isSetTargetAutomationEvent(lastAutomationEvent)) {\n                  throw new Error('The internal list is malformed.');\n                }\n                var startTime = lastAutomationEvent === undefined ? removedAutomationEvent.insertTime : isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.startTime + lastAutomationEvent.duration : getEventTime(lastAutomationEvent);\n                var startValue = lastAutomationEvent === undefined ? this._defaultValue : isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.values[lastAutomationEvent.values.length - 1] : lastAutomationEvent.value;\n                var value = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? getExponentialRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent) : getLinearRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent);\n                var truncatedAutomationEvent = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? createExtendedExponentialRampToValueAutomationEvent(value, eventTime, this._currenTime) : createExtendedLinearRampToValueAutomationEvent(value, eventTime, this._currenTime);\n                this._automationEvents.push(truncatedAutomationEvent);\n              }\n              if (lastAutomationEvent !== undefined && isSetTargetAutomationEvent(lastAutomationEvent)) {\n                this._automationEvents.push(createSetValueAutomationEvent(this.getValue(eventTime), eventTime));\n              }\n              if (lastAutomationEvent !== undefined && isSetValueCurveAutomationEvent(lastAutomationEvent) && lastAutomationEvent.startTime + lastAutomationEvent.duration > eventTime) {\n                var duration = eventTime - lastAutomationEvent.startTime;\n                var ratio = (lastAutomationEvent.values.length - 1) / lastAutomationEvent.duration;\n                var length = Math.max(2, 1 + Math.ceil(duration * ratio));\n                var fraction = duration / (length - 1) * ratio;\n                var values = lastAutomationEvent.values.slice(0, length);\n                if (fraction < 1) {\n                  for (var i = 1; i < length; i += 1) {\n                    var factor = fraction * i % 1;\n                    values[i] = lastAutomationEvent.values[i - 1] * (1 - factor) + lastAutomationEvent.values[i] * factor;\n                  }\n                }\n                this._automationEvents[this._automationEvents.length - 1] = createSetValueCurveAutomationEvent(values, lastAutomationEvent.startTime, duration);\n              }\n            }\n          } else {\n            var _index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n              return getEventTime(currentAutomationEvent) > eventTime;\n            });\n            var previousAutomationEvent = _index === -1 ? this._automationEvents[this._automationEvents.length - 1] : this._automationEvents[_index - 1];\n            if (previousAutomationEvent !== undefined && isSetValueCurveAutomationEvent(previousAutomationEvent) && getEventTime(previousAutomationEvent) + previousAutomationEvent.duration > eventTime) {\n              return false;\n            }\n            var persistentAutomationEvent = isExponentialRampToValueAutomationEvent(automationEvent) ? createExtendedExponentialRampToValueAutomationEvent(automationEvent.value, automationEvent.endTime, this._currenTime) : isLinearRampToValueAutomationEvent(automationEvent) ? createExtendedLinearRampToValueAutomationEvent(automationEvent.value, eventTime, this._currenTime) : automationEvent;\n            if (_index === -1) {\n              this._automationEvents.push(persistentAutomationEvent);\n            } else {\n              if (isSetValueCurveAutomationEvent(automationEvent) && eventTime + automationEvent.duration > getEventTime(this._automationEvents[_index])) {\n                return false;\n              }\n              this._automationEvents.splice(_index, 0, persistentAutomationEvent);\n            }\n          }\n          return true;\n        }\n      }, {\n        key: \"flush\",\n        value: function flush(time) {\n          var index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n            return getEventTime(currentAutomationEvent) > time;\n          });\n          if (index > 1) {\n            var remainingAutomationEvents = this._automationEvents.slice(index - 1);\n            var firstRemainingAutomationEvent = remainingAutomationEvents[0];\n            if (isSetTargetAutomationEvent(firstRemainingAutomationEvent)) {\n              remainingAutomationEvents.unshift(createSetValueAutomationEvent(getValueOfAutomationEventAtIndexAtTime(this._automationEvents, index - 2, firstRemainingAutomationEvent.startTime, this._defaultValue), firstRemainingAutomationEvent.startTime));\n            }\n            this._automationEvents = remainingAutomationEvents;\n          }\n        }\n      }, {\n        key: \"getValue\",\n        value: function getValue(time) {\n          if (this._automationEvents.length === 0) {\n            return this._defaultValue;\n          }\n          var indexOfNextEvent = this._automationEvents.findIndex(function (automationEvent) {\n            return getEventTime(automationEvent) > time;\n          });\n          var nextAutomationEvent = this._automationEvents[indexOfNextEvent];\n          var indexOfCurrentEvent = (indexOfNextEvent === -1 ? this._automationEvents.length : indexOfNextEvent) - 1;\n          var currentAutomationEvent = this._automationEvents[indexOfCurrentEvent];\n          if (currentAutomationEvent !== undefined && isSetTargetAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || nextAutomationEvent.insertTime > time)) {\n            return getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(this._automationEvents, indexOfCurrentEvent - 1, currentAutomationEvent.startTime, this._defaultValue), currentAutomationEvent);\n          }\n          if (currentAutomationEvent !== undefined && isSetValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {\n            return currentAutomationEvent.value;\n          }\n          if (currentAutomationEvent !== undefined && isSetValueCurveAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || currentAutomationEvent.startTime + currentAutomationEvent.duration > time)) {\n            if (time < currentAutomationEvent.startTime + currentAutomationEvent.duration) {\n              return getValueCurveValueAtTime(time, currentAutomationEvent);\n            }\n            return currentAutomationEvent.values[currentAutomationEvent.values.length - 1];\n          }\n          if (currentAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {\n            return currentAutomationEvent.value;\n          }\n          if (nextAutomationEvent !== undefined && isExponentialRampToValueAutomationEvent(nextAutomationEvent)) {\n            var _getEndTimeAndValueOf = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, indexOfCurrentEvent, currentAutomationEvent, nextAutomationEvent, this._defaultValue),\n              _getEndTimeAndValueOf2 = _slicedToArray(_getEndTimeAndValueOf, 2),\n              startTime = _getEndTimeAndValueOf2[0],\n              value = _getEndTimeAndValueOf2[1];\n            return getExponentialRampValueAtTime(time, startTime, value, nextAutomationEvent);\n          }\n          if (nextAutomationEvent !== undefined && isLinearRampToValueAutomationEvent(nextAutomationEvent)) {\n            var _getEndTimeAndValueOf3 = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, indexOfCurrentEvent, currentAutomationEvent, nextAutomationEvent, this._defaultValue),\n              _getEndTimeAndValueOf4 = _slicedToArray(_getEndTimeAndValueOf3, 2),\n              _startTime = _getEndTimeAndValueOf4[0],\n              _value = _getEndTimeAndValueOf4[1];\n            return getLinearRampValueAtTime(time, _startTime, _value, nextAutomationEvent);\n          }\n          return this._defaultValue;\n        }\n      }]);\n      return AutomationEventList;\n    }(Symbol.iterator);\n\n    var createCancelAndHoldAutomationEvent = function createCancelAndHoldAutomationEvent(cancelTime) {\n      return {\n        cancelTime: cancelTime,\n        type: 'cancelAndHold'\n      };\n    };\n\n    var createCancelScheduledValuesAutomationEvent = function createCancelScheduledValuesAutomationEvent(cancelTime) {\n      return {\n        cancelTime: cancelTime,\n        type: 'cancelScheduledValues'\n      };\n    };\n\n    var createExponentialRampToValueAutomationEvent = function createExponentialRampToValueAutomationEvent(value, endTime) {\n      return {\n        endTime: endTime,\n        type: 'exponentialRampToValue',\n        value: value\n      };\n    };\n\n    var createLinearRampToValueAutomationEvent = function createLinearRampToValueAutomationEvent(value, endTime) {\n      return {\n        endTime: endTime,\n        type: 'linearRampToValue',\n        value: value\n      };\n    };\n\n    var createSetTargetAutomationEvent = function createSetTargetAutomationEvent(target, startTime, timeConstant) {\n      return {\n        startTime: startTime,\n        target: target,\n        timeConstant: timeConstant,\n        type: 'setTarget'\n      };\n    };\n\n    exports.AutomationEventList = AutomationEventList;\n    exports.createCancelAndHoldAutomationEvent = createCancelAndHoldAutomationEvent;\n    exports.createCancelScheduledValuesAutomationEvent = createCancelScheduledValuesAutomationEvent;\n    exports.createExponentialRampToValueAutomationEvent = createExponentialRampToValueAutomationEvent;\n    exports.createLinearRampToValueAutomationEvent = createLinearRampToValueAutomationEvent;\n    exports.createSetTargetAutomationEvent = createSetTargetAutomationEvent;\n    exports.createSetValueAutomationEvent = createSetValueAutomationEvent;\n    exports.createSetValueCurveAutomationEvent = createSetValueCurveAutomationEvent;\n\n}));\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}