{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { createOfflineAudioContext } from \"../context/AudioContext\";\nimport { Context } from \"../context/Context\";\nimport { isOfflineAudioContext } from \"../util/AdvancedTypeCheck\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\n/**\n * Wrapper around the OfflineAudioContext\n * @category Core\n * @example\n * // generate a single channel, 0.5 second buffer\n * const context = new Tone.OfflineContext(1, 0.5, 44100);\n * const osc = new Tone.Oscillator({ context });\n * context.render().then(buffer => {\n * \tconsole.log(buffer.numberOfChannels, buffer.duration);\n * });\n */\nexport class OfflineContext extends Context {\n  constructor() {\n    super({\n      clockSource: \"offline\",\n      context: isOfflineAudioContext(arguments[0]) ? arguments[0] : createOfflineAudioContext(arguments[0], arguments[1] * arguments[2], arguments[2]),\n      lookAhead: 0,\n      updateInterval: isOfflineAudioContext(arguments[0]) ? 128 / arguments[0].sampleRate : 128 / arguments[2]\n    });\n    this.name = \"OfflineContext\";\n    /**\n     * An artificial clock source\n     */\n    this._currentTime = 0;\n    this.isOffline = true;\n    this._duration = isOfflineAudioContext(arguments[0]) ? arguments[0].length / arguments[0].sampleRate : arguments[1];\n  }\n  /**\n   * Override the now method to point to the internal clock time\n   */\n  now() {\n    return this._currentTime;\n  }\n  /**\n   * Same as this.now()\n   */\n  get currentTime() {\n    return this._currentTime;\n  }\n  /**\n   * Render just the clock portion of the audio context.\n   */\n  _renderClock(asynchronous) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let index = 0;\n      while (this._duration - this._currentTime >= 0) {\n        // invoke all the callbacks on that time\n        this.emit(\"tick\");\n        // increment the clock in block-sized chunks\n        this._currentTime += 128 / this.sampleRate;\n        // yield once a second of audio\n        index++;\n        const yieldEvery = Math.floor(this.sampleRate / 128);\n        if (asynchronous && index % yieldEvery === 0) {\n          yield new Promise(done => setTimeout(done, 1));\n        }\n      }\n    });\n  }\n  /**\n   * Render the output of the OfflineContext\n   * @param asynchronous If the clock should be rendered asynchronously, which will not block the main thread, but be slightly slower.\n   */\n  render() {\n    let asynchronous = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.workletsAreReady();\n      yield this._renderClock(asynchronous);\n      const buffer = yield this._context.startRendering();\n      return new ToneAudioBuffer(buffer);\n    });\n  }\n  /**\n   * Close the context\n   */\n  close() {\n    return Promise.resolve();\n  }\n}","map":{"version":3,"names":["createOfflineAudioContext","Context","isOfflineAudioContext","ToneAudioBuffer","OfflineContext","constructor","clockSource","context","arguments","lookAhead","updateInterval","sampleRate","name","_currentTime","isOffline","_duration","length","now","currentTime","_renderClock","asynchronous","index","emit","yieldEvery","Math","floor","Promise","done","setTimeout","render","undefined","workletsAreReady","buffer","_context","startRendering","close","resolve"],"sources":["/Users/ianstrom/Development/code/Capstone/client/node_modules/tone/Tone/core/context/OfflineContext.ts"],"sourcesContent":["import { createOfflineAudioContext } from \"../context/AudioContext\";\nimport { Context } from \"../context/Context\";\nimport { Seconds } from \"../type/Units\";\nimport { isOfflineAudioContext } from \"../util/AdvancedTypeCheck\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\n\n/**\n * Wrapper around the OfflineAudioContext\n * @category Core\n * @example\n * // generate a single channel, 0.5 second buffer\n * const context = new Tone.OfflineContext(1, 0.5, 44100);\n * const osc = new Tone.Oscillator({ context });\n * context.render().then(buffer => {\n * \tconsole.log(buffer.numberOfChannels, buffer.duration);\n * });\n */\nexport class OfflineContext extends Context {\n\n\treadonly name: string = \"OfflineContext\";\n\n\t/**\n\t * A private reference to the duration\n\t */\n\tprivate readonly _duration: Seconds;\n\n\t/**\n\t * An artificial clock source\n\t */\n\tprivate _currentTime: Seconds = 0;\n\n\t/**\n\t * Private reference to the OfflineAudioContext.\n\t */\n\tprotected _context!: OfflineAudioContext;\n\n\treadonly isOffline: boolean = true;\n\n\t/**\n\t * @param  channels  The number of channels to render\n\t * @param  duration  The duration to render in seconds\n\t * @param sampleRate the sample rate to render at\n\t */\n\tconstructor(\n\t\tchannels: number,\n\t\tduration: Seconds, \n\t\tsampleRate: number,\n\t);\n\tconstructor(context: OfflineAudioContext);\n\tconstructor() {\n\n\t\tsuper({\n\t\t\tclockSource: \"offline\",\n\t\t\tcontext: isOfflineAudioContext(arguments[0]) ?\n\t\t\t\targuments[0] : createOfflineAudioContext(arguments[0], arguments[1] * arguments[2], arguments[2]),\n\t\t\tlookAhead: 0,\n\t\t\tupdateInterval: isOfflineAudioContext(arguments[0]) ?\n\t\t\t\t128 / arguments[0].sampleRate : 128 / arguments[2],\n\t\t});\n\n\t\tthis._duration = isOfflineAudioContext(arguments[0]) ?\n\t\t\targuments[0].length / arguments[0].sampleRate : arguments[1];\n\t}\n\n\t/**\n\t * Override the now method to point to the internal clock time\n\t */\n\tnow(): Seconds {\n\t\treturn this._currentTime;\n\t}\n\n\t/**\n\t * Same as this.now()\n\t */\n\tget currentTime(): Seconds {\n\t\treturn this._currentTime;\n\t}\n\n\t/**\n\t * Render just the clock portion of the audio context.\n\t */\n\tprivate async _renderClock(asynchronous: boolean): Promise<void> {\n\t\tlet index = 0;\n\t\twhile (this._duration - this._currentTime >= 0) {\n\n\t\t\t// invoke all the callbacks on that time\n\t\t\tthis.emit(\"tick\");\n\n\t\t\t// increment the clock in block-sized chunks\n\t\t\tthis._currentTime += 128 / this.sampleRate;\n\n\t\t\t// yield once a second of audio\n\t\t\tindex++;\n\t\t\tconst yieldEvery = Math.floor(this.sampleRate / 128);\n\t\t\tif (asynchronous && index % yieldEvery === 0) {\n\t\t\t\tawait new Promise(done => setTimeout(done, 1));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Render the output of the OfflineContext\n\t * @param asynchronous If the clock should be rendered asynchronously, which will not block the main thread, but be slightly slower.\n\t */\n\tasync render(asynchronous = true): Promise<ToneAudioBuffer> {\n\t\tawait this.workletsAreReady();\n\t\tawait this._renderClock(asynchronous);\n\t\tconst buffer = await this._context.startRendering();\n\t\treturn new ToneAudioBuffer(buffer);\n\t}\n\n\t/**\n\t * Close the context\n\t */\n\tclose(): Promise<void> {\n\t\treturn Promise.resolve();\n\t}\n}\n"],"mappings":";AAAA,SAASA,yBAAyB,QAAQ,yBAAyB;AACnE,SAASC,OAAO,QAAQ,oBAAoB;AAE5C,SAASC,qBAAqB,QAAQ,2BAA2B;AACjE,SAASC,eAAe,QAAQ,mBAAmB;AAEnD;;;;;;;;;;;AAWA,OAAM,MAAOC,cAAe,SAAQH,OAAO;EAgC1CI,YAAA;IAEC,KAAK,CAAC;MACLC,WAAW,EAAE,SAAS;MACtBC,OAAO,EAAEL,qBAAqB,CAACM,SAAS,CAAC,CAAC,CAAC,CAAC,GAC3CA,SAAS,CAAC,CAAC,CAAC,GAAGR,yBAAyB,CAACQ,SAAS,CAAC,CAAC,CAAC,EAAEA,SAAS,CAAC,CAAC,CAAC,GAAGA,SAAS,CAAC,CAAC,CAAC,EAAEA,SAAS,CAAC,CAAC,CAAC,CAAC;MAClGC,SAAS,EAAE,CAAC;MACZC,cAAc,EAAER,qBAAqB,CAACM,SAAS,CAAC,CAAC,CAAC,CAAC,GAClD,GAAG,GAAGA,SAAS,CAAC,CAAC,CAAC,CAACG,UAAU,GAAG,GAAG,GAAGH,SAAS,CAAC,CAAC;KAClD,CAAC;IAvCM,KAAAI,IAAI,GAAW,gBAAgB;IAOxC;;;IAGQ,KAAAC,YAAY,GAAY,CAAC;IAOxB,KAAAC,SAAS,GAAY,IAAI;IAwBjC,IAAI,CAACC,SAAS,GAAGb,qBAAqB,CAACM,SAAS,CAAC,CAAC,CAAC,CAAC,GACnDA,SAAS,CAAC,CAAC,CAAC,CAACQ,MAAM,GAAGR,SAAS,CAAC,CAAC,CAAC,CAACG,UAAU,GAAGH,SAAS,CAAC,CAAC,CAAC;EAC9D;EAEA;;;EAGAS,GAAGA,CAAA;IACF,OAAO,IAAI,CAACJ,YAAY;EACzB;EAEA;;;EAGA,IAAIK,WAAWA,CAAA;IACd,OAAO,IAAI,CAACL,YAAY;EACzB;EAEA;;;EAGcM,YAAYA,CAACC,YAAqB;;MAC/C,IAAIC,KAAK,GAAG,CAAC;MACb,OAAO,IAAI,CAACN,SAAS,GAAG,IAAI,CAACF,YAAY,IAAI,CAAC,EAAE;QAE/C;QACA,IAAI,CAACS,IAAI,CAAC,MAAM,CAAC;QAEjB;QACA,IAAI,CAACT,YAAY,IAAI,GAAG,GAAG,IAAI,CAACF,UAAU;QAE1C;QACAU,KAAK,EAAE;QACP,MAAME,UAAU,GAAGC,IAAI,CAACC,KAAK,CAAC,IAAI,CAACd,UAAU,GAAG,GAAG,CAAC;QACpD,IAAIS,YAAY,IAAIC,KAAK,GAAGE,UAAU,KAAK,CAAC,EAAE;UAC7C,MAAM,IAAIG,OAAO,CAACC,IAAI,IAAIC,UAAU,CAACD,IAAI,EAAE,CAAC,CAAC,CAAC;;;IAGjD,CAAC;;EAED;;;;EAIME,MAAMA,CAAA,EAAoB;IAAA,IAAnBT,YAAY,GAAAZ,SAAA,CAAAQ,MAAA,QAAAR,SAAA,QAAAsB,SAAA,GAAAtB,SAAA,MAAG,IAAI;;MAC/B,MAAM,IAAI,CAACuB,gBAAgB,EAAE;MAC7B,MAAM,IAAI,CAACZ,YAAY,CAACC,YAAY,CAAC;MACrC,MAAMY,MAAM,GAAG,MAAM,IAAI,CAACC,QAAQ,CAACC,cAAc,EAAE;MACnD,OAAO,IAAI/B,eAAe,CAAC6B,MAAM,CAAC;IACnC,CAAC;;EAED;;;EAGAG,KAAKA,CAAA;IACJ,OAAOT,OAAO,CAACU,OAAO,EAAE;EACzB"},"metadata":{},"sourceType":"module","externalDependencies":[]}