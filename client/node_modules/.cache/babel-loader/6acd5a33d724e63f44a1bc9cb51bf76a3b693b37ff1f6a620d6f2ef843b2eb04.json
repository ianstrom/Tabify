{"ast":null,"code":"export const createWrapAudioBufferCopyChannelMethods = (convertNumberToUnsignedLong, createIndexSizeError) => {\n  return audioBuffer => {\n    audioBuffer.copyFromChannel = function (destination, channelNumberAsNumber) {\n      let bufferOffsetAsNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n      const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n      if (channelNumber >= audioBuffer.numberOfChannels) {\n        throw createIndexSizeError();\n      }\n      const audioBufferLength = audioBuffer.length;\n      const channelData = audioBuffer.getChannelData(channelNumber);\n      const destinationLength = destination.length;\n      for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < destinationLength; i += 1) {\n        destination[i] = channelData[i + bufferOffset];\n      }\n    };\n    audioBuffer.copyToChannel = function (source, channelNumberAsNumber) {\n      let bufferOffsetAsNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n      const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n      if (channelNumber >= audioBuffer.numberOfChannels) {\n        throw createIndexSizeError();\n      }\n      const audioBufferLength = audioBuffer.length;\n      const channelData = audioBuffer.getChannelData(channelNumber);\n      const sourceLength = source.length;\n      for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < sourceLength; i += 1) {\n        channelData[i + bufferOffset] = source[i];\n      }\n    };\n  };\n};","map":{"version":3,"names":["createWrapAudioBufferCopyChannelMethods","convertNumberToUnsignedLong","createIndexSizeError","audioBuffer","copyFromChannel","destination","channelNumberAsNumber","bufferOffsetAsNumber","arguments","length","undefined","bufferOffset","channelNumber","numberOfChannels","audioBufferLength","channelData","getChannelData","destinationLength","i","copyToChannel","source","sourceLength"],"sources":["/Users/ianstrom/Development/code/Capstone/node_modules/standardized-audio-context/src/factories/wrap-audio-buffer-copy-channel-methods.ts"],"sourcesContent":["import { TNativeAudioBuffer, TWrapAudioBufferCopyChannelMethodsFactory } from '../types';\n\nexport const createWrapAudioBufferCopyChannelMethods: TWrapAudioBufferCopyChannelMethodsFactory = (\n    convertNumberToUnsignedLong,\n    createIndexSizeError\n) => {\n    return (audioBuffer: TNativeAudioBuffer): void => {\n        audioBuffer.copyFromChannel = (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n            const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n            const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n\n            if (channelNumber >= audioBuffer.numberOfChannels) {\n                throw createIndexSizeError();\n            }\n\n            const audioBufferLength = audioBuffer.length;\n            const channelData = audioBuffer.getChannelData(channelNumber);\n            const destinationLength = destination.length;\n\n            for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < destinationLength; i += 1) {\n                destination[i] = channelData[i + bufferOffset];\n            }\n        };\n\n        audioBuffer.copyToChannel = (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n            const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n            const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n\n            if (channelNumber >= audioBuffer.numberOfChannels) {\n                throw createIndexSizeError();\n            }\n\n            const audioBufferLength = audioBuffer.length;\n            const channelData = audioBuffer.getChannelData(channelNumber);\n            const sourceLength = source.length;\n\n            for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < sourceLength; i += 1) {\n                channelData[i + bufferOffset] = source[i];\n            }\n        };\n    };\n};\n"],"mappings":"AAEA,OAAO,MAAMA,uCAAuC,GAA8CA,CAC9FC,2BAA2B,EAC3BC,oBAAoB,KACpB;EACA,OAAQC,WAA+B,IAAU;IAC7CA,WAAW,CAACC,eAAe,GAAG,UAACC,WAAW,EAAEC,qBAAqB,EAA8B;MAAA,IAA5BC,oBAAoB,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;MACvF,MAAMG,YAAY,GAAGV,2BAA2B,CAACM,oBAAoB,CAAC;MACtE,MAAMK,aAAa,GAAGX,2BAA2B,CAACK,qBAAqB,CAAC;MAExE,IAAIM,aAAa,IAAIT,WAAW,CAACU,gBAAgB,EAAE;QAC/C,MAAMX,oBAAoB,EAAE;;MAGhC,MAAMY,iBAAiB,GAAGX,WAAW,CAACM,MAAM;MAC5C,MAAMM,WAAW,GAAGZ,WAAW,CAACa,cAAc,CAACJ,aAAa,CAAC;MAC7D,MAAMK,iBAAiB,GAAGZ,WAAW,CAACI,MAAM;MAE5C,KAAK,IAAIS,CAAC,GAAGP,YAAY,GAAG,CAAC,GAAG,CAACA,YAAY,GAAG,CAAC,EAAEO,CAAC,GAAGP,YAAY,GAAGG,iBAAiB,IAAII,CAAC,GAAGD,iBAAiB,EAAEC,CAAC,IAAI,CAAC,EAAE;QACtHb,WAAW,CAACa,CAAC,CAAC,GAAGH,WAAW,CAACG,CAAC,GAAGP,YAAY,CAAC;;IAEtD,CAAC;IAEDR,WAAW,CAACgB,aAAa,GAAG,UAACC,MAAM,EAAEd,qBAAqB,EAA8B;MAAA,IAA5BC,oBAAoB,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;MAChF,MAAMG,YAAY,GAAGV,2BAA2B,CAACM,oBAAoB,CAAC;MACtE,MAAMK,aAAa,GAAGX,2BAA2B,CAACK,qBAAqB,CAAC;MAExE,IAAIM,aAAa,IAAIT,WAAW,CAACU,gBAAgB,EAAE;QAC/C,MAAMX,oBAAoB,EAAE;;MAGhC,MAAMY,iBAAiB,GAAGX,WAAW,CAACM,MAAM;MAC5C,MAAMM,WAAW,GAAGZ,WAAW,CAACa,cAAc,CAACJ,aAAa,CAAC;MAC7D,MAAMS,YAAY,GAAGD,MAAM,CAACX,MAAM;MAElC,KAAK,IAAIS,CAAC,GAAGP,YAAY,GAAG,CAAC,GAAG,CAACA,YAAY,GAAG,CAAC,EAAEO,CAAC,GAAGP,YAAY,GAAGG,iBAAiB,IAAII,CAAC,GAAGG,YAAY,EAAEH,CAAC,IAAI,CAAC,EAAE;QACjHH,WAAW,CAACG,CAAC,GAAGP,YAAY,CAAC,GAAGS,MAAM,CAACF,CAAC,CAAC;;IAEjD,CAAC;EACL,CAAC;AACL,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}