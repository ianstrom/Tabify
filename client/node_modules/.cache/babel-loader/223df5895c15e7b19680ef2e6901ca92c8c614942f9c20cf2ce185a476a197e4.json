{"ast":null,"code":"import { dbToGain, gainToDb } from \"../type/Conversions\";\nimport { isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { ToneWithContext } from \"./ToneWithContext\";\nimport { EQ } from \"../util/Math\";\nimport { assert, assertRange } from \"../util/Debug\";\n/**\n * Param wraps the native Web Audio's AudioParam to provide\n * additional unit conversion functionality. It also\n * serves as a base-class for classes which have a single,\n * automatable parameter.\n * @category Core\n */\nexport class Param extends ToneWithContext {\n  constructor() {\n    super(optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]));\n    this.name = \"Param\";\n    this.overridden = false;\n    /**\n     * The minimum output value\n     */\n    this._minOutput = 1e-7;\n    const options = optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]);\n    assert(isDefined(options.param) && (isAudioParam(options.param) || options.param instanceof Param), \"param must be an AudioParam\");\n    while (!isAudioParam(options.param)) {\n      options.param = options.param._param;\n    }\n    this._swappable = isDefined(options.swappable) ? options.swappable : false;\n    if (this._swappable) {\n      this.input = this.context.createGain();\n      // initialize\n      this._param = options.param;\n      this.input.connect(this._param);\n    } else {\n      this._param = this.input = options.param;\n    }\n    this._events = new Timeline(1000);\n    this._initialValue = this._param.defaultValue;\n    this.units = options.units;\n    this.convert = options.convert;\n    this._minValue = options.minValue;\n    this._maxValue = options.maxValue;\n    // if the value is defined, set it immediately\n    if (isDefined(options.value) && options.value !== this._toType(this._initialValue)) {\n      this.setValueAtTime(options.value, 0);\n    }\n  }\n  static getDefaults() {\n    return Object.assign(ToneWithContext.getDefaults(), {\n      convert: true,\n      units: \"number\"\n    });\n  }\n  get value() {\n    const now = this.now();\n    return this.getValueAtTime(now);\n  }\n  set value(value) {\n    this.cancelScheduledValues(this.now());\n    this.setValueAtTime(value, this.now());\n  }\n  get minValue() {\n    // if it's not the default minValue, return it\n    if (isDefined(this._minValue)) {\n      return this._minValue;\n    } else if (this.units === \"time\" || this.units === \"frequency\" || this.units === \"normalRange\" || this.units === \"positive\" || this.units === \"transportTime\" || this.units === \"ticks\" || this.units === \"bpm\" || this.units === \"hertz\" || this.units === \"samples\") {\n      return 0;\n    } else if (this.units === \"audioRange\") {\n      return -1;\n    } else if (this.units === \"decibels\") {\n      return -Infinity;\n    } else {\n      return this._param.minValue;\n    }\n  }\n  get maxValue() {\n    if (isDefined(this._maxValue)) {\n      return this._maxValue;\n    } else if (this.units === \"normalRange\" || this.units === \"audioRange\") {\n      return 1;\n    } else {\n      return this._param.maxValue;\n    }\n  }\n  /**\n   * Type guard based on the unit name\n   */\n  _is(arg, type) {\n    return this.units === type;\n  }\n  /**\n   * Make sure the value is always in the defined range\n   */\n  _assertRange(value) {\n    if (isDefined(this.maxValue) && isDefined(this.minValue)) {\n      assertRange(value, this._fromType(this.minValue), this._fromType(this.maxValue));\n    }\n    return value;\n  }\n  /**\n   * Convert the given value from the type specified by Param.units\n   * into the destination value (such as Gain or Frequency).\n   */\n  _fromType(val) {\n    if (this.convert && !this.overridden) {\n      if (this._is(val, \"time\")) {\n        return this.toSeconds(val);\n      } else if (this._is(val, \"decibels\")) {\n        return dbToGain(val);\n      } else if (this._is(val, \"frequency\")) {\n        return this.toFrequency(val);\n      } else {\n        return val;\n      }\n    } else if (this.overridden) {\n      // if it's overridden, should only schedule 0s\n      return 0;\n    } else {\n      return val;\n    }\n  }\n  /**\n   * Convert the parameters value into the units specified by Param.units.\n   */\n  _toType(val) {\n    if (this.convert && this.units === \"decibels\") {\n      return gainToDb(val);\n    } else {\n      return val;\n    }\n  }\n  //-------------------------------------\n  // ABSTRACT PARAM INTERFACE\n  // all docs are generated from ParamInterface.ts\n  //-------------------------------------\n  setValueAtTime(value, time) {\n    const computedTime = this.toSeconds(time);\n    const numericValue = this._fromType(value);\n    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to setValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(time)}`);\n    this._assertRange(numericValue);\n    this.log(this.units, \"setValueAtTime\", value, computedTime);\n    this._events.add({\n      time: computedTime,\n      type: \"setValueAtTime\",\n      value: numericValue\n    });\n    this._param.setValueAtTime(numericValue, computedTime);\n    return this;\n  }\n  getValueAtTime(time) {\n    const computedTime = Math.max(this.toSeconds(time), 0);\n    const after = this._events.getAfter(computedTime);\n    const before = this._events.get(computedTime);\n    let value = this._initialValue;\n    // if it was set by\n    if (before === null) {\n      value = this._initialValue;\n    } else if (before.type === \"setTargetAtTime\" && (after === null || after.type === \"setValueAtTime\")) {\n      const previous = this._events.getBefore(before.time);\n      let previousVal;\n      if (previous === null) {\n        previousVal = this._initialValue;\n      } else {\n        previousVal = previous.value;\n      }\n      if (before.type === \"setTargetAtTime\") {\n        value = this._exponentialApproach(before.time, previousVal, before.value, before.constant, computedTime);\n      }\n    } else if (after === null) {\n      value = before.value;\n    } else if (after.type === \"linearRampToValueAtTime\" || after.type === \"exponentialRampToValueAtTime\") {\n      let beforeValue = before.value;\n      if (before.type === \"setTargetAtTime\") {\n        const previous = this._events.getBefore(before.time);\n        if (previous === null) {\n          beforeValue = this._initialValue;\n        } else {\n          beforeValue = previous.value;\n        }\n      }\n      if (after.type === \"linearRampToValueAtTime\") {\n        value = this._linearInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n      } else {\n        value = this._exponentialInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n      }\n    } else {\n      value = before.value;\n    }\n    return this._toType(value);\n  }\n  setRampPoint(time) {\n    time = this.toSeconds(time);\n    let currentVal = this.getValueAtTime(time);\n    this.cancelAndHoldAtTime(time);\n    if (this._fromType(currentVal) === 0) {\n      currentVal = this._toType(this._minOutput);\n    }\n    this.setValueAtTime(currentVal, time);\n    return this;\n  }\n  linearRampToValueAtTime(value, endTime) {\n    const numericValue = this._fromType(value);\n    const computedTime = this.toSeconds(endTime);\n    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);\n    this._assertRange(numericValue);\n    this._events.add({\n      time: computedTime,\n      type: \"linearRampToValueAtTime\",\n      value: numericValue\n    });\n    this.log(this.units, \"linearRampToValueAtTime\", value, computedTime);\n    this._param.linearRampToValueAtTime(numericValue, computedTime);\n    return this;\n  }\n  exponentialRampToValueAtTime(value, endTime) {\n    let numericValue = this._fromType(value);\n    // the value can't be 0\n    numericValue = EQ(numericValue, 0) ? this._minOutput : numericValue;\n    this._assertRange(numericValue);\n    const computedTime = this.toSeconds(endTime);\n    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);\n    // store the event\n    this._events.add({\n      time: computedTime,\n      type: \"exponentialRampToValueAtTime\",\n      value: numericValue\n    });\n    this.log(this.units, \"exponentialRampToValueAtTime\", value, computedTime);\n    this._param.exponentialRampToValueAtTime(numericValue, computedTime);\n    return this;\n  }\n  exponentialRampTo(value, rampTime, startTime) {\n    startTime = this.toSeconds(startTime);\n    this.setRampPoint(startTime);\n    this.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n    return this;\n  }\n  linearRampTo(value, rampTime, startTime) {\n    startTime = this.toSeconds(startTime);\n    this.setRampPoint(startTime);\n    this.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n    return this;\n  }\n  targetRampTo(value, rampTime, startTime) {\n    startTime = this.toSeconds(startTime);\n    this.setRampPoint(startTime);\n    this.exponentialApproachValueAtTime(value, startTime, rampTime);\n    return this;\n  }\n  exponentialApproachValueAtTime(value, time, rampTime) {\n    time = this.toSeconds(time);\n    rampTime = this.toSeconds(rampTime);\n    const timeConstant = Math.log(rampTime + 1) / Math.log(200);\n    this.setTargetAtTime(value, time, timeConstant);\n    // at 90% start a linear ramp to the final value\n    this.cancelAndHoldAtTime(time + rampTime * 0.9);\n    this.linearRampToValueAtTime(value, time + rampTime);\n    return this;\n  }\n  setTargetAtTime(value, startTime, timeConstant) {\n    const numericValue = this._fromType(value);\n    // The value will never be able to approach without timeConstant > 0.\n    assert(isFinite(timeConstant) && timeConstant > 0, \"timeConstant must be a number greater than 0\");\n    const computedTime = this.toSeconds(startTime);\n    this._assertRange(numericValue);\n    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to setTargetAtTime: ${JSON.stringify(value)}, ${JSON.stringify(startTime)}`);\n    this._events.add({\n      constant: timeConstant,\n      time: computedTime,\n      type: \"setTargetAtTime\",\n      value: numericValue\n    });\n    this.log(this.units, \"setTargetAtTime\", value, computedTime, timeConstant);\n    this._param.setTargetAtTime(numericValue, computedTime, timeConstant);\n    return this;\n  }\n  setValueCurveAtTime(values, startTime, duration) {\n    let scaling = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    duration = this.toSeconds(duration);\n    startTime = this.toSeconds(startTime);\n    const startingValue = this._fromType(values[0]) * scaling;\n    this.setValueAtTime(this._toType(startingValue), startTime);\n    const segTime = duration / (values.length - 1);\n    for (let i = 1; i < values.length; i++) {\n      const numericValue = this._fromType(values[i]) * scaling;\n      this.linearRampToValueAtTime(this._toType(numericValue), startTime + i * segTime);\n    }\n    return this;\n  }\n  cancelScheduledValues(time) {\n    const computedTime = this.toSeconds(time);\n    assert(isFinite(computedTime), `Invalid argument to cancelScheduledValues: ${JSON.stringify(time)}`);\n    this._events.cancel(computedTime);\n    this._param.cancelScheduledValues(computedTime);\n    this.log(this.units, \"cancelScheduledValues\", computedTime);\n    return this;\n  }\n  cancelAndHoldAtTime(time) {\n    const computedTime = this.toSeconds(time);\n    const valueAtTime = this._fromType(this.getValueAtTime(computedTime));\n    // remove the schedule events\n    assert(isFinite(computedTime), `Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(time)}`);\n    this.log(this.units, \"cancelAndHoldAtTime\", computedTime, \"value=\" + valueAtTime);\n    // if there is an event at the given computedTime\n    // and that even is not a \"set\"\n    const before = this._events.get(computedTime);\n    const after = this._events.getAfter(computedTime);\n    if (before && EQ(before.time, computedTime)) {\n      // remove everything after\n      if (after) {\n        this._param.cancelScheduledValues(after.time);\n        this._events.cancel(after.time);\n      } else {\n        this._param.cancelAndHoldAtTime(computedTime);\n        this._events.cancel(computedTime + this.sampleTime);\n      }\n    } else if (after) {\n      this._param.cancelScheduledValues(after.time);\n      // cancel the next event(s)\n      this._events.cancel(after.time);\n      if (after.type === \"linearRampToValueAtTime\") {\n        this.linearRampToValueAtTime(this._toType(valueAtTime), computedTime);\n      } else if (after.type === \"exponentialRampToValueAtTime\") {\n        this.exponentialRampToValueAtTime(this._toType(valueAtTime), computedTime);\n      }\n    }\n    // set the value at the given time\n    this._events.add({\n      time: computedTime,\n      type: \"setValueAtTime\",\n      value: valueAtTime\n    });\n    this._param.setValueAtTime(valueAtTime, computedTime);\n    return this;\n  }\n  rampTo(value) {\n    let rampTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.1;\n    let startTime = arguments.length > 2 ? arguments[2] : undefined;\n    if (this.units === \"frequency\" || this.units === \"bpm\" || this.units === \"decibels\") {\n      this.exponentialRampTo(value, rampTime, startTime);\n    } else {\n      this.linearRampTo(value, rampTime, startTime);\n    }\n    return this;\n  }\n  /**\n   * Apply all of the previously scheduled events to the passed in Param or AudioParam.\n   * The applied values will start at the context's current time and schedule\n   * all of the events which are scheduled on this Param onto the passed in param.\n   */\n  apply(param) {\n    const now = this.context.currentTime;\n    // set the param's value at the current time and schedule everything else\n    param.setValueAtTime(this.getValueAtTime(now), now);\n    // if the previous event was a curve, then set the rest of it\n    const previousEvent = this._events.get(now);\n    if (previousEvent && previousEvent.type === \"setTargetAtTime\") {\n      // approx it until the next event with linear ramps\n      const nextEvent = this._events.getAfter(previousEvent.time);\n      // or for 2 seconds if there is no event\n      const endTime = nextEvent ? nextEvent.time : now + 2;\n      const subdivisions = (endTime - now) / 10;\n      for (let i = now; i < endTime; i += subdivisions) {\n        param.linearRampToValueAtTime(this.getValueAtTime(i), i);\n      }\n    }\n    this._events.forEachAfter(this.context.currentTime, event => {\n      if (event.type === \"cancelScheduledValues\") {\n        param.cancelScheduledValues(event.time);\n      } else if (event.type === \"setTargetAtTime\") {\n        param.setTargetAtTime(event.value, event.time, event.constant);\n      } else {\n        param[event.type](event.value, event.time);\n      }\n    });\n    return this;\n  }\n  /**\n   * Replace the Param's internal AudioParam. Will apply scheduled curves\n   * onto the parameter and replace the connections.\n   */\n  setParam(param) {\n    assert(this._swappable, \"The Param must be assigned as 'swappable' in the constructor\");\n    const input = this.input;\n    input.disconnect(this._param);\n    this.apply(param);\n    this._param = param;\n    input.connect(this._param);\n    return this;\n  }\n  dispose() {\n    super.dispose();\n    this._events.dispose();\n    return this;\n  }\n  get defaultValue() {\n    return this._toType(this._param.defaultValue);\n  }\n  //-------------------------------------\n  // \tAUTOMATION CURVE CALCULATIONS\n  // \tMIT License, copyright (c) 2014 Jordan Santell\n  //-------------------------------------\n  // Calculates the the value along the curve produced by setTargetAtTime\n  _exponentialApproach(t0, v0, v1, timeConstant, t) {\n    return v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);\n  }\n  // Calculates the the value along the curve produced by linearRampToValueAtTime\n  _linearInterpolate(t0, v0, t1, v1, t) {\n    return v0 + (v1 - v0) * ((t - t0) / (t1 - t0));\n  }\n  // Calculates the the value along the curve produced by exponentialRampToValueAtTime\n  _exponentialInterpolate(t0, v0, t1, v1, t) {\n    return v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));\n  }\n}","map":{"version":3,"names":["dbToGain","gainToDb","isAudioParam","optionsFromArguments","Timeline","isDefined","ToneWithContext","EQ","assert","assertRange","Param","constructor","getDefaults","arguments","name","overridden","_minOutput","options","param","_param","_swappable","swappable","input","context","createGain","connect","_events","_initialValue","defaultValue","units","convert","_minValue","minValue","_maxValue","maxValue","value","_toType","setValueAtTime","Object","assign","now","getValueAtTime","cancelScheduledValues","Infinity","_is","arg","type","_assertRange","_fromType","val","toSeconds","toFrequency","time","computedTime","numericValue","isFinite","JSON","stringify","log","add","Math","max","after","getAfter","before","get","previous","getBefore","previousVal","_exponentialApproach","constant","beforeValue","_linearInterpolate","_exponentialInterpolate","setRampPoint","currentVal","cancelAndHoldAtTime","linearRampToValueAtTime","endTime","exponentialRampToValueAtTime","exponentialRampTo","rampTime","startTime","linearRampTo","targetRampTo","exponentialApproachValueAtTime","timeConstant","setTargetAtTime","setValueCurveAtTime","values","duration","scaling","length","undefined","startingValue","segTime","i","cancel","valueAtTime","sampleTime","rampTo","apply","currentTime","previousEvent","nextEvent","subdivisions","forEachAfter","event","setParam","disconnect","dispose","t0","v0","v1","t","exp","t1","pow"],"sources":["/Users/ianstrom/Development/code/Capstone/client/node_modules/tone/Tone/core/context/Param.ts"],"sourcesContent":["import { AbstractParam } from \"../context/AbstractParam\";\nimport { dbToGain, gainToDb } from \"../type/Conversions\";\nimport { Decibels, Frequency, Positive, Time, UnitMap, UnitName } from \"../type/Units\";\nimport { isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { ToneWithContext, ToneWithContextOptions } from \"./ToneWithContext\";\nimport { EQ } from \"../util/Math\";\nimport { assert, assertRange } from \"../util/Debug\";\n\nexport interface ParamOptions<TypeName extends UnitName> extends ToneWithContextOptions {\n\tunits: TypeName;\n\tvalue?: UnitMap[TypeName];\n\tparam: AudioParam | Param<TypeName>;\n\tconvert: boolean;\n\tminValue?: number;\n\tmaxValue?: number;\n\tswappable?: boolean;\n}\n\n/**\n * the possible automation types\n */\ntype AutomationType = \"linearRampToValueAtTime\" | \"exponentialRampToValueAtTime\" | \"setValueAtTime\" | \"setTargetAtTime\" | \"cancelScheduledValues\";\n\ninterface TargetAutomationEvent {\n\ttype: \"setTargetAtTime\";\n\ttime: number;\n\tvalue: number;\n\tconstant: number;\n}\n\ninterface NormalAutomationEvent {\n\ttype: Exclude<AutomationType, \"setTargetAtTime\">;\n\ttime: number;\n\tvalue: number;\n}\n/**\n * The events on the automation\n */\nexport type AutomationEvent = NormalAutomationEvent | TargetAutomationEvent;\n\n/**\n * Param wraps the native Web Audio's AudioParam to provide\n * additional unit conversion functionality. It also\n * serves as a base-class for classes which have a single,\n * automatable parameter.\n * @category Core\n */\nexport class Param<TypeName extends UnitName = \"number\">\n\textends ToneWithContext<ParamOptions<TypeName>>\n\timplements AbstractParam<TypeName> {\n\n\treadonly name: string = \"Param\";\n\n\treadonly input: GainNode | AudioParam;\n\n\treadonly units: UnitName;\n\tconvert: boolean;\n\toverridden = false;\n\n\t/**\n\t * The timeline which tracks all of the automations.\n\t */\n\tprotected _events: Timeline<AutomationEvent>;\n\n\t/**\n\t * The native parameter to control\n\t */\n\tprotected _param: AudioParam;\n\n\t/**\n\t * The default value before anything is assigned\n\t */\n\tprotected _initialValue: number;\n\n\t/**\n\t * The minimum output value\n\t */\n\tprivate _minOutput = 1e-7;\n\n\t/**\n\t * Private reference to the min and max values if passed into the constructor\n\t */\n\tprivate readonly _minValue?: number;\n\tprivate readonly _maxValue?: number;\n\n\t/**\n\t * If the underlying AudioParam can be swapped out\n\t * using the setParam method. \n\t */\n\tprotected readonly _swappable: boolean;\n\n\t/**\n\t * @param param The AudioParam to wrap\n\t * @param units The unit name\n\t * @param convert Whether or not to convert the value to the target units\n\t */\n\tconstructor(param: AudioParam, units?: TypeName, convert?: boolean);\n\tconstructor(options: Partial<ParamOptions<TypeName>>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]));\n\n\t\tconst options = optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]);\n\n\t\tassert(isDefined(options.param) &&\n\t\t\t(isAudioParam(options.param) || options.param instanceof Param), \"param must be an AudioParam\");\n\n\t\twhile (!isAudioParam(options.param)) {\n\t\t\toptions.param = options.param._param;\n\t\t}\n\n\t\tthis._swappable = isDefined(options.swappable) ? options.swappable : false;\n\t\tif (this._swappable) {\n\t\t\tthis.input = this.context.createGain();\n\t\t\t// initialize\n\t\t\tthis._param = options.param;\n\t\t\tthis.input.connect(this._param);\n\t\t} else {\n\t\t\tthis._param = this.input = options.param;\n\t\t}\n\t\tthis._events = new Timeline<AutomationEvent>(1000);\n\t\tthis._initialValue = this._param.defaultValue;\n\t\tthis.units = options.units;\n\t\tthis.convert = options.convert;\n\t\tthis._minValue = options.minValue;\n\t\tthis._maxValue = options.maxValue;\n\n\t\t// if the value is defined, set it immediately\n\t\tif (isDefined(options.value) && options.value !== this._toType(this._initialValue)) {\n\t\t\tthis.setValueAtTime(options.value, 0);\n\t\t}\n\t}\n\n\tstatic getDefaults(): ParamOptions<any> {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tconvert: true,\n\t\t\tunits: \"number\" as UnitName,\n\t\t} as ParamOptions<any>);\n\t}\n\n\tget value(): UnitMap[TypeName] {\n\t\tconst now = this.now();\n\t\treturn this.getValueAtTime(now);\n\t}\n\tset value(value) {\n\t\tthis.cancelScheduledValues(this.now());\n\t\tthis.setValueAtTime(value, this.now());\n\t}\n\n\tget minValue(): number {\n\t\t// if it's not the default minValue, return it\n\t\tif (isDefined(this._minValue)) {\n\t\t\treturn this._minValue;\n\t\t} else if (this.units === \"time\" || this.units === \"frequency\" ||\n\t\t\tthis.units === \"normalRange\" || this.units === \"positive\" ||\n\t\t\tthis.units === \"transportTime\" || this.units === \"ticks\" ||\n\t\t\tthis.units === \"bpm\" || this.units === \"hertz\" || this.units === \"samples\") {\n\t\t\treturn 0;\n\t\t} else if (this.units === \"audioRange\") {\n\t\t\treturn -1;\n\t\t} else if (this.units === \"decibels\") {\n\t\t\treturn -Infinity;\n\t\t} else {\n\t\t\treturn this._param.minValue;\n\t\t}\n\t}\n\n\tget maxValue(): number {\n\t\tif (isDefined(this._maxValue)) {\n\t\t\treturn this._maxValue;\n\t\t} else if (this.units === \"normalRange\" ||\n\t\t\tthis.units === \"audioRange\") {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn this._param.maxValue;\n\t\t}\n\t}\n\n\t/**\n\t * Type guard based on the unit name\n\t */\n\tprivate _is<T>(arg: any, type: UnitName): arg is T {\n\t\treturn this.units === type;\n\t}\n\n\t/**\n\t * Make sure the value is always in the defined range\n\t */\n\tprivate _assertRange(value: number): number {\n\t\tif (isDefined(this.maxValue) && isDefined(this.minValue)) {\n\t\t\tassertRange(value, this._fromType(this.minValue), this._fromType(this.maxValue));\n\t\t}\n\t\treturn value;\n\t}\n\n\t/**\n\t * Convert the given value from the type specified by Param.units\n\t * into the destination value (such as Gain or Frequency).\n\t */\n\tprotected _fromType(val: UnitMap[TypeName]): number {\n\t\tif (this.convert && !this.overridden) {\n\t\t\tif (this._is<Time>(val, \"time\")) {\n\t\t\t\treturn this.toSeconds(val);\n\t\t\t} else if (this._is<Decibels>(val, \"decibels\")) {\n\t\t\t\treturn dbToGain(val);\n\t\t\t} else if (this._is<Frequency>(val, \"frequency\")) {\n\t\t\t\treturn this.toFrequency(val);\n\t\t\t} else {\n\t\t\t\treturn val as number;\n\t\t\t}\n\t\t} else if (this.overridden) {\n\t\t\t// if it's overridden, should only schedule 0s\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn val as number;\n\t\t}\n\t}\n\n\t/**\n\t * Convert the parameters value into the units specified by Param.units.\n\t */\n\tprotected _toType(val: number): UnitMap[TypeName] {\n\t\tif (this.convert && this.units === \"decibels\") {\n\t\t\treturn gainToDb(val) as UnitMap[TypeName];\n\t\t} else {\n\t\t\treturn val as UnitMap[TypeName];\n\t\t}\n\t}\n\n\t//-------------------------------------\n\t// ABSTRACT PARAM INTERFACE\n\t// all docs are generated from ParamInterface.ts\n\t//-------------------------------------\n\n\tsetValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst numericValue = this._fromType(value);\n\t\tassert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to setValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(time)}`);\n\t\tthis._assertRange(numericValue);\n\t\tthis.log(this.units, \"setValueAtTime\", value, computedTime);\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"setValueAtTime\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis._param.setValueAtTime(numericValue, computedTime);\n\t\treturn this;\n\t}\n\n\tgetValueAtTime(time: Time): UnitMap[TypeName] {\n\t\tconst computedTime = Math.max(this.toSeconds(time), 0);\n\t\tconst after = this._events.getAfter(computedTime);\n\t\tconst before = this._events.get(computedTime);\n\t\tlet value = this._initialValue;\n\t\t// if it was set by\n\t\tif (before === null) {\n\t\t\tvalue = this._initialValue;\n\t\t} else if (before.type === \"setTargetAtTime\" && (after === null || after.type === \"setValueAtTime\")) {\n\t\t\tconst previous = this._events.getBefore(before.time);\n\t\t\tlet previousVal;\n\t\t\tif (previous === null) {\n\t\t\t\tpreviousVal = this._initialValue;\n\t\t\t} else {\n\t\t\t\tpreviousVal = previous.value;\n\t\t\t}\n\t\t\tif (before.type === \"setTargetAtTime\") {\n\t\t\t\tvalue = this._exponentialApproach(before.time, previousVal, before.value, before.constant, computedTime);\n\t\t\t}\n\t\t} else if (after === null) {\n\t\t\tvalue = before.value;\n\t\t} else if (after.type === \"linearRampToValueAtTime\" || after.type === \"exponentialRampToValueAtTime\") {\n\t\t\tlet beforeValue = before.value;\n\t\t\tif (before.type === \"setTargetAtTime\") {\n\t\t\t\tconst previous = this._events.getBefore(before.time);\n\t\t\t\tif (previous === null) {\n\t\t\t\t\tbeforeValue = this._initialValue;\n\t\t\t\t} else {\n\t\t\t\t\tbeforeValue = previous.value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (after.type === \"linearRampToValueAtTime\") {\n\t\t\t\tvalue = this._linearInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n\t\t\t} else {\n\t\t\t\tvalue = this._exponentialInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n\t\t\t}\n\t\t} else {\n\t\t\tvalue = before.value;\n\t\t}\n\t\treturn this._toType(value);\n\t}\n\n\tsetRampPoint(time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tlet currentVal = this.getValueAtTime(time);\n\t\tthis.cancelAndHoldAtTime(time);\n\t\tif (this._fromType(currentVal) === 0) {\n\t\t\tcurrentVal = this._toType(this._minOutput);\n\t\t}\n\t\tthis.setValueAtTime(currentVal, time);\n\t\treturn this;\n\t}\n\n\tlinearRampToValueAtTime(value: UnitMap[TypeName], endTime: Time): this {\n\t\tconst numericValue = this._fromType(value);\n\t\tconst computedTime = this.toSeconds(endTime);\n\t\tassert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);\n\t\tthis._assertRange(numericValue);\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"linearRampToValueAtTime\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis.log(this.units, \"linearRampToValueAtTime\", value, computedTime);\n\t\tthis._param.linearRampToValueAtTime(numericValue, computedTime);\n\t\treturn this;\n\t}\n\n\texponentialRampToValueAtTime(value: UnitMap[TypeName], endTime: Time): this {\n\t\tlet numericValue = this._fromType(value);\n\t\t// the value can't be 0\n\t\tnumericValue = EQ(numericValue, 0) ? this._minOutput : numericValue;\n\t\tthis._assertRange(numericValue);\n\t\tconst computedTime = this.toSeconds(endTime);\n\t\tassert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);\n\t\t// store the event\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"exponentialRampToValueAtTime\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis.log(this.units, \"exponentialRampToValueAtTime\", value, computedTime);\n\t\tthis._param.exponentialRampToValueAtTime(numericValue, computedTime);\n\t\treturn this;\n\t}\n\n\texponentialRampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: Time): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n\t\treturn this;\n\t}\n\n\tlinearRampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: Time): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n\t\treturn this;\n\t}\n\n\ttargetRampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: Time): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.exponentialApproachValueAtTime(value, startTime, rampTime);\n\t\treturn this;\n\t}\n\n\texponentialApproachValueAtTime(value: UnitMap[TypeName], time: Time, rampTime: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\trampTime = this.toSeconds(rampTime);\n\t\tconst timeConstant = Math.log(rampTime + 1) / Math.log(200);\n\t\tthis.setTargetAtTime(value, time, timeConstant);\n\t\t// at 90% start a linear ramp to the final value\n\t\tthis.cancelAndHoldAtTime(time + rampTime * 0.9);\n\t\tthis.linearRampToValueAtTime(value, time + rampTime);\n\t\treturn this;\n\t}\n\n\tsetTargetAtTime(value: UnitMap[TypeName], startTime: Time, timeConstant: Positive): this {\n\t\tconst numericValue = this._fromType(value);\n\t\t// The value will never be able to approach without timeConstant > 0.\n\t\tassert(isFinite(timeConstant) && timeConstant > 0, \"timeConstant must be a number greater than 0\");\n\t\tconst computedTime = this.toSeconds(startTime);\n\t\tthis._assertRange(numericValue);\n\t\tassert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to setTargetAtTime: ${JSON.stringify(value)}, ${JSON.stringify(startTime)}`);\n\t\tthis._events.add({\n\t\t\tconstant: timeConstant,\n\t\t\ttime: computedTime,\n\t\t\ttype: \"setTargetAtTime\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis.log(this.units, \"setTargetAtTime\", value, computedTime, timeConstant);\n\t\tthis._param.setTargetAtTime(numericValue, computedTime, timeConstant);\n\t\treturn this;\n\t}\n\n\tsetValueCurveAtTime(values: UnitMap[TypeName][], startTime: Time, duration: Time, scaling = 1): this {\n\t\tduration = this.toSeconds(duration);\n\t\tstartTime = this.toSeconds(startTime);\n\t\tconst startingValue = this._fromType(values[0]) * scaling;\n\t\tthis.setValueAtTime(this._toType(startingValue), startTime);\n\t\tconst segTime = duration / (values.length - 1);\n\t\tfor (let i = 1; i < values.length; i++) {\n\t\t\tconst numericValue = this._fromType(values[i]) * scaling;\n\t\t\tthis.linearRampToValueAtTime(this._toType(numericValue), startTime + i * segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\tcancelScheduledValues(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tassert(isFinite(computedTime), `Invalid argument to cancelScheduledValues: ${JSON.stringify(time)}`);\n\t\tthis._events.cancel(computedTime);\n\t\tthis._param.cancelScheduledValues(computedTime);\n\t\tthis.log(this.units, \"cancelScheduledValues\", computedTime);\n\t\treturn this;\n\t}\n\n\tcancelAndHoldAtTime(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst valueAtTime = this._fromType(this.getValueAtTime(computedTime));\n\t\t// remove the schedule events\n\t\tassert(isFinite(computedTime), `Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(time)}`);\n\n\t\tthis.log(this.units, \"cancelAndHoldAtTime\", computedTime, \"value=\" + valueAtTime);\n\t\t\n\t\t// if there is an event at the given computedTime\n\t\t// and that even is not a \"set\"\n\t\tconst before = this._events.get(computedTime);\n\t\tconst after = this._events.getAfter(computedTime);\n\t\tif (before && EQ(before.time, computedTime)) {\n\t\t\t// remove everything after\n\t\t\tif (after) {\n\t\t\t\tthis._param.cancelScheduledValues(after.time);\n\t\t\t\tthis._events.cancel(after.time);\n\t\t\t} else {\n\t\t\t\tthis._param.cancelAndHoldAtTime(computedTime);\n\t\t\t\tthis._events.cancel(computedTime + this.sampleTime);\n\t\t\t}\n\t\t} else if (after) {\n\t\t\tthis._param.cancelScheduledValues(after.time);\n\t\t\t// cancel the next event(s)\n\t\t\tthis._events.cancel(after.time);\n\t\t\tif (after.type === \"linearRampToValueAtTime\") {\n\t\t\t\tthis.linearRampToValueAtTime(this._toType(valueAtTime), computedTime);\n\t\t\t} else if (after.type === \"exponentialRampToValueAtTime\") {\n\t\t\t\tthis.exponentialRampToValueAtTime(this._toType(valueAtTime), computedTime);\n\t\t\t}\n\t\t}\n\n\t\t// set the value at the given time\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"setValueAtTime\",\n\t\t\tvalue: valueAtTime,\n\t\t});\n\t\tthis._param.setValueAtTime(valueAtTime, computedTime);\n\t\treturn this;\n\t}\n\n\trampTo(value: UnitMap[TypeName], rampTime: Time = 0.1, startTime?: Time): this {\n\t\tif (this.units === \"frequency\" || this.units === \"bpm\" || this.units === \"decibels\") {\n\t\t\tthis.exponentialRampTo(value, rampTime, startTime);\n\t\t} else {\n\t\t\tthis.linearRampTo(value, rampTime, startTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Apply all of the previously scheduled events to the passed in Param or AudioParam.\n\t * The applied values will start at the context's current time and schedule\n\t * all of the events which are scheduled on this Param onto the passed in param.\n\t */\n\tapply(param: Param | AudioParam): this {\n\t\tconst now = this.context.currentTime;\n\t\t// set the param's value at the current time and schedule everything else\n\t\tparam.setValueAtTime(this.getValueAtTime(now) as number, now);\n\t\t// if the previous event was a curve, then set the rest of it\n\t\tconst previousEvent = this._events.get(now);\n\t\tif (previousEvent && previousEvent.type === \"setTargetAtTime\") {\n\t\t\t// approx it until the next event with linear ramps\n\t\t\tconst nextEvent = this._events.getAfter(previousEvent.time);\n\t\t\t// or for 2 seconds if there is no event\n\t\t\tconst endTime = nextEvent ? nextEvent.time : now + 2;\n\t\t\tconst subdivisions = (endTime - now) / 10;\n\t\t\tfor (let i = now; i < endTime; i += subdivisions) {\n\t\t\t\tparam.linearRampToValueAtTime(this.getValueAtTime(i) as number, i);\n\t\t\t}\n\t\t}\n\t\tthis._events.forEachAfter(this.context.currentTime, event => {\n\t\t\tif (event.type === \"cancelScheduledValues\") {\n\t\t\t\tparam.cancelScheduledValues(event.time);\n\t\t\t} else if (event.type === \"setTargetAtTime\") {\n\t\t\t\tparam.setTargetAtTime(event.value, event.time, event.constant);\n\t\t\t} else {\n\t\t\t\tparam[event.type](event.value, event.time);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Replace the Param's internal AudioParam. Will apply scheduled curves \n\t * onto the parameter and replace the connections.\n\t */\n\tsetParam(param: AudioParam): this {\n\t\tassert(this._swappable, \"The Param must be assigned as 'swappable' in the constructor\");\n\t\tconst input = this.input as GainNode;\n\t\tinput.disconnect(this._param);\n\t\tthis.apply(param);\n\t\tthis._param = param;\n\t\tinput.connect(this._param);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._events.dispose();\n\t\treturn this;\n\t}\n\n\tget defaultValue(): UnitMap[TypeName] {\n\t\treturn this._toType(this._param.defaultValue);\n\t}\n\n\t//-------------------------------------\n\t// \tAUTOMATION CURVE CALCULATIONS\n\t// \tMIT License, copyright (c) 2014 Jordan Santell\n\t//-------------------------------------\n\n\t// Calculates the the value along the curve produced by setTargetAtTime\n\tprotected _exponentialApproach(t0: number, v0: number, v1: number, timeConstant: number, t: number): number {\n\t\treturn v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);\n\t}\n\n\t// Calculates the the value along the curve produced by linearRampToValueAtTime\n\tprotected _linearInterpolate(t0: number, v0: number, t1: number, v1: number, t: number): number {\n\t\treturn v0 + (v1 - v0) * ((t - t0) / (t1 - t0));\n\t}\n\n\t// Calculates the the value along the curve produced by exponentialRampToValueAtTime\n\tprotected _exponentialInterpolate(t0: number, v0: number, t1: number, v1: number, t: number): number {\n\t\treturn v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}