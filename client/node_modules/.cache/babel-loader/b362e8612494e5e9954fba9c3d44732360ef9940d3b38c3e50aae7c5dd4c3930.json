{"ast":null,"code":"import { TicksClass } from \"../type/Ticks\";\nimport { TransportEvent } from \"./TransportEvent\";\n/**\n * TransportRepeatEvent is an internal class used by Tone.Transport\n * to schedule repeat events. This class should not be instantiated directly.\n */\nexport class TransportRepeatEvent extends TransportEvent {\n  /**\n   * @param transport The transport object which the event belongs to\n   */\n  constructor(transport, opts) {\n    super(transport, opts);\n    /**\n     * The ID of the current timeline event\n     */\n    this._currentId = -1;\n    /**\n     * The ID of the next timeline event\n     */\n    this._nextId = -1;\n    /**\n     * The time of the next event\n     */\n    this._nextTick = this.time;\n    /**\n     * a reference to the bound start method\n     */\n    this._boundRestart = this._restart.bind(this);\n    const options = Object.assign(TransportRepeatEvent.getDefaults(), opts);\n    this.duration = new TicksClass(transport.context, options.duration).valueOf();\n    this._interval = new TicksClass(transport.context, options.interval).valueOf();\n    this._nextTick = options.time;\n    this.transport.on(\"start\", this._boundRestart);\n    this.transport.on(\"loopStart\", this._boundRestart);\n    this.context = this.transport.context;\n    this._restart();\n  }\n  static getDefaults() {\n    return Object.assign({}, TransportEvent.getDefaults(), {\n      duration: Infinity,\n      interval: 1,\n      once: false\n    });\n  }\n  /**\n   * Invoke the callback. Returns the tick time which\n   * the next event should be scheduled at.\n   * @param  time  The AudioContext time in seconds of the event\n   */\n  invoke(time) {\n    // create more events if necessary\n    this._createEvents(time);\n    // call the super class\n    super.invoke(time);\n  }\n  /**\n   * Push more events onto the timeline to keep up with the position of the timeline\n   */\n  _createEvents(time) {\n    // schedule the next event\n    const ticks = this.transport.getTicksAtTime(time);\n    if (ticks >= this.time && ticks >= this._nextTick && this._nextTick + this._interval < this.time + this.duration) {\n      this._nextTick += this._interval;\n      this._currentId = this._nextId;\n      this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new TicksClass(this.context, this._nextTick).toSeconds());\n    }\n  }\n  /**\n   * Push more events onto the timeline to keep up with the position of the timeline\n   */\n  _restart(time) {\n    this.transport.clear(this._currentId);\n    this.transport.clear(this._nextId);\n    this._nextTick = this.time;\n    const ticks = this.transport.getTicksAtTime(time);\n    if (ticks > this.time) {\n      this._nextTick = this.time + Math.ceil((ticks - this.time) / this._interval) * this._interval;\n    }\n    this._currentId = this.transport.scheduleOnce(this.invoke.bind(this), new TicksClass(this.context, this._nextTick).toSeconds());\n    this._nextTick += this._interval;\n    this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new TicksClass(this.context, this._nextTick).toSeconds());\n  }\n  /**\n   * Clean up\n   */\n  dispose() {\n    super.dispose();\n    this.transport.clear(this._currentId);\n    this.transport.clear(this._nextId);\n    this.transport.off(\"start\", this._boundRestart);\n    this.transport.off(\"loopStart\", this._boundRestart);\n    return this;\n  }\n}","map":{"version":3,"names":["TicksClass","TransportEvent","TransportRepeatEvent","constructor","transport","opts","_currentId","_nextId","_nextTick","time","_boundRestart","_restart","bind","options","Object","assign","getDefaults","duration","context","valueOf","_interval","interval","on","Infinity","once","invoke","_createEvents","ticks","getTicksAtTime","scheduleOnce","toSeconds","clear","Math","ceil","dispose","off"],"sources":["/Users/ianstrom/Development/code/Capstone/client/node_modules/tone/Tone/core/clock/TransportRepeatEvent.ts"],"sourcesContent":["import { BaseContext } from \"../context/BaseContext\";\nimport { TicksClass } from \"../type/Ticks\";\nimport { Seconds, Ticks, Time } from \"../type/Units\";\nimport { TransportEvent, TransportEventOptions } from \"./TransportEvent\";\n\ntype Transport = import(\"../clock/Transport\").Transport;\n\ninterface TransportRepeatEventOptions extends TransportEventOptions {\n\tinterval: Ticks;\n\tduration: Ticks;\n}\n\n/**\n * TransportRepeatEvent is an internal class used by Tone.Transport\n * to schedule repeat events. This class should not be instantiated directly.\n */\nexport class TransportRepeatEvent extends TransportEvent {\n\n\t/**\n\t * When the event should stop repeating\n\t */\n\tprivate duration: Ticks;\n\n\t/**\n\t * The interval of the repeated event\n\t */\n\tprivate _interval: Ticks;\n\n\t/**\n\t * The ID of the current timeline event\n\t */\n\tprivate _currentId = -1;\n\n\t/**\n\t * The ID of the next timeline event\n\t */\n\tprivate _nextId = -1;\n\n\t/**\n\t * The time of the next event\n\t */\n\tprivate _nextTick = this.time;\n\n\t/**\n\t * a reference to the bound start method\n\t */\n\tprivate _boundRestart = this._restart.bind(this);\n\n\t/**\n\t * The audio context belonging to this event\n\t */\n\tprotected context: BaseContext;\n\n\t/**\n\t * @param transport The transport object which the event belongs to\n\t */\n\tconstructor(transport: Transport, opts: Partial<TransportRepeatEventOptions>) {\n\n\t\tsuper(transport, opts);\n\n\t\tconst options = Object.assign(TransportRepeatEvent.getDefaults(), opts);\n\n\t\tthis.duration = new TicksClass(transport.context, options.duration).valueOf();\n\t\tthis._interval = new TicksClass(transport.context, options.interval).valueOf();\n\t\tthis._nextTick = options.time;\n\t\tthis.transport.on(\"start\", this._boundRestart);\n\t\tthis.transport.on(\"loopStart\", this._boundRestart);\n\t\tthis.context = this.transport.context;\n\t\tthis._restart();\n\t}\n\n\tstatic getDefaults(): TransportRepeatEventOptions {\n\t\treturn Object.assign({}, TransportEvent.getDefaults(), {\n\t\t\tduration: Infinity,\n\t\t\tinterval: 1,\n\t\t\tonce: false,\n\t\t});\n\t}\n\n\t/**\n\t * Invoke the callback. Returns the tick time which\n\t * the next event should be scheduled at.\n\t * @param  time  The AudioContext time in seconds of the event\n\t */\n\tinvoke(time: Seconds): void {\n\t\t// create more events if necessary\n\t\tthis._createEvents(time);\n\t\t// call the super class\n\t\tsuper.invoke(time);\n\t}\n\n\t/**\n\t * Push more events onto the timeline to keep up with the position of the timeline\n\t */\n\tprivate _createEvents(time: Seconds): void {\n\t\t// schedule the next event\n\t\tconst ticks = this.transport.getTicksAtTime(time);\n\t\tif (ticks >= this.time && ticks >= this._nextTick && this._nextTick + this._interval < this.time + this.duration) {\n\t\t\tthis._nextTick += this._interval;\n\t\t\tthis._currentId = this._nextId;\n\t\t\tthis._nextId = this.transport.scheduleOnce(this.invoke.bind(this),\n\t\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds());\n\t\t}\n\t}\n\n\t/**\n\t * Push more events onto the timeline to keep up with the position of the timeline\n\t */\n\tprivate _restart(time?: Time): void {\n\t\tthis.transport.clear(this._currentId);\n\t\tthis.transport.clear(this._nextId);\n\t\tthis._nextTick = this.time;\n\t\tconst ticks = this.transport.getTicksAtTime(time);\n\t\tif (ticks > this.time) {\n\t\t\tthis._nextTick = this.time + Math.ceil((ticks - this.time) / this._interval) * this._interval;\n\t\t}\n\t\tthis._currentId = this.transport.scheduleOnce(this.invoke.bind(this),\n\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds());\n\t\tthis._nextTick += this._interval;\n\t\tthis._nextId = this.transport.scheduleOnce(this.invoke.bind(this),\n\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds());\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.transport.clear(this._currentId);\n\t\tthis.transport.clear(this._nextId);\n\t\tthis.transport.off(\"start\", this._boundRestart);\n\t\tthis.transport.off(\"loopStart\", this._boundRestart);\n\t\treturn this;\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}