{"ast":null,"code":"/**\n * A class which provides a reliable callback using either\n * a Web Worker, or if that isn't supported, falls back to setTimeout.\n */\nexport class Ticker {\n  constructor(callback, type, updateInterval) {\n    this._callback = callback;\n    this._type = type;\n    this._updateInterval = updateInterval;\n    // create the clock source for the first time\n    this._createClock();\n  }\n  /**\n   * Generate a web worker\n   */\n  _createWorker() {\n    const blob = new Blob([/* javascript */`\n\t\t\t// the initial timeout time\n\t\t\tlet timeoutTime =  ${(this._updateInterval * 1000).toFixed(1)};\n\t\t\t// onmessage callback\n\t\t\tself.onmessage = function(msg){\n\t\t\t\ttimeoutTime = parseInt(msg.data);\n\t\t\t};\n\t\t\t// the tick function which posts a message\n\t\t\t// and schedules a new tick\n\t\t\tfunction tick(){\n\t\t\t\tsetTimeout(tick, timeoutTime);\n\t\t\t\tself.postMessage('tick');\n\t\t\t}\n\t\t\t// call tick initially\n\t\t\ttick();\n\t\t\t`], {\n      type: \"text/javascript\"\n    });\n    const blobUrl = URL.createObjectURL(blob);\n    const worker = new Worker(blobUrl);\n    worker.onmessage = this._callback.bind(this);\n    this._worker = worker;\n  }\n  /**\n   * Create a timeout loop\n   */\n  _createTimeout() {\n    this._timeout = setTimeout(() => {\n      this._createTimeout();\n      this._callback();\n    }, this._updateInterval * 1000);\n  }\n  /**\n   * Create the clock source.\n   */\n  _createClock() {\n    if (this._type === \"worker\") {\n      try {\n        this._createWorker();\n      } catch (e) {\n        // workers not supported, fallback to timeout\n        this._type = \"timeout\";\n        this._createClock();\n      }\n    } else if (this._type === \"timeout\") {\n      this._createTimeout();\n    }\n  }\n  /**\n   * Clean up the current clock source\n   */\n  _disposeClock() {\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n      this._timeout = 0;\n    }\n    if (this._worker) {\n      this._worker.terminate();\n      this._worker.onmessage = null;\n    }\n  }\n  /**\n   * The rate in seconds the ticker will update\n   */\n  get updateInterval() {\n    return this._updateInterval;\n  }\n  set updateInterval(interval) {\n    this._updateInterval = Math.max(interval, 128 / 44100);\n    if (this._type === \"worker\") {\n      this._worker.postMessage(Math.max(interval * 1000, 1));\n    }\n  }\n  /**\n   * The type of the ticker, either a worker or a timeout\n   */\n  get type() {\n    return this._type;\n  }\n  set type(type) {\n    this._disposeClock();\n    this._type = type;\n    this._createClock();\n  }\n  /**\n   * Clean up\n   */\n  dispose() {\n    this._disposeClock();\n  }\n}","map":{"version":3,"names":["Ticker","constructor","callback","type","updateInterval","_callback","_type","_updateInterval","_createClock","_createWorker","blob","Blob","toFixed","blobUrl","URL","createObjectURL","worker","Worker","onmessage","bind","_worker","_createTimeout","_timeout","setTimeout","e","_disposeClock","clearTimeout","terminate","interval","Math","max","postMessage","dispose"],"sources":["/Users/ianstrom/Development/code/Capstone/node_modules/tone/Tone/core/clock/Ticker.ts"],"sourcesContent":["import { Seconds } from \"../type/Units\";\n\nexport type TickerClockSource = \"worker\" | \"timeout\" | \"offline\";\n\n/**\n * A class which provides a reliable callback using either\n * a Web Worker, or if that isn't supported, falls back to setTimeout.\n */\nexport class Ticker {\n\n\t/**\n\t * Either \"worker\" or \"timeout\" or \"offline\"\n\t */\n\tprivate _type: TickerClockSource;\n\n\t/**\n\t * The update interval of the worker\n\t */\n\tprivate _updateInterval: Seconds;\n\n\t/**\n\t * The callback to invoke at regular intervals\n\t */\n\tprivate _callback: () => void;\n\n\t/**\n\t * track the callback interval\n\t */\n\tprivate _timeout!: ReturnType<typeof setTimeout>;\n\n\t/**\n\t * private reference to the worker\n\t */\n\tprivate _worker!: Worker;\n\n\tconstructor(callback: () => void, type: TickerClockSource, updateInterval: Seconds) {\n\n\t\tthis._callback = callback;\n\t\tthis._type = type;\n\t\tthis._updateInterval = updateInterval;\n\n\t\t// create the clock source for the first time\n\t\tthis._createClock();\n\t}\n\n\t/**\n\t * Generate a web worker\n\t */\n\tprivate _createWorker(): void {\n\n\t\tconst blob = new Blob([\n\t\t\t/* javascript */`\n\t\t\t// the initial timeout time\n\t\t\tlet timeoutTime =  ${(this._updateInterval * 1000).toFixed(1)};\n\t\t\t// onmessage callback\n\t\t\tself.onmessage = function(msg){\n\t\t\t\ttimeoutTime = parseInt(msg.data);\n\t\t\t};\n\t\t\t// the tick function which posts a message\n\t\t\t// and schedules a new tick\n\t\t\tfunction tick(){\n\t\t\t\tsetTimeout(tick, timeoutTime);\n\t\t\t\tself.postMessage('tick');\n\t\t\t}\n\t\t\t// call tick initially\n\t\t\ttick();\n\t\t\t`\n\t\t], { type: \"text/javascript\" });\n\t\tconst blobUrl = URL.createObjectURL(blob);\n\t\tconst worker = new Worker(blobUrl);\n\n\t\tworker.onmessage = this._callback.bind(this);\n\n\t\tthis._worker = worker;\n\t}\n\n\t/**\n\t * Create a timeout loop\n\t */\n\tprivate _createTimeout(): void {\n\t\tthis._timeout = setTimeout(() => {\n\t\t\tthis._createTimeout();\n\t\t\tthis._callback();\n\t\t}, this._updateInterval * 1000);\n\t}\n\n\t/**\n\t * Create the clock source.\n\t */\n\tprivate _createClock(): void {\n\t\tif (this._type === \"worker\") {\n\t\t\ttry {\n\t\t\t\tthis._createWorker();\n\t\t\t} catch (e) {\n\t\t\t\t// workers not supported, fallback to timeout\n\t\t\t\tthis._type = \"timeout\";\n\t\t\t\tthis._createClock();\n\t\t\t}\n\t\t} else if (this._type === \"timeout\") {\n\t\t\tthis._createTimeout();\n\t\t}\n\t}\n\n\t/**\n\t * Clean up the current clock source\n\t */\n\tprivate _disposeClock(): void {\n\t\tif (this._timeout) {\n\t\t\tclearTimeout(this._timeout);\n\t\t\tthis._timeout = 0;\n\t\t}\n\t\tif (this._worker) {\n\t\t\tthis._worker.terminate();\n\t\t\tthis._worker.onmessage = null;\n\t\t}\n\t}\n\n\t/**\n\t * The rate in seconds the ticker will update\n\t */\n\tget updateInterval(): Seconds {\n\t\treturn this._updateInterval;\n\t}\n\tset updateInterval(interval: Seconds) {\n\t\tthis._updateInterval = Math.max(interval, 128 / 44100);\n\t\tif (this._type === \"worker\") {\n\t\t\tthis._worker.postMessage(Math.max(interval * 1000, 1));\n\t\t}\n\t}\n\n\t/**\n\t * The type of the ticker, either a worker or a timeout\n\t */\n\tget type(): TickerClockSource {\n\t\treturn this._type;\n\t}\n\tset type(type: TickerClockSource) {\n\t\tthis._disposeClock();\n\t\tthis._type = type;\n\t\tthis._createClock();\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): void {\n\t\tthis._disposeClock();\n\t}\n}\n"],"mappings":"AAIA;;;;AAIA,OAAM,MAAOA,MAAM;EA2BlBC,YAAYC,QAAoB,EAAEC,IAAuB,EAAEC,cAAuB;IAEjF,IAAI,CAACC,SAAS,GAAGH,QAAQ;IACzB,IAAI,CAACI,KAAK,GAAGH,IAAI;IACjB,IAAI,CAACI,eAAe,GAAGH,cAAc;IAErC;IACA,IAAI,CAACI,YAAY,EAAE;EACpB;EAEA;;;EAGQC,aAAaA,CAAA;IAEpB,MAAMC,IAAI,GAAG,IAAIC,IAAI,CAAC,CACrB,gBAAgB;;wBAEK,CAAC,IAAI,CAACJ,eAAe,GAAG,IAAI,EAAEK,OAAO,CAAC,CAAC,CAAC;;;;;;;;;;;;;IAa5D,CACD,EAAE;MAAET,IAAI,EAAE;IAAiB,CAAE,CAAC;IAC/B,MAAMU,OAAO,GAAGC,GAAG,CAACC,eAAe,CAACL,IAAI,CAAC;IACzC,MAAMM,MAAM,GAAG,IAAIC,MAAM,CAACJ,OAAO,CAAC;IAElCG,MAAM,CAACE,SAAS,GAAG,IAAI,CAACb,SAAS,CAACc,IAAI,CAAC,IAAI,CAAC;IAE5C,IAAI,CAACC,OAAO,GAAGJ,MAAM;EACtB;EAEA;;;EAGQK,cAAcA,CAAA;IACrB,IAAI,CAACC,QAAQ,GAAGC,UAAU,CAAC,MAAK;MAC/B,IAAI,CAACF,cAAc,EAAE;MACrB,IAAI,CAAChB,SAAS,EAAE;IACjB,CAAC,EAAE,IAAI,CAACE,eAAe,GAAG,IAAI,CAAC;EAChC;EAEA;;;EAGQC,YAAYA,CAAA;IACnB,IAAI,IAAI,CAACF,KAAK,KAAK,QAAQ,EAAE;MAC5B,IAAI;QACH,IAAI,CAACG,aAAa,EAAE;OACpB,CAAC,OAAOe,CAAC,EAAE;QACX;QACA,IAAI,CAAClB,KAAK,GAAG,SAAS;QACtB,IAAI,CAACE,YAAY,EAAE;;KAEpB,MAAM,IAAI,IAAI,CAACF,KAAK,KAAK,SAAS,EAAE;MACpC,IAAI,CAACe,cAAc,EAAE;;EAEvB;EAEA;;;EAGQI,aAAaA,CAAA;IACpB,IAAI,IAAI,CAACH,QAAQ,EAAE;MAClBI,YAAY,CAAC,IAAI,CAACJ,QAAQ,CAAC;MAC3B,IAAI,CAACA,QAAQ,GAAG,CAAC;;IAElB,IAAI,IAAI,CAACF,OAAO,EAAE;MACjB,IAAI,CAACA,OAAO,CAACO,SAAS,EAAE;MACxB,IAAI,CAACP,OAAO,CAACF,SAAS,GAAG,IAAI;;EAE/B;EAEA;;;EAGA,IAAId,cAAcA,CAAA;IACjB,OAAO,IAAI,CAACG,eAAe;EAC5B;EACA,IAAIH,cAAcA,CAACwB,QAAiB;IACnC,IAAI,CAACrB,eAAe,GAAGsB,IAAI,CAACC,GAAG,CAACF,QAAQ,EAAE,GAAG,GAAG,KAAK,CAAC;IACtD,IAAI,IAAI,CAACtB,KAAK,KAAK,QAAQ,EAAE;MAC5B,IAAI,CAACc,OAAO,CAACW,WAAW,CAACF,IAAI,CAACC,GAAG,CAACF,QAAQ,GAAG,IAAI,EAAE,CAAC,CAAC,CAAC;;EAExD;EAEA;;;EAGA,IAAIzB,IAAIA,CAAA;IACP,OAAO,IAAI,CAACG,KAAK;EAClB;EACA,IAAIH,IAAIA,CAACA,IAAuB;IAC/B,IAAI,CAACsB,aAAa,EAAE;IACpB,IAAI,CAACnB,KAAK,GAAGH,IAAI;IACjB,IAAI,CAACK,YAAY,EAAE;EACpB;EAEA;;;EAGAwB,OAAOA,CAAA;IACN,IAAI,CAACP,aAAa,EAAE;EACrB"},"metadata":{},"sourceType":"module","externalDependencies":[]}