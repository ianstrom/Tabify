{"ast":null,"code":"import { isArray } from \"./TypeCheck\";\n/**\n * Make the property not writable using `defineProperty`. Internal use only.\n */\nexport function readOnly(target, property) {\n  if (isArray(property)) {\n    property.forEach(str => readOnly(target, str));\n  } else {\n    Object.defineProperty(target, property, {\n      enumerable: true,\n      writable: false\n    });\n  }\n}\n/**\n * Make an attribute writeable. Internal use only.\n */\nexport function writable(target, property) {\n  if (isArray(property)) {\n    property.forEach(str => writable(target, str));\n  } else {\n    Object.defineProperty(target, property, {\n      writable: true\n    });\n  }\n}\nexport const noOp = () => {\n  // no operation here!\n};","map":{"version":3,"names":["isArray","readOnly","target","property","forEach","str","Object","defineProperty","enumerable","writable","noOp"],"sources":["/Users/ianstrom/Development/code/Capstone/node_modules/tone/Tone/core/util/Interface.ts"],"sourcesContent":["import { isArray } from \"./TypeCheck\";\n\n// return an interface which excludes certain keys\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n\n/**\n * Make the property not writable using `defineProperty`. Internal use only.\n */\nexport function readOnly(target: object, property: string | string[]): void {\n\tif (isArray(property)) {\n\t\tproperty.forEach(str => readOnly(target, str));\n\t} else {\n\t\tObject.defineProperty(target, property, {\n\t\t\tenumerable: true,\n\t\t\twritable: false,\n\t\t});\n\t}\n}\n\n/**\n * Make an attribute writeable. Internal use only.\n */\nexport function writable(target: object, property: string | string[]): void {\n\tif (isArray(property)) {\n\t\tproperty.forEach(str => writable(target, str));\n\t} else {\n\t\tObject.defineProperty(target, property, {\n\t\t\twritable: true,\n\t\t});\n\t}\n}\n\nexport const noOp: (...args: any[]) => any = () => {\n\t// no operation here!\n};\n\n/**\n * Recursive Partial taken from here: https://stackoverflow.com/a/51365037\n */\nexport type RecursivePartial<T> = {\n\t[P in keyof T]?:\n\tT[P] extends Array<infer U> ? Array<RecursivePartial<U>> :\n\t\tT[P] extends object ? RecursivePartial<T[P]> :\n\t\t\tT[P];\n};\n"],"mappings":"AAAA,SAASA,OAAO,QAAQ,aAAa;AAKrC;;;AAGA,OAAM,SAAUC,QAAQA,CAACC,MAAc,EAAEC,QAA2B;EACnE,IAAIH,OAAO,CAACG,QAAQ,CAAC,EAAE;IACtBA,QAAQ,CAACC,OAAO,CAACC,GAAG,IAAIJ,QAAQ,CAACC,MAAM,EAAEG,GAAG,CAAC,CAAC;GAC9C,MAAM;IACNC,MAAM,CAACC,cAAc,CAACL,MAAM,EAAEC,QAAQ,EAAE;MACvCK,UAAU,EAAE,IAAI;MAChBC,QAAQ,EAAE;KACV,CAAC;;AAEJ;AAEA;;;AAGA,OAAM,SAAUA,QAAQA,CAACP,MAAc,EAAEC,QAA2B;EACnE,IAAIH,OAAO,CAACG,QAAQ,CAAC,EAAE;IACtBA,QAAQ,CAACC,OAAO,CAACC,GAAG,IAAII,QAAQ,CAACP,MAAM,EAAEG,GAAG,CAAC,CAAC;GAC9C,MAAM;IACNC,MAAM,CAACC,cAAc,CAACL,MAAM,EAAEC,QAAQ,EAAE;MACvCM,QAAQ,EAAE;KACV,CAAC;;AAEJ;AAEA,OAAO,MAAMC,IAAI,GAA4BA,CAAA,KAAK;EACjD;AAAA,CACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}