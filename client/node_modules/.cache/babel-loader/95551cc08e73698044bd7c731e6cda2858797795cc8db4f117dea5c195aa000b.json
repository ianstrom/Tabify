{"ast":null,"code":"import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createWaveShaperNodeRendererFactory = (createNativeWaveShaperNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n  return () => {\n    const renderedNativeWaveShaperNodes = new WeakMap();\n    const createWaveShaperNode = async (proxy, nativeOfflineAudioContext) => {\n      let nativeWaveShaperNode = getNativeAudioNode(proxy);\n      // If the initially used nativeWaveShaperNode was not constructed on the same OfflineAudioContext it needs to be created again.\n      const nativeWaveShaperNodeIsOwnedByContext = isOwnedByContext(nativeWaveShaperNode, nativeOfflineAudioContext);\n      if (!nativeWaveShaperNodeIsOwnedByContext) {\n        const options = {\n          channelCount: nativeWaveShaperNode.channelCount,\n          channelCountMode: nativeWaveShaperNode.channelCountMode,\n          channelInterpretation: nativeWaveShaperNode.channelInterpretation,\n          curve: nativeWaveShaperNode.curve,\n          oversample: nativeWaveShaperNode.oversample\n        };\n        nativeWaveShaperNode = createNativeWaveShaperNode(nativeOfflineAudioContext, options);\n      }\n      renderedNativeWaveShaperNodes.set(nativeOfflineAudioContext, nativeWaveShaperNode);\n      if (isNativeAudioNodeFaker(nativeWaveShaperNode)) {\n        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode.inputs[0]);\n      } else {\n        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode);\n      }\n      return nativeWaveShaperNode;\n    };\n    return {\n      render(proxy, nativeOfflineAudioContext) {\n        const renderedNativeWaveShaperNode = renderedNativeWaveShaperNodes.get(nativeOfflineAudioContext);\n        if (renderedNativeWaveShaperNode !== undefined) {\n          return Promise.resolve(renderedNativeWaveShaperNode);\n        }\n        return createWaveShaperNode(proxy, nativeOfflineAudioContext);\n      }\n    };\n  };\n};","map":{"version":3,"names":["isNativeAudioNodeFaker","isOwnedByContext","createWaveShaperNodeRendererFactory","createNativeWaveShaperNode","getNativeAudioNode","renderInputsOfAudioNode","renderedNativeWaveShaperNodes","WeakMap","createWaveShaperNode","proxy","nativeOfflineAudioContext","nativeWaveShaperNode","nativeWaveShaperNodeIsOwnedByContext","options","channelCount","channelCountMode","channelInterpretation","curve","oversample","set","inputs","render","renderedNativeWaveShaperNode","get","undefined","Promise","resolve"],"sources":["/Users/ianstrom/Development/code/Capstone/client/node_modules/standardized-audio-context/src/factories/wave-shaper-node-renderer-factory.ts"],"sourcesContent":["import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IMinimalOfflineAudioContext, IOfflineAudioContext, IWaveShaperNode } from '../interfaces';\nimport { TNativeOfflineAudioContext, TNativeWaveShaperNode, TWaveShaperNodeRendererFactoryFactory } from '../types';\n\nexport const createWaveShaperNodeRendererFactory: TWaveShaperNodeRendererFactoryFactory = (\n    createNativeWaveShaperNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeWaveShaperNodes = new WeakMap<TNativeOfflineAudioContext, TNativeWaveShaperNode>();\n\n        const createWaveShaperNode = async (proxy: IWaveShaperNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeWaveShaperNode = getNativeAudioNode<T, TNativeWaveShaperNode>(proxy);\n\n            // If the initially used nativeWaveShaperNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeWaveShaperNodeIsOwnedByContext = isOwnedByContext(nativeWaveShaperNode, nativeOfflineAudioContext);\n\n            if (!nativeWaveShaperNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeWaveShaperNode.channelCount,\n                    channelCountMode: nativeWaveShaperNode.channelCountMode,\n                    channelInterpretation: nativeWaveShaperNode.channelInterpretation,\n                    curve: nativeWaveShaperNode.curve,\n                    oversample: nativeWaveShaperNode.oversample\n                };\n\n                nativeWaveShaperNode = createNativeWaveShaperNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeWaveShaperNodes.set(nativeOfflineAudioContext, nativeWaveShaperNode);\n\n            if (isNativeAudioNodeFaker(nativeWaveShaperNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode.inputs[0]);\n            } else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode);\n            }\n\n            return nativeWaveShaperNode;\n        };\n\n        return {\n            render(proxy: IWaveShaperNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeWaveShaperNode> {\n                const renderedNativeWaveShaperNode = renderedNativeWaveShaperNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeWaveShaperNode !== undefined) {\n                    return Promise.resolve(renderedNativeWaveShaperNode);\n                }\n\n                return createWaveShaperNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n"],"mappings":"AAAA,SAASA,sBAAsB,QAAQ,mCAAmC;AAC1E,SAASC,gBAAgB,QAAQ,gCAAgC;AAIjE,OAAO,MAAMC,mCAAmC,GAA0CA,CACtFC,0BAA0B,EAC1BC,kBAAkB,EAClBC,uBAAuB,KACvB;EACA,OAAO,MAAmE;IACtE,MAAMC,6BAA6B,GAAG,IAAIC,OAAO,EAAqD;IAEtG,MAAMC,oBAAoB,GAAG,MAAAA,CAAOC,KAAyB,EAAEC,yBAAqD,KAAI;MACpH,IAAIC,oBAAoB,GAAGP,kBAAkB,CAA2BK,KAAK,CAAC;MAE9E;MACA,MAAMG,oCAAoC,GAAGX,gBAAgB,CAACU,oBAAoB,EAAED,yBAAyB,CAAC;MAE9G,IAAI,CAACE,oCAAoC,EAAE;QACvC,MAAMC,OAAO,GAAG;UACZC,YAAY,EAAEH,oBAAoB,CAACG,YAAY;UAC/CC,gBAAgB,EAAEJ,oBAAoB,CAACI,gBAAgB;UACvDC,qBAAqB,EAAEL,oBAAoB,CAACK,qBAAqB;UACjEC,KAAK,EAAEN,oBAAoB,CAACM,KAAK;UACjCC,UAAU,EAAEP,oBAAoB,CAACO;SACpC;QAEDP,oBAAoB,GAAGR,0BAA0B,CAACO,yBAAyB,EAAEG,OAAO,CAAC;;MAGzFP,6BAA6B,CAACa,GAAG,CAACT,yBAAyB,EAAEC,oBAAoB,CAAC;MAElF,IAAIX,sBAAsB,CAACW,oBAAoB,CAAC,EAAE;QAC9C,MAAMN,uBAAuB,CAACI,KAAK,EAAEC,yBAAyB,EAAEC,oBAAoB,CAACS,MAAM,CAAC,CAAC,CAAC,CAAC;OAClG,MAAM;QACH,MAAMf,uBAAuB,CAACI,KAAK,EAAEC,yBAAyB,EAAEC,oBAAoB,CAAC;;MAGzF,OAAOA,oBAAoB;IAC/B,CAAC;IAED,OAAO;MACHU,MAAMA,CAACZ,KAAyB,EAAEC,yBAAqD;QACnF,MAAMY,4BAA4B,GAAGhB,6BAA6B,CAACiB,GAAG,CAACb,yBAAyB,CAAC;QAEjG,IAAIY,4BAA4B,KAAKE,SAAS,EAAE;UAC5C,OAAOC,OAAO,CAACC,OAAO,CAACJ,4BAA4B,CAAC;;QAGxD,OAAOd,oBAAoB,CAACC,KAAK,EAAEC,yBAAyB,CAAC;MACjE;KACH;EACL,CAAC;AACL,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}