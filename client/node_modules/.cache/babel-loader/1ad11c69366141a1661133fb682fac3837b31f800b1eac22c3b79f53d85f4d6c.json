{"ast":null,"code":"import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { ReadOnlyMap } from '../read-only-map';\nconst DEFAULT_OPTIONS = {\n  channelCount: 2,\n  // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.\n  channelCountMode: 'explicit',\n  channelInterpretation: 'speakers',\n  numberOfInputs: 1,\n  numberOfOutputs: 1,\n  parameterData: {},\n  processorOptions: {}\n};\nexport const createAudioWorkletNodeConstructor = (addUnrenderedAudioWorkletNode, audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, getAudioNodeConnections, getBackupOfflineAudioContext, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, sanitizeAudioWorkletNodeOptions, setActiveAudioWorkletNodeInputs, testAudioWorkletNodeOptionsClonability, wrapEventListener) => {\n  return class AudioWorkletNode extends audioNodeConstructor {\n    constructor(context, name, options) {\n      var _a;\n      const nativeContext = getNativeContext(context);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n      const mergedOptions = sanitizeAudioWorkletNodeOptions({\n        ...DEFAULT_OPTIONS,\n        ...options\n      });\n      // Bug #191: Safari doesn't throw an error if the options aren't clonable.\n      testAudioWorkletNodeOptionsClonability(mergedOptions);\n      const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n      const processorConstructor = nodeNameToProcessorConstructorMap === null || nodeNameToProcessorConstructorMap === void 0 ? void 0 : nodeNameToProcessorConstructorMap.get(name);\n      // Bug #186: Chrome and Edge do not allow to create an AudioWorkletNode on a closed AudioContext.\n      const nativeContextOrBackupOfflineAudioContext = isOffline || nativeContext.state !== 'closed' ? nativeContext : (_a = getBackupOfflineAudioContext(nativeContext)) !== null && _a !== void 0 ? _a : nativeContext;\n      const nativeAudioWorkletNode = createNativeAudioWorkletNode(nativeContextOrBackupOfflineAudioContext, isOffline ? null : context.baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, mergedOptions);\n      const audioWorkletNodeRenderer = isOffline ? createAudioWorkletNodeRenderer(name, mergedOptions, processorConstructor) : null;\n      /*\n       * @todo Add a mechanism to switch an AudioWorkletNode to passive once the process() function of the AudioWorkletProcessor\n       * returns false.\n       */\n      super(context, true, nativeAudioWorkletNode, audioWorkletNodeRenderer);\n      const parameters = [];\n      nativeAudioWorkletNode.parameters.forEach((nativeAudioParam, nm) => {\n        const audioParam = createAudioParam(this, isOffline, nativeAudioParam);\n        parameters.push([nm, audioParam]);\n      });\n      this._nativeAudioWorkletNode = nativeAudioWorkletNode;\n      this._onprocessorerror = null;\n      this._parameters = new ReadOnlyMap(parameters);\n      /*\n       * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to\n       * the destination.\n       */\n      if (isOffline) {\n        addUnrenderedAudioWorkletNode(nativeContext, this);\n      }\n      const {\n        activeInputs\n      } = getAudioNodeConnections(this);\n      setActiveAudioWorkletNodeInputs(nativeAudioWorkletNode, activeInputs);\n    }\n    get onprocessorerror() {\n      return this._onprocessorerror;\n    }\n    set onprocessorerror(value) {\n      const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n      this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;\n      const nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;\n      this._onprocessorerror = nativeOnProcessorError !== null && nativeOnProcessorError === wrappedListener ? value : nativeOnProcessorError;\n    }\n    get parameters() {\n      if (this._parameters === null) {\n        // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n        return this._nativeAudioWorkletNode.parameters;\n      }\n      return this._parameters;\n    }\n    get port() {\n      return this._nativeAudioWorkletNode.port;\n    }\n  };\n};","map":{"version":3,"names":["NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS","ReadOnlyMap","DEFAULT_OPTIONS","channelCount","channelCountMode","channelInterpretation","numberOfInputs","numberOfOutputs","parameterData","processorOptions","createAudioWorkletNodeConstructor","addUnrenderedAudioWorkletNode","audioNodeConstructor","createAudioParam","createAudioWorkletNodeRenderer","createNativeAudioWorkletNode","getAudioNodeConnections","getBackupOfflineAudioContext","getNativeContext","isNativeOfflineAudioContext","nativeAudioWorkletNodeConstructor","sanitizeAudioWorkletNodeOptions","setActiveAudioWorkletNodeInputs","testAudioWorkletNodeOptionsClonability","wrapEventListener","AudioWorkletNode","constructor","context","name","options","nativeContext","isOffline","mergedOptions","nodeNameToProcessorConstructorMap","get","processorConstructor","nativeContextOrBackupOfflineAudioContext","state","_a","nativeAudioWorkletNode","baseLatency","audioWorkletNodeRenderer","parameters","forEach","nativeAudioParam","nm","audioParam","push","_nativeAudioWorkletNode","_onprocessorerror","_parameters","activeInputs","onprocessorerror","value","wrappedListener","nativeOnProcessorError","port"],"sources":["/Users/ianstrom/Development/code/Capstone/node_modules/standardized-audio-context/src/factories/audio-worklet-node-constructor.ts"],"sourcesContent":["import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport {\n    IAudioParam,\n    IAudioWorkletNode,\n    IAudioWorkletNodeEventMap,\n    IAudioWorkletNodeOptions,\n    IMinimalAudioContext,\n    IMinimalOfflineAudioContext,\n    IOfflineAudioContext,\n    IReadOnlyMap\n} from '../interfaces';\nimport { ReadOnlyMap } from '../read-only-map';\nimport {\n    TAudioNodeRenderer,\n    TAudioParamMap,\n    TAudioWorkletNodeConstructorFactory,\n    TContext,\n    TErrorEventHandler,\n    TNativeAudioContext,\n    TNativeAudioParam,\n    TNativeAudioWorkletNode\n} from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    numberOfInputs: 1,\n    numberOfOutputs: 1,\n    parameterData: {},\n    processorOptions: {}\n} as const;\n\nexport const createAudioWorkletNodeConstructor: TAudioWorkletNodeConstructorFactory = (\n    addUnrenderedAudioWorkletNode,\n    audioNodeConstructor,\n    createAudioParam,\n    createAudioWorkletNodeRenderer,\n    createNativeAudioWorkletNode,\n    getAudioNodeConnections,\n    getBackupOfflineAudioContext,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    nativeAudioWorkletNodeConstructor,\n    sanitizeAudioWorkletNodeOptions,\n    setActiveAudioWorkletNodeInputs,\n    testAudioWorkletNodeOptionsClonability,\n    wrapEventListener\n) => {\n    return class AudioWorkletNode<T extends TContext>\n        extends audioNodeConstructor<T, IAudioWorkletNodeEventMap>\n        implements IAudioWorkletNode<T>\n    {\n        private _nativeAudioWorkletNode: TNativeAudioWorkletNode;\n\n        private _onprocessorerror: null | TErrorEventHandler<this>;\n\n        private _parameters: null | TAudioParamMap;\n\n        constructor(context: T, name: string, options?: Partial<IAudioWorkletNodeOptions>) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const mergedOptions = sanitizeAudioWorkletNodeOptions({ ...DEFAULT_OPTIONS, ...options });\n\n            // Bug #191: Safari doesn't throw an error if the options aren't clonable.\n            testAudioWorkletNodeOptionsClonability(mergedOptions);\n\n            const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n            const processorConstructor = nodeNameToProcessorConstructorMap?.get(name);\n            // Bug #186: Chrome and Edge do not allow to create an AudioWorkletNode on a closed AudioContext.\n            const nativeContextOrBackupOfflineAudioContext =\n                isOffline || nativeContext.state !== 'closed'\n                    ? nativeContext\n                    : getBackupOfflineAudioContext(<TNativeAudioContext>nativeContext) ?? nativeContext;\n            const nativeAudioWorkletNode = createNativeAudioWorkletNode(\n                nativeContextOrBackupOfflineAudioContext,\n                isOffline ? null : (<IMinimalAudioContext>(<any>context)).baseLatency,\n                nativeAudioWorkletNodeConstructor,\n                name,\n                processorConstructor,\n                mergedOptions\n            );\n            const audioWorkletNodeRenderer = <TAudioNodeRenderer<T, this>>(\n                (isOffline ? createAudioWorkletNodeRenderer(name, mergedOptions, processorConstructor) : null)\n            );\n\n            /*\n             * @todo Add a mechanism to switch an AudioWorkletNode to passive once the process() function of the AudioWorkletProcessor\n             * returns false.\n             */\n            super(context, true, nativeAudioWorkletNode, audioWorkletNodeRenderer);\n\n            const parameters: [string, IAudioParam][] = [];\n\n            nativeAudioWorkletNode.parameters.forEach((nativeAudioParam, nm) => {\n                const audioParam = createAudioParam(this, isOffline, nativeAudioParam);\n\n                parameters.push([nm, audioParam]);\n            });\n\n            this._nativeAudioWorkletNode = nativeAudioWorkletNode;\n            this._onprocessorerror = null;\n            this._parameters = new ReadOnlyMap(parameters);\n\n            /*\n             * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to\n             * the destination.\n             */\n            if (isOffline) {\n                addUnrenderedAudioWorkletNode(nativeContext, <IAudioWorkletNode<IMinimalOfflineAudioContext | IOfflineAudioContext>>this);\n            }\n\n            const { activeInputs } = getAudioNodeConnections(this);\n\n            setActiveAudioWorkletNodeInputs(nativeAudioWorkletNode, activeInputs);\n        }\n\n        get onprocessorerror(): null | TErrorEventHandler<this> {\n            return this._onprocessorerror;\n        }\n\n        set onprocessorerror(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, <EventListenerOrEventListenerObject>value) : null;\n\n            this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;\n\n            const nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;\n\n            this._onprocessorerror =\n                nativeOnProcessorError !== null && nativeOnProcessorError === wrappedListener\n                    ? value\n                    : <null | TErrorEventHandler<this>>nativeOnProcessorError;\n        }\n\n        get parameters(): TAudioParamMap {\n            if (this._parameters === null) {\n                // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                return <IReadOnlyMap<string, TNativeAudioParam>>this._nativeAudioWorkletNode.parameters;\n            }\n\n            return this._parameters;\n        }\n\n        get port(): MessagePort {\n            return this._nativeAudioWorkletNode.port;\n        }\n    };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}