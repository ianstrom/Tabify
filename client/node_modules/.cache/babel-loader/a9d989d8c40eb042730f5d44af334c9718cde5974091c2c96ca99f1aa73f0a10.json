{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { FrequencyClass } from \"../core/type/Frequency\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { Instrument } from \"../instrument/Instrument\";\nimport { timeRange } from \"../core/util/Decorator\";\n/**\n * Abstract base class for other monophonic instruments to extend.\n */\nexport class Monophonic extends Instrument {\n  constructor() {\n    super(optionsFromArguments(Monophonic.getDefaults(), arguments));\n    const options = optionsFromArguments(Monophonic.getDefaults(), arguments);\n    this.portamento = options.portamento;\n    this.onsilence = options.onsilence;\n  }\n  static getDefaults() {\n    return Object.assign(Instrument.getDefaults(), {\n      detune: 0,\n      onsilence: noOp,\n      portamento: 0\n    });\n  }\n  /**\n   * Trigger the attack of the note optionally with a given velocity.\n   * @param  note The note to trigger.\n   * @param  time When the note should start.\n   * @param  velocity The velocity scaler determines how \"loud\" the note will be triggered.\n   * @example\n   * const synth = new Tone.Synth().toDestination();\n   * // trigger the note a half second from now at half velocity\n   * synth.triggerAttack(\"C4\", \"+0.5\", 0.5);\n   */\n  triggerAttack(note, time) {\n    let velocity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    this.log(\"triggerAttack\", note, time, velocity);\n    const seconds = this.toSeconds(time);\n    this._triggerEnvelopeAttack(seconds, velocity);\n    this.setNote(note, seconds);\n    return this;\n  }\n  /**\n   * Trigger the release portion of the envelope\n   * @param  time If no time is given, the release happens immediatly\n   * @example\n   * const synth = new Tone.Synth().toDestination();\n   * synth.triggerAttack(\"C4\");\n   * // trigger the release a second from now\n   * synth.triggerRelease(\"+1\");\n   */\n  triggerRelease(time) {\n    this.log(\"triggerRelease\", time);\n    const seconds = this.toSeconds(time);\n    this._triggerEnvelopeRelease(seconds);\n    return this;\n  }\n  /**\n   * Set the note at the given time. If no time is given, the note\n   * will set immediately.\n   * @param note The note to change to.\n   * @param  time The time when the note should be set.\n   * @example\n   * const synth = new Tone.Synth().toDestination();\n   * synth.triggerAttack(\"C4\");\n   * // change to F#6 in one quarter note from now.\n   * synth.setNote(\"F#6\", \"+4n\");\n   */\n  setNote(note, time) {\n    const computedTime = this.toSeconds(time);\n    const computedFrequency = note instanceof FrequencyClass ? note.toFrequency() : note;\n    if (this.portamento > 0 && this.getLevelAtTime(computedTime) > 0.05) {\n      const portTime = this.toSeconds(this.portamento);\n      this.frequency.exponentialRampTo(computedFrequency, portTime, computedTime);\n    } else {\n      this.frequency.setValueAtTime(computedFrequency, computedTime);\n    }\n    return this;\n  }\n}\n__decorate([timeRange(0)], Monophonic.prototype, \"portamento\", void 0);","map":{"version":3,"names":["FrequencyClass","optionsFromArguments","noOp","Instrument","timeRange","Monophonic","constructor","getDefaults","arguments","options","portamento","onsilence","Object","assign","detune","triggerAttack","note","time","velocity","length","undefined","log","seconds","toSeconds","_triggerEnvelopeAttack","setNote","triggerRelease","_triggerEnvelopeRelease","computedTime","computedFrequency","toFrequency","getLevelAtTime","portTime","frequency","exponentialRampTo","setValueAtTime","__decorate"],"sources":["/Users/ianstrom/Development/code/Capstone/node_modules/tone/Tone/instrument/Monophonic.ts"],"sourcesContent":["import { FrequencyClass } from \"../core/type/Frequency\";\nimport { Cents, Frequency, NormalRange, Seconds, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { Instrument, InstrumentOptions } from \"../instrument/Instrument\";\nimport { Signal } from \"../signal/Signal\";\nimport { timeRange } from \"../core/util/Decorator\";\n\ntype onSilenceCallback = (instrument: Monophonic<any>) => void;\n\nexport interface MonophonicOptions extends InstrumentOptions {\n\tportamento: Seconds;\n\tonsilence: onSilenceCallback;\n\tdetune: Cents;\n}\n\n/**\n * Abstract base class for other monophonic instruments to extend.\n */\nexport abstract class Monophonic<Options extends MonophonicOptions> extends Instrument<Options> {\n\n\t/**\n\t * The glide time between notes.\n\t */\n\t@timeRange(0)\n\tportamento: Seconds;\n\n\t/**\n\t * Invoked when the release has finished and the output is silent.\n\t */\n\tonsilence: onSilenceCallback;\n\n\t/**\n\t * The instrument's frequency signal.\n\t */\n\tabstract readonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The instrument's detune control signal.\n\t */\n\tabstract readonly detune: Signal<\"cents\">;\n\n\tconstructor(options?: Partial<MonophonicOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Monophonic.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Monophonic.getDefaults(), arguments);\n\n\t\tthis.portamento = options.portamento;\n\t\tthis.onsilence = options.onsilence;\n\t}\n\n\tstatic getDefaults(): MonophonicOptions {\n\t\treturn Object.assign(Instrument.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tonsilence: noOp,\n\t\t\tportamento: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Trigger the attack of the note optionally with a given velocity.\n\t * @param  note The note to trigger.\n\t * @param  time When the note should start.\n\t * @param  velocity The velocity scaler determines how \"loud\" the note will be triggered.\n\t * @example\n\t * const synth = new Tone.Synth().toDestination();\n\t * // trigger the note a half second from now at half velocity\n\t * synth.triggerAttack(\"C4\", \"+0.5\", 0.5);\n\t */\n\ttriggerAttack(note: Frequency | FrequencyClass, time?: Time, velocity: NormalRange = 1): this {\n\t\tthis.log(\"triggerAttack\", note, time, velocity);\n\t\tconst seconds = this.toSeconds(time);\n\t\tthis._triggerEnvelopeAttack(seconds, velocity);\n\t\tthis.setNote(note, seconds);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the release portion of the envelope\n\t * @param  time If no time is given, the release happens immediatly\n\t * @example\n\t * const synth = new Tone.Synth().toDestination();\n\t * synth.triggerAttack(\"C4\");\n\t * // trigger the release a second from now\n\t * synth.triggerRelease(\"+1\");\n\t */\n\ttriggerRelease(time?: Time): this {\n\t\tthis.log(\"triggerRelease\", time);\n\t\tconst seconds = this.toSeconds(time);\n\t\tthis._triggerEnvelopeRelease(seconds);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Internal method which starts the envelope attack\n\t */\n\tprotected abstract _triggerEnvelopeAttack(time: Seconds, velocity: NormalRange): void;\n\n\t/**\n\t * Internal method which starts the envelope release\n\t */\n\tprotected abstract _triggerEnvelopeRelease(time: Seconds): void;\n\n\t/**\n\t * Get the level of the output at the given time. Measures\n\t * the envelope(s) value at the time.\n\t * @param time The time to query the envelope value\n\t * @return The output level between 0-1\n\t */\n\tabstract getLevelAtTime(time: Time): NormalRange;\n\n\t/**\n\t * Set the note at the given time. If no time is given, the note\n\t * will set immediately.\n\t * @param note The note to change to.\n\t * @param  time The time when the note should be set.\n\t * @example\n\t * const synth = new Tone.Synth().toDestination();\n\t * synth.triggerAttack(\"C4\");\n\t * // change to F#6 in one quarter note from now.\n\t * synth.setNote(\"F#6\", \"+4n\");\n\t */\n\tsetNote(note: Frequency | FrequencyClass, time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst computedFrequency = note instanceof FrequencyClass ? note.toFrequency() : note;\n\t\tif (this.portamento > 0 && this.getLevelAtTime(computedTime) > 0.05) {\n\t\t\tconst portTime = this.toSeconds(this.portamento);\n\t\t\tthis.frequency.exponentialRampTo(computedFrequency, portTime, computedTime);\n\t\t} else {\n\t\t\tthis.frequency.setValueAtTime(computedFrequency, computedTime);\n\t\t}\n\t\treturn this;\n\t}\n}\n"],"mappings":";AAAA,SAASA,cAAc,QAAQ,wBAAwB;AAEvD,SAASC,oBAAoB,QAAQ,uBAAuB;AAC5D,SAASC,IAAI,QAAQ,wBAAwB;AAC7C,SAASC,UAAU,QAA2B,0BAA0B;AAExE,SAASC,SAAS,QAAQ,wBAAwB;AAUlD;;;AAGA,OAAM,MAAgBC,UAA8C,SAAQF,UAAmB;EAwB9FG,YAAA;IAEC,KAAK,CAACL,oBAAoB,CAACI,UAAU,CAACE,WAAW,EAAE,EAAEC,SAAS,CAAC,CAAC;IAChE,MAAMC,OAAO,GAAGR,oBAAoB,CAACI,UAAU,CAACE,WAAW,EAAE,EAAEC,SAAS,CAAC;IAEzE,IAAI,CAACE,UAAU,GAAGD,OAAO,CAACC,UAAU;IACpC,IAAI,CAACC,SAAS,GAAGF,OAAO,CAACE,SAAS;EACnC;EAEA,OAAOJ,WAAWA,CAAA;IACjB,OAAOK,MAAM,CAACC,MAAM,CAACV,UAAU,CAACI,WAAW,EAAE,EAAE;MAC9CO,MAAM,EAAE,CAAC;MACTH,SAAS,EAAET,IAAI;MACfQ,UAAU,EAAE;KACZ,CAAC;EACH;EAEA;;;;;;;;;;EAUAK,aAAaA,CAACC,IAAgC,EAAEC,IAAW,EAA2B;IAAA,IAAzBC,QAAA,GAAAV,SAAA,CAAAW,MAAA,QAAAX,SAAA,QAAAY,SAAA,GAAAZ,SAAA,MAAwB,CAAC;IACrF,IAAI,CAACa,GAAG,CAAC,eAAe,EAAEL,IAAI,EAAEC,IAAI,EAAEC,QAAQ,CAAC;IAC/C,MAAMI,OAAO,GAAG,IAAI,CAACC,SAAS,CAACN,IAAI,CAAC;IACpC,IAAI,CAACO,sBAAsB,CAACF,OAAO,EAAEJ,QAAQ,CAAC;IAC9C,IAAI,CAACO,OAAO,CAACT,IAAI,EAAEM,OAAO,CAAC;IAC3B,OAAO,IAAI;EACZ;EAEA;;;;;;;;;EASAI,cAAcA,CAACT,IAAW;IACzB,IAAI,CAACI,GAAG,CAAC,gBAAgB,EAAEJ,IAAI,CAAC;IAChC,MAAMK,OAAO,GAAG,IAAI,CAACC,SAAS,CAACN,IAAI,CAAC;IACpC,IAAI,CAACU,uBAAuB,CAACL,OAAO,CAAC;IACrC,OAAO,IAAI;EACZ;EAoBA;;;;;;;;;;;EAWAG,OAAOA,CAACT,IAAgC,EAAEC,IAAW;IACpD,MAAMW,YAAY,GAAG,IAAI,CAACL,SAAS,CAACN,IAAI,CAAC;IACzC,MAAMY,iBAAiB,GAAGb,IAAI,YAAYhB,cAAc,GAAGgB,IAAI,CAACc,WAAW,EAAE,GAAGd,IAAI;IACpF,IAAI,IAAI,CAACN,UAAU,GAAG,CAAC,IAAI,IAAI,CAACqB,cAAc,CAACH,YAAY,CAAC,GAAG,IAAI,EAAE;MACpE,MAAMI,QAAQ,GAAG,IAAI,CAACT,SAAS,CAAC,IAAI,CAACb,UAAU,CAAC;MAChD,IAAI,CAACuB,SAAS,CAACC,iBAAiB,CAACL,iBAAiB,EAAEG,QAAQ,EAAEJ,YAAY,CAAC;KAC3E,MAAM;MACN,IAAI,CAACK,SAAS,CAACE,cAAc,CAACN,iBAAiB,EAAED,YAAY,CAAC;;IAE/D,OAAO,IAAI;EACZ;;AA5GAQ,UAAA,EADChC,SAAS,CAAC,CAAC,CAAC,C,6CACO"},"metadata":{},"sourceType":"module","externalDependencies":[]}