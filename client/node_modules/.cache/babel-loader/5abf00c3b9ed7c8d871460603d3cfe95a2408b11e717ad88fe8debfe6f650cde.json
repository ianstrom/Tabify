{"ast":null,"code":"import { deactivateAudioGraph } from '../helpers/deactivate-audio-graph';\nimport { testPromiseSupport } from '../helpers/test-promise-support';\nconst DEFAULT_OPTIONS = {\n  numberOfChannels: 1\n};\nexport const createMinimalOfflineAudioContextConstructor = (cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, minimalBaseAudioContextConstructor, startRendering) => {\n  return class MinimalOfflineAudioContext extends minimalBaseAudioContextConstructor {\n    constructor(options) {\n      const {\n        length,\n        numberOfChannels,\n        sampleRate\n      } = {\n        ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate);\n      // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n      if (!cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n        nativeOfflineAudioContext.addEventListener('statechange', (() => {\n          let i = 0;\n          const delayStateChangeEvent = event => {\n            if (this._state === 'running') {\n              if (i > 0) {\n                nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                event.stopImmediatePropagation();\n                this._waitForThePromiseToSettle(event);\n              } else {\n                i += 1;\n              }\n            }\n          };\n          return delayStateChangeEvent;\n        })());\n      }\n      super(nativeOfflineAudioContext, numberOfChannels);\n      this._length = length;\n      this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n      this._state = null;\n    }\n    get length() {\n      // Bug #17: Safari does not yet expose the length.\n      if (this._nativeOfflineAudioContext.length === undefined) {\n        return this._length;\n      }\n      return this._nativeOfflineAudioContext.length;\n    }\n    get state() {\n      return this._state === null ? this._nativeOfflineAudioContext.state : this._state;\n    }\n    startRendering() {\n      /*\n       * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n       * the state of the nativeOfflineAudioContext might no transition to running immediately.\n       */\n      if (this._state === 'running') {\n        return Promise.reject(createInvalidStateError());\n      }\n      this._state = 'running';\n      return startRendering(this.destination, this._nativeOfflineAudioContext).finally(() => {\n        this._state = null;\n        deactivateAudioGraph(this);\n      });\n    }\n    _waitForThePromiseToSettle(event) {\n      if (this._state === null) {\n        this._nativeOfflineAudioContext.dispatchEvent(event);\n      } else {\n        setTimeout(() => this._waitForThePromiseToSettle(event));\n      }\n    }\n  };\n};","map":{"version":3,"names":["deactivateAudioGraph","testPromiseSupport","DEFAULT_OPTIONS","numberOfChannels","createMinimalOfflineAudioContextConstructor","cacheTestResult","createInvalidStateError","createNativeOfflineAudioContext","minimalBaseAudioContextConstructor","startRendering","MinimalOfflineAudioContext","constructor","options","length","sampleRate","nativeOfflineAudioContext","addEventListener","i","delayStateChangeEvent","event","_state","removeEventListener","stopImmediatePropagation","_waitForThePromiseToSettle","_length","_nativeOfflineAudioContext","undefined","state","Promise","reject","destination","finally","dispatchEvent","setTimeout"],"sources":["/Users/ianstrom/Development/code/Capstone/client/node_modules/standardized-audio-context/src/factories/minimal-offline-audio-context-constructor.ts"],"sourcesContent":["import { deactivateAudioGraph } from '../helpers/deactivate-audio-graph';\nimport { testPromiseSupport } from '../helpers/test-promise-support';\nimport { IAudioBuffer, IMinimalOfflineAudioContext, IOfflineAudioContextOptions } from '../interfaces';\nimport { TAudioContextState, TMinimalOfflineAudioContextConstructorFactory, TNativeOfflineAudioContext } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n} as const;\n\nexport const createMinimalOfflineAudioContextConstructor: TMinimalOfflineAudioContextConstructorFactory = (\n    cacheTestResult,\n    createInvalidStateError,\n    createNativeOfflineAudioContext,\n    minimalBaseAudioContextConstructor,\n    startRendering\n) => {\n    return class MinimalOfflineAudioContext extends minimalBaseAudioContextConstructor<IMinimalOfflineAudioContext>\n        implements IMinimalOfflineAudioContext {\n        private _length: number;\n\n        private _nativeOfflineAudioContext: TNativeOfflineAudioContext;\n\n        private _state: null | TAudioContextState;\n\n        constructor(options: IOfflineAudioContextOptions) {\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n\n            const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate);\n\n            // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n            if (!cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n                nativeOfflineAudioContext.addEventListener(\n                    'statechange',\n                    (() => {\n                        let i = 0;\n\n                        const delayStateChangeEvent = (event: Event) => {\n                            if (this._state === 'running') {\n                                if (i > 0) {\n                                    nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                                    event.stopImmediatePropagation();\n\n                                    this._waitForThePromiseToSettle(event);\n                                } else {\n                                    i += 1;\n                                }\n                            }\n                        };\n\n                        return delayStateChangeEvent;\n                    })()\n                );\n            }\n\n            super(nativeOfflineAudioContext, numberOfChannels);\n\n            this._length = length;\n            this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n            this._state = null;\n        }\n\n        get length(): number {\n            // Bug #17: Safari does not yet expose the length.\n            if (this._nativeOfflineAudioContext.length === undefined) {\n                return this._length;\n            }\n\n            return this._nativeOfflineAudioContext.length;\n        }\n\n        get state(): TAudioContextState {\n            return this._state === null ? this._nativeOfflineAudioContext.state : this._state;\n        }\n\n        public startRendering(): Promise<IAudioBuffer> {\n            /*\n             * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n             * the state of the nativeOfflineAudioContext might no transition to running immediately.\n             */\n            if (this._state === 'running') {\n                return Promise.reject(createInvalidStateError());\n            }\n\n            this._state = 'running';\n\n            return startRendering(this.destination, this._nativeOfflineAudioContext).finally(() => {\n                this._state = null;\n\n                deactivateAudioGraph(this);\n            });\n        }\n\n        private _waitForThePromiseToSettle(event: Event): void {\n            if (this._state === null) {\n                this._nativeOfflineAudioContext.dispatchEvent(event);\n            } else {\n                setTimeout(() => this._waitForThePromiseToSettle(event));\n            }\n        }\n    };\n};\n"],"mappings":"AAAA,SAASA,oBAAoB,QAAQ,mCAAmC;AACxE,SAASC,kBAAkB,QAAQ,iCAAiC;AAIpE,MAAMC,eAAe,GAAG;EACpBC,gBAAgB,EAAE;CACZ;AAEV,OAAO,MAAMC,2CAA2C,GAAkDA,CACtGC,eAAe,EACfC,uBAAuB,EACvBC,+BAA+B,EAC/BC,kCAAkC,EAClCC,cAAc,KACd;EACA,OAAO,MAAMC,0BAA2B,SAAQF,kCAA+D;IAQ3GG,YAAYC,OAAoC;MAC5C,MAAM;QAAEC,MAAM;QAAEV,gBAAgB;QAAEW;MAAU,CAAE,GAAG;QAAE,GAAGZ,eAAe;QAAE,GAAGU;MAAO,CAAE;MAEnF,MAAMG,yBAAyB,GAAGR,+BAA+B,CAACJ,gBAAgB,EAAEU,MAAM,EAAEC,UAAU,CAAC;MAEvG;MACA,IAAI,CAACT,eAAe,CAACJ,kBAAkB,EAAE,MAAMA,kBAAkB,CAACc,yBAAyB,CAAC,CAAC,EAAE;QAC3FA,yBAAyB,CAACC,gBAAgB,CACtC,aAAa,EACb,CAAC,MAAK;UACF,IAAIC,CAAC,GAAG,CAAC;UAET,MAAMC,qBAAqB,GAAIC,KAAY,IAAI;YAC3C,IAAI,IAAI,CAACC,MAAM,KAAK,SAAS,EAAE;cAC3B,IAAIH,CAAC,GAAG,CAAC,EAAE;gBACPF,yBAAyB,CAACM,mBAAmB,CAAC,aAAa,EAAEH,qBAAqB,CAAC;gBACnFC,KAAK,CAACG,wBAAwB,EAAE;gBAEhC,IAAI,CAACC,0BAA0B,CAACJ,KAAK,CAAC;eACzC,MAAM;gBACHF,CAAC,IAAI,CAAC;;;UAGlB,CAAC;UAED,OAAOC,qBAAqB;QAChC,CAAC,GAAG,CACP;;MAGL,KAAK,CAACH,yBAAyB,EAAEZ,gBAAgB,CAAC;MAElD,IAAI,CAACqB,OAAO,GAAGX,MAAM;MACrB,IAAI,CAACY,0BAA0B,GAAGV,yBAAyB;MAC3D,IAAI,CAACK,MAAM,GAAG,IAAI;IACtB;IAEA,IAAIP,MAAMA,CAAA;MACN;MACA,IAAI,IAAI,CAACY,0BAA0B,CAACZ,MAAM,KAAKa,SAAS,EAAE;QACtD,OAAO,IAAI,CAACF,OAAO;;MAGvB,OAAO,IAAI,CAACC,0BAA0B,CAACZ,MAAM;IACjD;IAEA,IAAIc,KAAKA,CAAA;MACL,OAAO,IAAI,CAACP,MAAM,KAAK,IAAI,GAAG,IAAI,CAACK,0BAA0B,CAACE,KAAK,GAAG,IAAI,CAACP,MAAM;IACrF;IAEOX,cAAcA,CAAA;MACjB;;;;MAIA,IAAI,IAAI,CAACW,MAAM,KAAK,SAAS,EAAE;QAC3B,OAAOQ,OAAO,CAACC,MAAM,CAACvB,uBAAuB,EAAE,CAAC;;MAGpD,IAAI,CAACc,MAAM,GAAG,SAAS;MAEvB,OAAOX,cAAc,CAAC,IAAI,CAACqB,WAAW,EAAE,IAAI,CAACL,0BAA0B,CAAC,CAACM,OAAO,CAAC,MAAK;QAClF,IAAI,CAACX,MAAM,GAAG,IAAI;QAElBpB,oBAAoB,CAAC,IAAI,CAAC;MAC9B,CAAC,CAAC;IACN;IAEQuB,0BAA0BA,CAACJ,KAAY;MAC3C,IAAI,IAAI,CAACC,MAAM,KAAK,IAAI,EAAE;QACtB,IAAI,CAACK,0BAA0B,CAACO,aAAa,CAACb,KAAK,CAAC;OACvD,MAAM;QACHc,UAAU,CAAC,MAAM,IAAI,CAACV,0BAA0B,CAACJ,KAAK,CAAC,CAAC;;IAEhE;GACH;AACL,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}