{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp, readOnly } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform } from \"./OscillatorInterface\";\nimport { assertRange } from \"../../core/util/Debug\";\n/**\n * FatOscillator is an array of oscillators with detune spread between the oscillators\n * @example\n * const fatOsc = new Tone.FatOscillator(\"Ab3\", \"sawtooth\", 40).toDestination().start();\n * @category Source\n */\nexport class FatOscillator extends Source {\n  constructor() {\n    super(optionsFromArguments(FatOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"spread\"]));\n    this.name = \"FatOscillator\";\n    /**\n     * The array of oscillators\n     */\n    this._oscillators = [];\n    const options = optionsFromArguments(FatOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"spread\"]);\n    this.frequency = new Signal({\n      context: this.context,\n      units: \"frequency\",\n      value: options.frequency\n    });\n    this.detune = new Signal({\n      context: this.context,\n      units: \"cents\",\n      value: options.detune\n    });\n    this._spread = options.spread;\n    this._type = options.type;\n    this._phase = options.phase;\n    this._partials = options.partials;\n    this._partialCount = options.partialCount;\n    // set the count initially\n    this.count = options.count;\n    readOnly(this, [\"frequency\", \"detune\"]);\n  }\n  static getDefaults() {\n    return Object.assign(Oscillator.getDefaults(), {\n      count: 3,\n      spread: 20,\n      type: \"sawtooth\"\n    });\n  }\n  /**\n   * start the oscillator\n   */\n  _start(time) {\n    time = this.toSeconds(time);\n    this._forEach(osc => osc.start(time));\n  }\n  /**\n   * stop the oscillator\n   */\n  _stop(time) {\n    time = this.toSeconds(time);\n    this._forEach(osc => osc.stop(time));\n  }\n  _restart(time) {\n    this._forEach(osc => osc.restart(time));\n  }\n  /**\n   * Iterate over all of the oscillators\n   */\n  _forEach(iterator) {\n    for (let i = 0; i < this._oscillators.length; i++) {\n      iterator(this._oscillators[i], i);\n    }\n  }\n  /**\n   * The type of the oscillator\n   */\n  get type() {\n    return this._type;\n  }\n  set type(type) {\n    this._type = type;\n    this._forEach(osc => osc.type = type);\n  }\n  /**\n   * The detune spread between the oscillators. If \"count\" is\n   * set to 3 oscillators and the \"spread\" is set to 40,\n   * the three oscillators would be detuned like this: [-20, 0, 20]\n   * for a total detune spread of 40 cents.\n   * @example\n   * const fatOsc = new Tone.FatOscillator().toDestination().start();\n   * fatOsc.spread = 70;\n   */\n  get spread() {\n    return this._spread;\n  }\n  set spread(spread) {\n    this._spread = spread;\n    if (this._oscillators.length > 1) {\n      const start = -spread / 2;\n      const step = spread / (this._oscillators.length - 1);\n      this._forEach((osc, i) => osc.detune.value = start + step * i);\n    }\n  }\n  /**\n   * The number of detuned oscillators. Must be an integer greater than 1.\n   * @example\n   * const fatOsc = new Tone.FatOscillator(\"C#3\", \"sawtooth\").toDestination().start();\n   * // use 4 sawtooth oscillators\n   * fatOsc.count = 4;\n   */\n  get count() {\n    return this._oscillators.length;\n  }\n  set count(count) {\n    assertRange(count, 1);\n    if (this._oscillators.length !== count) {\n      // dispose the previous oscillators\n      this._forEach(osc => osc.dispose());\n      this._oscillators = [];\n      for (let i = 0; i < count; i++) {\n        const osc = new Oscillator({\n          context: this.context,\n          volume: -6 - count * 1.1,\n          type: this._type,\n          phase: this._phase + i / count * 360,\n          partialCount: this._partialCount,\n          onstop: i === 0 ? () => this.onstop(this) : noOp\n        });\n        if (this.type === \"custom\") {\n          osc.partials = this._partials;\n        }\n        this.frequency.connect(osc.frequency);\n        this.detune.connect(osc.detune);\n        osc.detune.overridden = false;\n        osc.connect(this.output);\n        this._oscillators[i] = osc;\n      }\n      // set the spread\n      this.spread = this._spread;\n      if (this.state === \"started\") {\n        this._forEach(osc => osc.start());\n      }\n    }\n  }\n  get phase() {\n    return this._phase;\n  }\n  set phase(phase) {\n    this._phase = phase;\n    this._forEach((osc, i) => osc.phase = this._phase + i / this.count * 360);\n  }\n  get baseType() {\n    return this._oscillators[0].baseType;\n  }\n  set baseType(baseType) {\n    this._forEach(osc => osc.baseType = baseType);\n    this._type = this._oscillators[0].type;\n  }\n  get partials() {\n    return this._oscillators[0].partials;\n  }\n  set partials(partials) {\n    this._partials = partials;\n    this._partialCount = this._partials.length;\n    if (partials.length) {\n      this._type = \"custom\";\n      this._forEach(osc => osc.partials = partials);\n    }\n  }\n  get partialCount() {\n    return this._oscillators[0].partialCount;\n  }\n  set partialCount(partialCount) {\n    this._partialCount = partialCount;\n    this._forEach(osc => osc.partialCount = partialCount);\n    this._type = this._oscillators[0].type;\n  }\n  asArray() {\n    let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1024;\n    return __awaiter(this, void 0, void 0, function* () {\n      return generateWaveform(this, length);\n    });\n  }\n  /**\n   * Clean up.\n   */\n  dispose() {\n    super.dispose();\n    this.frequency.dispose();\n    this.detune.dispose();\n    this._forEach(osc => osc.dispose());\n    return this;\n  }\n}","map":{"version":3,"names":["optionsFromArguments","noOp","readOnly","Signal","Source","Oscillator","generateWaveform","assertRange","FatOscillator","constructor","getDefaults","arguments","name","_oscillators","options","frequency","context","units","value","detune","_spread","spread","_type","type","_phase","phase","_partials","partials","_partialCount","partialCount","count","Object","assign","_start","time","toSeconds","_forEach","osc","start","_stop","stop","_restart","restart","iterator","i","length","step","dispose","volume","onstop","connect","overridden","output","state","baseType","asArray","undefined"],"sources":["/Users/ianstrom/Development/code/Capstone/client/node_modules/tone/Tone/source/oscillator/FatOscillator.ts"],"sourcesContent":["import { Cents, Degrees, Frequency, Seconds, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp, readOnly } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport {\n\tFatConstructorOptions, FatOscillatorOptions,\n\tgenerateWaveform, NonCustomOscillatorType, ToneOscillatorInterface, ToneOscillatorType\n} from \"./OscillatorInterface\";\nimport { assertRange } from \"../../core/util/Debug\";\n\nexport { FatOscillatorOptions } from \"./OscillatorInterface\";\n\n/**\n * FatOscillator is an array of oscillators with detune spread between the oscillators\n * @example\n * const fatOsc = new Tone.FatOscillator(\"Ab3\", \"sawtooth\", 40).toDestination().start();\n * @category Source\n */\nexport class FatOscillator extends Source<FatOscillatorOptions> implements ToneOscillatorInterface {\n\n\treadonly name: string = \"FatOscillator\";\n\n\treadonly frequency: Signal<\"frequency\">;\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The array of oscillators\n\t */\n\tprivate _oscillators: Oscillator[] = [];\n\n\t/**\n\t * The total spread of the oscillators\n\t */\n\tprivate _spread: Cents;\n\n\t/**\n\t * The type of the oscillator\n\t */\n\tprivate _type: ToneOscillatorType;\n\n\t/**\n\t * The phase of the oscillators\n\t */\n\tprivate _phase: Degrees;\n\n\t/**\n\t * The partials array\n\t */\n\tprivate _partials: number[];\n\n\t/**\n\t * The number of partials to use\n\t */\n\tprivate _partialCount: number;\n\n\t/**\n\t * @param frequency The oscillator's frequency.\n\t * @param type The type of the oscillator.\n\t * @param spread The detune spread between the oscillators.\n\t */\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType, spread?: Cents);\n\tconstructor(options?: Partial<FatConstructorOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(FatOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"spread\"]));\n\t\tconst options = optionsFromArguments(FatOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"spread\"]);\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\n\t\tthis._spread = options.spread;\n\t\tthis._type = options.type;\n\t\tthis._phase = options.phase;\n\t\tthis._partials = options.partials;\n\t\tthis._partialCount = options.partialCount;\n\n\t\t// set the count initially\n\t\tthis.count = options.count;\n\n\t\treadOnly(this, [\"frequency\", \"detune\"]);\n\t}\n\n\tstatic getDefaults(): FatOscillatorOptions {\n\t\treturn Object.assign(Oscillator.getDefaults(), {\n\t\t\tcount: 3,\n\t\t\tspread: 20,\n\t\t\ttype: \"sawtooth\",\n\t\t});\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._forEach(osc => osc.start(time));\n\t}\n\n\t/**\n\t * stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._forEach(osc => osc.stop(time));\n\t}\n\n\tprotected _restart(time: Seconds): void {\n\t\tthis._forEach(osc => osc.restart(time));\n\t}\n\n\t/**\n\t * Iterate over all of the oscillators\n\t */\n\tprivate _forEach(iterator: (osc: Oscillator, index: number) => void): void {\n\t\tfor (let i = 0; i < this._oscillators.length; i++) {\n\t\t\titerator(this._oscillators[i], i);\n\t\t}\n\t}\n\n\t/**\n\t * The type of the oscillator\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._type;\n\t}\n\tset type(type: ToneOscillatorType) {\n\t\tthis._type = type;\n\t\tthis._forEach(osc => osc.type = type);\n\t}\n\n\t/**\n\t * The detune spread between the oscillators. If \"count\" is\n\t * set to 3 oscillators and the \"spread\" is set to 40,\n\t * the three oscillators would be detuned like this: [-20, 0, 20]\n\t * for a total detune spread of 40 cents.\n\t * @example\n\t * const fatOsc = new Tone.FatOscillator().toDestination().start();\n\t * fatOsc.spread = 70;\n\t */\n\tget spread(): Cents {\n\t\treturn this._spread;\n\t}\n\tset spread(spread: Cents) {\n\t\tthis._spread = spread;\n\t\tif (this._oscillators.length > 1) {\n\t\t\tconst start = -spread / 2;\n\t\t\tconst step = spread / (this._oscillators.length - 1);\n\t\t\tthis._forEach((osc, i) => osc.detune.value = start + step * i);\n\t\t}\n\t}\n\n\t/**\n\t * The number of detuned oscillators. Must be an integer greater than 1.\n\t * @example\n\t * const fatOsc = new Tone.FatOscillator(\"C#3\", \"sawtooth\").toDestination().start();\n\t * // use 4 sawtooth oscillators\n\t * fatOsc.count = 4;\n\t */\n\tget count(): number {\n\t\treturn this._oscillators.length;\n\t}\n\tset count(count: number) {\n\t\tassertRange(count, 1);\n\t\tif (this._oscillators.length !== count) {\n\t\t\t// dispose the previous oscillators\n\t\t\tthis._forEach(osc => osc.dispose());\n\t\t\tthis._oscillators = [];\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tconst osc = new Oscillator({\n\t\t\t\t\tcontext: this.context,\n\t\t\t\t\tvolume: -6 - count * 1.1,\n\t\t\t\t\ttype: this._type as NonCustomOscillatorType,\n\t\t\t\t\tphase: this._phase + (i / count) * 360,\n\t\t\t\t\tpartialCount: this._partialCount,\n\t\t\t\t\tonstop: i === 0 ? () => this.onstop(this) : noOp,\n\t\t\t\t});\n\t\t\t\tif (this.type === \"custom\") {\n\t\t\t\t\tosc.partials = this._partials;\n\t\t\t\t}\n\t\t\t\tthis.frequency.connect(osc.frequency);\n\t\t\t\tthis.detune.connect(osc.detune);\n\t\t\t\tosc.detune.overridden = false;\n\t\t\t\tosc.connect(this.output);\n\t\t\t\tthis._oscillators[i] = osc;\n\t\t\t}\n\t\t\t// set the spread\n\t\t\tthis.spread = this._spread;\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tthis._forEach(osc => osc.start());\n\t\t\t}\n\t\t}\n\t}\n\n\tget phase(): Degrees {\n\t\treturn this._phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._phase = phase;\n\t\tthis._forEach((osc, i) => osc.phase = this._phase + (i / this.count) * 360);\n\t}\n\n\tget baseType(): OscillatorType {\n\t\treturn this._oscillators[0].baseType;\n\t}\n\tset baseType(baseType: OscillatorType) {\n\t\tthis._forEach(osc => osc.baseType = baseType);\n\t\tthis._type = this._oscillators[0].type;\n\t}\n\n\tget partials(): number[] {\n\t\treturn this._oscillators[0].partials;\n\t}\n\tset partials(partials: number[]) {\n\t\tthis._partials = partials;\n\t\tthis._partialCount = this._partials.length;\n\t\tif (partials.length) {\n\t\t\tthis._type = \"custom\";\n\t\t\tthis._forEach(osc => osc.partials = partials);\n\t\t}\n\t}\n\n\tget partialCount(): number {\n\t\treturn this._oscillators[0].partialCount;\n\t}\n\tset partialCount(partialCount: number) {\n\t\tthis._partialCount = partialCount;\n\t\tthis._forEach(osc => osc.partialCount = partialCount);\n\t\tthis._type = this._oscillators[0].type;\n\t}\n\n\tasync asArray(length = 1024): Promise<Float32Array> {\n\t\treturn generateWaveform(this, length);\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\tthis._forEach(osc => osc.dispose());\n\t\treturn this;\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}