{"ast":null,"code":"import { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nconst processBuffer = async (proxy, renderedBuffer, nativeOfflineAudioContext, options, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime) => {\n  // Ceil the length to the next full render quantum.\n  // Bug #17: Safari does not yet expose the length.\n  const length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;\n  const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n  const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n  const processedBuffer = numberOfOutputChannels === 0 ? null : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\n  if (processorConstructor === undefined) {\n    throw new Error('Missing the processor constructor.');\n  }\n  const audioNodeConnections = getAudioNodeConnections(proxy);\n  const audioWorkletProcessor = await getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n  const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n  const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n  const parameters = Array.from(proxy.parameters.keys()).reduce((prmtrs, name) => ({\n    ...prmtrs,\n    [name]: new Float32Array(128)\n  }), {});\n  for (let i = 0; i < length; i += 128) {\n    if (options.numberOfInputs > 0 && renderedBuffer !== null) {\n      for (let j = 0; j < options.numberOfInputs; j += 1) {\n        for (let k = 0; k < options.channelCount; k += 1) {\n          copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n        }\n      }\n    }\n    if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {\n      processorConstructor.parameterDescriptors.forEach((_ref, index) => {\n        let {\n          name\n        } = _ref;\n        copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n      });\n    }\n    for (let j = 0; j < options.numberOfInputs; j += 1) {\n      for (let k = 0; k < outputChannelCount[j]; k += 1) {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (outputs[j][k].byteLength === 0) {\n          outputs[j][k] = new Float32Array(128);\n        }\n      }\n    }\n    try {\n      const potentiallyEmptyInputs = inputs.map((input, index) => {\n        if (audioNodeConnections.activeInputs[index].size === 0) {\n          return [];\n        }\n        return input;\n      });\n      const activeSourceFlag = exposeCurrentFrameAndCurrentTime(i / nativeOfflineAudioContext.sampleRate, nativeOfflineAudioContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n      if (processedBuffer !== null) {\n        for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n          for (let k = 0; k < outputChannelCount[j]; k += 1) {\n            copyToChannel(processedBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n          }\n          outputChannelSplitterNodeOutput += outputChannelCount[j];\n        }\n      }\n      if (!activeSourceFlag) {\n        break;\n      }\n    } catch (error) {\n      proxy.dispatchEvent(new ErrorEvent('processorerror', {\n        colno: error.colno,\n        filename: error.filename,\n        lineno: error.lineno,\n        message: error.message\n      }));\n      break;\n    }\n  }\n  return processedBuffer;\n};\nexport const createAudioWorkletNodeRendererFactory = (connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n  return (name, options, processorConstructor) => {\n    const renderedNativeAudioNodes = new WeakMap();\n    let processedBufferPromise = null;\n    const createAudioNode = async (proxy, nativeOfflineAudioContext) => {\n      let nativeAudioWorkletNode = getNativeAudioNode(proxy);\n      let nativeOutputNodes = null;\n      const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);\n      const outputChannelCount = Array.isArray(options.outputChannelCount) ? options.outputChannelCount : Array.from(options.outputChannelCount);\n      // Bug #61: Only Chrome, Edge & Firefox have an implementation of the AudioWorkletNode yet.\n      if (nativeAudioWorkletNodeConstructor === null) {\n        const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n        const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n          channelCount: Math.max(1, numberOfOutputChannels),\n          channelCountMode: 'explicit',\n          channelInterpretation: 'discrete',\n          numberOfOutputs: Math.max(1, numberOfOutputChannels)\n        });\n        const outputChannelMergerNodes = [];\n        for (let i = 0; i < proxy.numberOfOutputs; i += 1) {\n          outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeOfflineAudioContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'speakers',\n            numberOfInputs: outputChannelCount[i]\n          }));\n        }\n        const outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n          channelCount: options.channelCount,\n          channelCountMode: options.channelCountMode,\n          channelInterpretation: options.channelInterpretation,\n          gain: 1\n        });\n        outputGainNode.connect = connectMultipleOutputs.bind(null, outputChannelMergerNodes);\n        outputGainNode.disconnect = disconnectMultipleOutputs.bind(null, outputChannelMergerNodes);\n        nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n      } else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n        nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n      }\n      renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]);\n      if (nativeOutputNodes !== null) {\n        if (processedBufferPromise === null) {\n          if (processorConstructor === undefined) {\n            throw new Error('Missing the processor constructor.');\n          }\n          if (nativeOfflineAudioContextConstructor === null) {\n            throw new Error('Missing the native OfflineAudioContext constructor.');\n          }\n          // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.\n          const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n          const numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n          const numberOfChannels = numberOfInputChannels + numberOfParameters;\n          const renderBuffer = async () => {\n            const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(numberOfChannels,\n            // Ceil the length to the next full render quantum.\n            // Bug #17: Safari does not yet expose the length.\n            Math.ceil(proxy.context.length / 128) * 128, nativeOfflineAudioContext.sampleRate);\n            const gainNodes = [];\n            const inputChannelSplitterNodes = [];\n            for (let i = 0; i < options.numberOfInputs; i += 1) {\n              gainNodes.push(createNativeGainNode(partialOfflineAudioContext, {\n                channelCount: options.channelCount,\n                channelCountMode: options.channelCountMode,\n                channelInterpretation: options.channelInterpretation,\n                gain: 1\n              }));\n              inputChannelSplitterNodes.push(createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                channelCount: options.channelCount,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                numberOfOutputs: options.channelCount\n              }));\n            }\n            const constantSourceNodes = await Promise.all(Array.from(proxy.parameters.values()).map(async audioParam => {\n              const constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                offset: audioParam.value\n              });\n              await renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset);\n              return constantSourceNode;\n            }));\n            const inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n              channelCount: 1,\n              channelCountMode: 'explicit',\n              channelInterpretation: 'speakers',\n              numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n            });\n            for (let i = 0; i < options.numberOfInputs; i += 1) {\n              gainNodes[i].connect(inputChannelSplitterNodes[i]);\n              for (let j = 0; j < options.channelCount; j += 1) {\n                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n              }\n            }\n            for (const [index, constantSourceNode] of constantSourceNodes.entries()) {\n              constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n              constantSourceNode.start(0);\n            }\n            inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n            await Promise.all(gainNodes.map(gainNode => renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode)));\n            return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n          };\n          processedBufferPromise = processBuffer(proxy, numberOfChannels === 0 ? null : await renderBuffer(), nativeOfflineAudioContext, options, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime);\n        }\n        const processedBuffer = await processedBufferPromise;\n        const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n          buffer: null,\n          channelCount: 2,\n          channelCountMode: 'max',\n          channelInterpretation: 'speakers',\n          loop: false,\n          loopEnd: 0,\n          loopStart: 0,\n          playbackRate: 1\n        });\n        const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;\n        if (processedBuffer !== null) {\n          audioBufferSourceNode.buffer = processedBuffer;\n          audioBufferSourceNode.start(0);\n        }\n        audioBufferSourceNode.connect(outputChannelSplitterNode);\n        for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {\n          const outputChannelMergerNode = outputChannelMergerNodes[i];\n          for (let j = 0; j < outputChannelCount[i]; j += 1) {\n            outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n          }\n          outputChannelSplitterNodeOutput += outputChannelCount[i];\n        }\n        return outputGainNode;\n      }\n      if (!nativeAudioWorkletNodeIsOwnedByContext) {\n        for (const [nm, audioParam] of proxy.parameters.entries()) {\n          await renderAutomation(nativeOfflineAudioContext, audioParam,\n          // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n          nativeAudioWorkletNode.parameters.get(nm));\n        }\n      } else {\n        for (const [nm, audioParam] of proxy.parameters.entries()) {\n          await connectAudioParam(nativeOfflineAudioContext, audioParam,\n          // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n          nativeAudioWorkletNode.parameters.get(nm));\n        }\n      }\n      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode);\n      return nativeAudioWorkletNode;\n    };\n    return {\n      render(proxy, nativeOfflineAudioContext) {\n        deleteUnrenderedAudioWorkletNode(nativeOfflineAudioContext, proxy);\n        const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n        if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {\n          return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n        }\n        return createAudioNode(proxy, nativeOfflineAudioContext);\n      }\n    };\n  };\n};","map":{"version":3,"names":["copyFromChannel","copyToChannel","createNestedArrays","getAudioNodeConnections","getAudioWorkletProcessor","isOwnedByContext","processBuffer","proxy","renderedBuffer","nativeOfflineAudioContext","options","outputChannelCount","processorConstructor","exposeCurrentFrameAndCurrentTime","length","Math","ceil","context","numberOfInputChannels","channelCount","numberOfInputs","numberOfOutputChannels","reduce","sum","value","processedBuffer","createBuffer","sampleRate","undefined","Error","audioNodeConnections","audioWorkletProcessor","inputs","outputs","numberOfOutputs","parameters","Array","from","keys","prmtrs","name","Float32Array","i","j","k","parameterDescriptors","forEach","_ref","index","byteLength","potentiallyEmptyInputs","map","input","activeInputs","size","activeSourceFlag","process","outputChannelSplitterNodeOutput","error","dispatchEvent","ErrorEvent","colno","filename","lineno","message","createAudioWorkletNodeRendererFactory","connectAudioParam","connectMultipleOutputs","createNativeAudioBufferSourceNode","createNativeChannelMergerNode","createNativeChannelSplitterNode","createNativeConstantSourceNode","createNativeGainNode","deleteUnrenderedAudioWorkletNode","disconnectMultipleOutputs","getNativeAudioNode","nativeAudioWorkletNodeConstructor","nativeOfflineAudioContextConstructor","renderAutomation","renderInputsOfAudioNode","renderNativeOfflineAudioContext","renderedNativeAudioNodes","WeakMap","processedBufferPromise","createAudioNode","nativeAudioWorkletNode","nativeOutputNodes","nativeAudioWorkletNodeIsOwnedByContext","isArray","outputChannelSplitterNode","max","channelCountMode","channelInterpretation","outputChannelMergerNodes","push","outputGainNode","gain","connect","bind","disconnect","set","numberOfParameters","numberOfChannels","renderBuffer","partialOfflineAudioContext","gainNodes","inputChannelSplitterNodes","constantSourceNodes","Promise","all","values","audioParam","constantSourceNode","offset","inputChannelMergerNode","entries","start","destination","gainNode","audioBufferSourceNode","buffer","loop","loopEnd","loopStart","playbackRate","outputChannelMergerNode","nm","get","render","renderedNativeAudioWorkletNodeOrGainNode","resolve"],"sources":["/Users/ianstrom/Development/code/Capstone/node_modules/standardized-audio-context/src/factories/audio-worklet-node-renderer-factory.ts"],"sourcesContent":["import { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport {\n    IAudioWorkletNode,\n    IAudioWorkletNodeOptions,\n    IAudioWorkletProcessorConstructor,\n    IMinimalOfflineAudioContext,\n    IOfflineAudioContext,\n    IReadOnlyMap\n} from '../interfaces';\nimport {\n    TAudioWorkletNodeRendererFactoryFactory,\n    TExposeCurrentFrameAndCurrentTimeFunction,\n    TNativeAudioBuffer,\n    TNativeAudioNode,\n    TNativeAudioParam,\n    TNativeAudioWorkletNode,\n    TNativeChannelMergerNode,\n    TNativeChannelSplitterNode,\n    TNativeGainNode,\n    TNativeOfflineAudioContext\n} from '../types';\n\nconst processBuffer = async <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>(\n    proxy: IAudioWorkletNode<T>,\n    renderedBuffer: null | TNativeAudioBuffer,\n    nativeOfflineAudioContext: TNativeOfflineAudioContext,\n    options: IAudioWorkletNodeOptions,\n    outputChannelCount: number[],\n    processorConstructor: undefined | IAudioWorkletProcessorConstructor,\n    exposeCurrentFrameAndCurrentTime: TExposeCurrentFrameAndCurrentTimeFunction\n): Promise<null | TNativeAudioBuffer> => {\n    // Ceil the length to the next full render quantum.\n    // Bug #17: Safari does not yet expose the length.\n    const length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;\n    const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n    const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n    const processedBuffer =\n        numberOfOutputChannels === 0\n            ? null\n            : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\n\n    if (processorConstructor === undefined) {\n        throw new Error('Missing the processor constructor.');\n    }\n\n    const audioNodeConnections = getAudioNodeConnections(proxy);\n    const audioWorkletProcessor = await getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n    const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n    const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n    const parameters: { [name: string]: Float32Array } = Array.from(proxy.parameters.keys()).reduce(\n        (prmtrs, name) => ({ ...prmtrs, [name]: new Float32Array(128) }),\n        {}\n    );\n\n    for (let i = 0; i < length; i += 128) {\n        if (options.numberOfInputs > 0 && renderedBuffer !== null) {\n            for (let j = 0; j < options.numberOfInputs; j += 1) {\n                for (let k = 0; k < options.channelCount; k += 1) {\n                    copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n                }\n            }\n        }\n\n        if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {\n            processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n            });\n        }\n\n        for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                // The byteLength will be 0 when the ArrayBuffer was transferred.\n                if (outputs[j][k].byteLength === 0) {\n                    outputs[j][k] = new Float32Array(128);\n                }\n            }\n        }\n\n        try {\n            const potentiallyEmptyInputs = inputs.map((input, index) => {\n                if (audioNodeConnections.activeInputs[index].size === 0) {\n                    return [];\n                }\n\n                return input;\n            });\n            const activeSourceFlag = exposeCurrentFrameAndCurrentTime(\n                i / nativeOfflineAudioContext.sampleRate,\n                nativeOfflineAudioContext.sampleRate,\n                () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters)\n            );\n\n            if (processedBuffer !== null) {\n                for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                    for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                        copyToChannel(processedBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                    }\n\n                    outputChannelSplitterNodeOutput += outputChannelCount[j];\n                }\n            }\n\n            if (!activeSourceFlag) {\n                break;\n            }\n        } catch (error) {\n            proxy.dispatchEvent(\n                new ErrorEvent('processorerror', {\n                    colno: error.colno,\n                    filename: error.filename,\n                    lineno: error.lineno,\n                    message: error.message\n                })\n            );\n\n            break;\n        }\n    }\n\n    return processedBuffer;\n};\n\nexport const createAudioWorkletNodeRendererFactory: TAudioWorkletNodeRendererFactoryFactory = (\n    connectAudioParam,\n    connectMultipleOutputs,\n    createNativeAudioBufferSourceNode,\n    createNativeChannelMergerNode,\n    createNativeChannelSplitterNode,\n    createNativeConstantSourceNode,\n    createNativeGainNode,\n    deleteUnrenderedAudioWorkletNode,\n    disconnectMultipleOutputs,\n    exposeCurrentFrameAndCurrentTime,\n    getNativeAudioNode,\n    nativeAudioWorkletNodeConstructor,\n    nativeOfflineAudioContextConstructor,\n    renderAutomation,\n    renderInputsOfAudioNode,\n    renderNativeOfflineAudioContext\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>(\n        name: string,\n        options: IAudioWorkletNodeOptions,\n        processorConstructor: undefined | IAudioWorkletProcessorConstructor\n    ) => {\n        const renderedNativeAudioNodes = new WeakMap<TNativeOfflineAudioContext, TNativeAudioWorkletNode | TNativeGainNode>();\n\n        let processedBufferPromise: null | Promise<null | TNativeAudioBuffer> = null;\n\n        const createAudioNode = async (proxy: IAudioWorkletNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeAudioWorkletNode = getNativeAudioNode<T, TNativeAudioWorkletNode>(proxy);\n            let nativeOutputNodes: null | [TNativeChannelSplitterNode, TNativeChannelMergerNode[], TNativeGainNode] = null;\n\n            const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);\n            const outputChannelCount = Array.isArray(options.outputChannelCount)\n                ? options.outputChannelCount\n                : Array.from(options.outputChannelCount);\n\n            // Bug #61: Only Chrome, Edge & Firefox have an implementation of the AudioWorkletNode yet.\n            if (nativeAudioWorkletNodeConstructor === null) {\n                const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n                const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n                    channelCount: Math.max(1, numberOfOutputChannels),\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    numberOfOutputs: Math.max(1, numberOfOutputChannels)\n                });\n                const outputChannelMergerNodes: TNativeChannelMergerNode[] = [];\n\n                for (let i = 0; i < proxy.numberOfOutputs; i += 1) {\n                    outputChannelMergerNodes.push(\n                        createNativeChannelMergerNode(nativeOfflineAudioContext, {\n                            channelCount: 1,\n                            channelCountMode: 'explicit',\n                            channelInterpretation: 'speakers',\n                            numberOfInputs: outputChannelCount[i]\n                        })\n                    );\n                }\n\n                const outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: options.channelCountMode,\n                    channelInterpretation: options.channelInterpretation,\n                    gain: 1\n                });\n\n                outputGainNode.connect = <TNativeAudioNode['connect']>connectMultipleOutputs.bind(null, outputChannelMergerNodes);\n                outputGainNode.disconnect = <TNativeAudioNode['disconnect']>disconnectMultipleOutputs.bind(null, outputChannelMergerNodes);\n\n                nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n            } else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n            }\n\n            renderedNativeAudioNodes.set(\n                nativeOfflineAudioContext,\n                nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]\n            );\n\n            if (nativeOutputNodes !== null) {\n                if (processedBufferPromise === null) {\n                    if (processorConstructor === undefined) {\n                        throw new Error('Missing the processor constructor.');\n                    }\n\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n\n                    // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.\n                    const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n                    const numberOfParameters =\n                        processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n                    const numberOfChannels = numberOfInputChannels + numberOfParameters;\n\n                    const renderBuffer = async () => {\n                        const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(\n                            numberOfChannels,\n                            // Ceil the length to the next full render quantum.\n                            // Bug #17: Safari does not yet expose the length.\n                            Math.ceil(proxy.context.length / 128) * 128,\n                            nativeOfflineAudioContext.sampleRate\n                        );\n                        const gainNodes: TNativeGainNode[] = [];\n                        const inputChannelSplitterNodes = [];\n\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes.push(\n                                createNativeGainNode(partialOfflineAudioContext, {\n                                    channelCount: options.channelCount,\n                                    channelCountMode: options.channelCountMode,\n                                    channelInterpretation: options.channelInterpretation,\n                                    gain: 1\n                                })\n                            );\n                            inputChannelSplitterNodes.push(\n                                createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                                    channelCount: options.channelCount,\n                                    channelCountMode: 'explicit',\n                                    channelInterpretation: 'discrete',\n                                    numberOfOutputs: options.channelCount\n                                })\n                            );\n                        }\n\n                        const constantSourceNodes = await Promise.all(\n                            Array.from(proxy.parameters.values()).map(async (audioParam) => {\n                                const constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                                    channelCount: 1,\n                                    channelCountMode: 'explicit',\n                                    channelInterpretation: 'discrete',\n                                    offset: audioParam.value\n                                });\n\n                                await renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset);\n\n                                return constantSourceNode;\n                            })\n                        );\n\n                        const inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                            channelCount: 1,\n                            channelCountMode: 'explicit',\n                            channelInterpretation: 'speakers',\n                            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n                        });\n\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n\n                            for (let j = 0; j < options.channelCount; j += 1) {\n                                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n                            }\n                        }\n\n                        for (const [index, constantSourceNode] of constantSourceNodes.entries()) {\n                            constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                            constantSourceNode.start(0);\n                        }\n\n                        inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n\n                        await Promise.all(\n                            gainNodes.map((gainNode) => renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode))\n                        );\n\n                        return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                    };\n\n                    processedBufferPromise = processBuffer(\n                        proxy,\n                        numberOfChannels === 0 ? null : await renderBuffer(),\n                        nativeOfflineAudioContext,\n                        options,\n                        outputChannelCount,\n                        processorConstructor,\n                        exposeCurrentFrameAndCurrentTime\n                    );\n                }\n\n                const processedBuffer = await processedBufferPromise;\n                const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n                    buffer: null,\n                    channelCount: 2,\n                    channelCountMode: 'max',\n                    channelInterpretation: 'speakers',\n                    loop: false,\n                    loopEnd: 0,\n                    loopStart: 0,\n                    playbackRate: 1\n                });\n                const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;\n\n                if (processedBuffer !== null) {\n                    audioBufferSourceNode.buffer = processedBuffer;\n                    audioBufferSourceNode.start(0);\n                }\n\n                audioBufferSourceNode.connect(outputChannelSplitterNode);\n\n                for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {\n                    const outputChannelMergerNode = outputChannelMergerNodes[i];\n\n                    for (let j = 0; j < outputChannelCount[i]; j += 1) {\n                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n\n                    outputChannelSplitterNodeOutput += outputChannelCount[i];\n                }\n\n                return outputGainNode;\n            }\n\n            if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await renderAutomation(\n                        nativeOfflineAudioContext,\n                        audioParam,\n                        // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                        <TNativeAudioParam>(<IReadOnlyMap<string, TNativeAudioParam>>nativeAudioWorkletNode.parameters).get(nm)\n                    );\n                }\n            } else {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await connectAudioParam(\n                        nativeOfflineAudioContext,\n                        audioParam,\n                        // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                        <TNativeAudioParam>(<IReadOnlyMap<string, TNativeAudioParam>>nativeAudioWorkletNode.parameters).get(nm)\n                    );\n                }\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode);\n\n            return nativeAudioWorkletNode;\n        };\n\n        return {\n            render(\n                proxy: IAudioWorkletNode<T>,\n                nativeOfflineAudioContext: TNativeOfflineAudioContext\n            ): Promise<TNativeAudioWorkletNode | TNativeGainNode> {\n                deleteUnrenderedAudioWorkletNode(nativeOfflineAudioContext, proxy);\n\n                const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n                }\n\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}