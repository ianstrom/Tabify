{"ast":null,"code":"import { optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isFunction } from \"../core/util/TypeCheck\";\nimport { assert } from \"../core/util/Debug\";\nimport { Signal } from \"./Signal\";\nimport { SignalOperator } from \"./SignalOperator\";\n/**\n * Wraps the native Web Audio API\n * [WaveShaperNode](http://webaudio.github.io/web-audio-api/#the-waveshapernode-interface).\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination().start();\n * // multiply the output of the signal by 2 using the waveshaper's function\n * const timesTwo = new Tone.WaveShaper((val) => val * 2, 2048).connect(osc.frequency);\n * const signal = new Tone.Signal(440).connect(timesTwo);\n * @category Signal\n */\nexport class WaveShaper extends SignalOperator {\n  constructor() {\n    super(Object.assign(optionsFromArguments(WaveShaper.getDefaults(), arguments, [\"mapping\", \"length\"])));\n    this.name = \"WaveShaper\";\n    /**\n     * the waveshaper node\n     */\n    this._shaper = this.context.createWaveShaper();\n    /**\n     * The input to the waveshaper node.\n     */\n    this.input = this._shaper;\n    /**\n     * The output from the waveshaper node\n     */\n    this.output = this._shaper;\n    const options = optionsFromArguments(WaveShaper.getDefaults(), arguments, [\"mapping\", \"length\"]);\n    if (isArray(options.mapping) || options.mapping instanceof Float32Array) {\n      this.curve = Float32Array.from(options.mapping);\n    } else if (isFunction(options.mapping)) {\n      this.setMap(options.mapping, options.length);\n    }\n  }\n  static getDefaults() {\n    return Object.assign(Signal.getDefaults(), {\n      length: 1024\n    });\n  }\n  /**\n   * Uses a mapping function to set the value of the curve.\n   * @param mapping The function used to define the values.\n   *                The mapping function take two arguments:\n   *                the first is the value at the current position\n   *                which goes from -1 to 1 over the number of elements\n   *                in the curve array. The second argument is the array position.\n   * @example\n   * const shaper = new Tone.WaveShaper();\n   * // map the input signal from [-1, 1] to [0, 10]\n   * shaper.setMap((val, index) => (val + 1) * 5);\n   */\n  setMap(mapping) {\n    let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1024;\n    const array = new Float32Array(length);\n    for (let i = 0, len = length; i < len; i++) {\n      const normalized = i / (len - 1) * 2 - 1;\n      array[i] = mapping(normalized, i);\n    }\n    this.curve = array;\n    return this;\n  }\n  /**\n   * The array to set as the waveshaper curve. For linear curves\n   * array length does not make much difference, but for complex curves\n   * longer arrays will provide smoother interpolation.\n   */\n  get curve() {\n    return this._shaper.curve;\n  }\n  set curve(mapping) {\n    this._shaper.curve = mapping;\n  }\n  /**\n   * Specifies what type of oversampling (if any) should be used when\n   * applying the shaping curve. Can either be \"none\", \"2x\" or \"4x\".\n   */\n  get oversample() {\n    return this._shaper.oversample;\n  }\n  set oversample(oversampling) {\n    const isOverSampleType = [\"none\", \"2x\", \"4x\"].some(str => str.includes(oversampling));\n    assert(isOverSampleType, \"oversampling must be either 'none', '2x', or '4x'\");\n    this._shaper.oversample = oversampling;\n  }\n  /**\n   * Clean up.\n   */\n  dispose() {\n    super.dispose();\n    this._shaper.disconnect();\n    return this;\n  }\n}","map":{"version":3,"names":["optionsFromArguments","isArray","isFunction","assert","Signal","SignalOperator","WaveShaper","constructor","Object","assign","getDefaults","arguments","name","_shaper","context","createWaveShaper","input","output","options","mapping","Float32Array","curve","from","setMap","length","undefined","array","i","len","normalized","oversample","oversampling","isOverSampleType","some","str","includes","dispose","disconnect"],"sources":["/Users/ianstrom/Development/code/Capstone/node_modules/tone/Tone/signal/WaveShaper.ts"],"sourcesContent":["import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isFunction } from \"../core/util/TypeCheck\";\nimport { assert } from \"../core/util/Debug\";\nimport { Signal } from \"./Signal\";\nimport { SignalOperator } from \"./SignalOperator\";\n\nexport type WaveShaperMappingFn = (value: number, index?: number) => number;\n\ntype WaveShaperMapping = WaveShaperMappingFn | number[] | Float32Array;\n\ninterface WaveShaperOptions extends ToneAudioNodeOptions {\n\tmapping?: WaveShaperMapping;\n\tlength: number;\n\tcurve?: number[] | Float32Array;\n}\n\n/**\n * Wraps the native Web Audio API\n * [WaveShaperNode](http://webaudio.github.io/web-audio-api/#the-waveshapernode-interface).\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination().start();\n * // multiply the output of the signal by 2 using the waveshaper's function\n * const timesTwo = new Tone.WaveShaper((val) => val * 2, 2048).connect(osc.frequency);\n * const signal = new Tone.Signal(440).connect(timesTwo);\n * @category Signal\n */\nexport class WaveShaper extends SignalOperator<WaveShaperOptions> {\n\n\treadonly name: string = \"WaveShaper\";\n\n\t/**\n\t * the waveshaper node\n\t */\n\tprivate _shaper: WaveShaperNode = this.context.createWaveShaper();\n\n\t/**\n\t * The input to the waveshaper node.\n\t */\n\tinput = this._shaper;\n\n\t/**\n\t * The output from the waveshaper node\n\t */\n\toutput = this._shaper;\n\n\t/**\n\t * @param mapping The function used to define the values.\n\t *                The mapping function should take two arguments:\n\t *                the first is the value at the current position\n\t *                and the second is the array position.\n\t *                If the argument is an array, that array will be\n\t *                set as the wave shaping function. The input\n\t *                signal is an AudioRange [-1, 1] value and the output\n\t *                signal can take on any numerical values.\n\t *\n\t * @param bufferLen The length of the WaveShaperNode buffer.\n\t */\n\tconstructor(mapping?: WaveShaperMapping, length?: number);\n\tconstructor(options?: Partial<WaveShaperOptions>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(WaveShaper.getDefaults(), arguments, [\"mapping\", \"length\"])));\n\t\tconst options = optionsFromArguments(WaveShaper.getDefaults(), arguments, [\"mapping\", \"length\"]);\n\n\t\tif (isArray(options.mapping) || options.mapping instanceof Float32Array) {\n\t\t\tthis.curve = Float32Array.from(options.mapping);\n\t\t} else if (isFunction(options.mapping)) {\n\t\t\tthis.setMap(options.mapping, options.length);\n\t\t}\n\t}\n\n\tstatic getDefaults(): WaveShaperOptions {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tlength: 1024,\n\t\t});\n\t}\n\n\t/**\n\t * Uses a mapping function to set the value of the curve.\n\t * @param mapping The function used to define the values.\n\t *                The mapping function take two arguments:\n\t *                the first is the value at the current position\n\t *                which goes from -1 to 1 over the number of elements\n\t *                in the curve array. The second argument is the array position.\n\t * @example\n\t * const shaper = new Tone.WaveShaper();\n\t * // map the input signal from [-1, 1] to [0, 10]\n\t * shaper.setMap((val, index) => (val + 1) * 5);\n\t */\n\tsetMap(mapping: WaveShaperMappingFn, length = 1024): this {\n\t\tconst array = new Float32Array(length);\n\t\tfor (let i = 0, len = length; i < len; i++) {\n\t\t\tconst normalized = (i / (len - 1)) * 2 - 1;\n\t\t\tarray[i] = mapping(normalized, i);\n\t\t}\n\t\tthis.curve = array;\n\t\treturn this;\n\t}\n\n\t/**\n\t * The array to set as the waveshaper curve. For linear curves\n\t * array length does not make much difference, but for complex curves\n\t * longer arrays will provide smoother interpolation.\n\t */\n\tget curve(): Float32Array | null {\n\t\treturn this._shaper.curve;\n\t}\n\n\tset curve(mapping: Float32Array | null) {\n\t\tthis._shaper.curve = mapping;\n\t}\n\n\t/**\n\t * Specifies what type of oversampling (if any) should be used when\n\t * applying the shaping curve. Can either be \"none\", \"2x\" or \"4x\".\n\t */\n\tget oversample(): OverSampleType {\n\t\treturn this._shaper.oversample;\n\t}\n\n\tset oversample(oversampling: OverSampleType) {\n\t\tconst isOverSampleType = [\"none\", \"2x\", \"4x\"].some(str => str.includes(oversampling));\n\t\tassert(isOverSampleType, \"oversampling must be either 'none', '2x', or '4x'\");\n\t\tthis._shaper.oversample = oversampling;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._shaper.disconnect();\n\t\treturn this;\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}