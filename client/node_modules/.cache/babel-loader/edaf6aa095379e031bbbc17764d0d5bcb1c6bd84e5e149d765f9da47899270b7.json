{"ast":null,"code":"import { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeStereoPannerNodeFakerFactory = (createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeGainNode, createNativeWaveShaperNode, createNotSupportedError, monitorConnections) => {\n  // The curve has a size of 14bit plus 1 value to have an exact representation for zero. This value has been determined experimentally.\n  const CURVE_SIZE = 16385;\n  const DC_CURVE = new Float32Array([1, 1]);\n  const HALF_PI = Math.PI / 2;\n  const SINGLE_CHANNEL_OPTIONS = {\n    channelCount: 1,\n    channelCountMode: 'explicit',\n    channelInterpretation: 'discrete'\n  };\n  const SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS = {\n    ...SINGLE_CHANNEL_OPTIONS,\n    oversample: 'none'\n  };\n  const buildInternalGraphForMono = (nativeContext, inputGainNode, panGainNode, channelMergerNode) => {\n    const leftWaveShaperCurve = new Float32Array(CURVE_SIZE);\n    const rightWaveShaperCurve = new Float32Array(CURVE_SIZE);\n    for (let i = 0; i < CURVE_SIZE; i += 1) {\n      const x = i / (CURVE_SIZE - 1) * HALF_PI;\n      leftWaveShaperCurve[i] = Math.cos(x);\n      rightWaveShaperCurve[i] = Math.sin(x);\n    }\n    const leftGainNode = createNativeGainNode(nativeContext, {\n      ...SINGLE_CHANNEL_OPTIONS,\n      gain: 0\n    });\n    // Bug #119: Safari does not fully support the WaveShaperNode.\n    const leftWaveShaperNode = createNativeWaveShaperNode(nativeContext, {\n      ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n      curve: leftWaveShaperCurve\n    });\n    // Bug #119: Safari does not fully support the WaveShaperNode.\n    const panWaveShaperNode = createNativeWaveShaperNode(nativeContext, {\n      ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n      curve: DC_CURVE\n    });\n    const rightGainNode = createNativeGainNode(nativeContext, {\n      ...SINGLE_CHANNEL_OPTIONS,\n      gain: 0\n    });\n    // Bug #119: Safari does not fully support the WaveShaperNode.\n    const rightWaveShaperNode = createNativeWaveShaperNode(nativeContext, {\n      ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n      curve: rightWaveShaperCurve\n    });\n    return {\n      connectGraph() {\n        inputGainNode.connect(leftGainNode);\n        inputGainNode.connect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n        inputGainNode.connect(rightGainNode);\n        panWaveShaperNode.connect(panGainNode);\n        panGainNode.connect(leftWaveShaperNode.inputs === undefined ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);\n        panGainNode.connect(rightWaveShaperNode.inputs === undefined ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);\n        leftWaveShaperNode.connect(leftGainNode.gain);\n        rightWaveShaperNode.connect(rightGainNode.gain);\n        leftGainNode.connect(channelMergerNode, 0, 0);\n        rightGainNode.connect(channelMergerNode, 0, 1);\n      },\n      disconnectGraph() {\n        inputGainNode.disconnect(leftGainNode);\n        inputGainNode.disconnect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n        inputGainNode.disconnect(rightGainNode);\n        panWaveShaperNode.disconnect(panGainNode);\n        panGainNode.disconnect(leftWaveShaperNode.inputs === undefined ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);\n        panGainNode.disconnect(rightWaveShaperNode.inputs === undefined ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);\n        leftWaveShaperNode.disconnect(leftGainNode.gain);\n        rightWaveShaperNode.disconnect(rightGainNode.gain);\n        leftGainNode.disconnect(channelMergerNode, 0, 0);\n        rightGainNode.disconnect(channelMergerNode, 0, 1);\n      }\n    };\n  };\n  const buildInternalGraphForStereo = (nativeContext, inputGainNode, panGainNode, channelMergerNode) => {\n    const leftInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n    const leftInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n    const rightInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n    const rightInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n    const centerIndex = Math.floor(CURVE_SIZE / 2);\n    for (let i = 0; i < CURVE_SIZE; i += 1) {\n      if (i > centerIndex) {\n        const x = (i - centerIndex) / (CURVE_SIZE - 1 - centerIndex) * HALF_PI;\n        leftInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n        leftInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n        rightInputForLeftOutputWaveShaperCurve[i] = 0;\n        rightInputForRightOutputWaveShaperCurve[i] = 1;\n      } else {\n        const x = i / (CURVE_SIZE - 1 - centerIndex) * HALF_PI;\n        leftInputForLeftOutputWaveShaperCurve[i] = 1;\n        leftInputForRightOutputWaveShaperCurve[i] = 0;\n        rightInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n        rightInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n      }\n    }\n    const channelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n      channelCount: 2,\n      channelCountMode: 'explicit',\n      channelInterpretation: 'discrete',\n      numberOfOutputs: 2\n    });\n    const leftInputForLeftOutputGainNode = createNativeGainNode(nativeContext, {\n      ...SINGLE_CHANNEL_OPTIONS,\n      gain: 0\n    });\n    // Bug #119: Safari does not fully support the WaveShaperNode.\n    const leftInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, {\n      ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n      curve: leftInputForLeftOutputWaveShaperCurve\n    });\n    const leftInputForRightOutputGainNode = createNativeGainNode(nativeContext, {\n      ...SINGLE_CHANNEL_OPTIONS,\n      gain: 0\n    });\n    // Bug #119: Safari does not fully support the WaveShaperNode.\n    const leftInputForRightOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, {\n      ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n      curve: leftInputForRightOutputWaveShaperCurve\n    });\n    // Bug #119: Safari does not fully support the WaveShaperNode.\n    const panWaveShaperNode = createNativeWaveShaperNode(nativeContext, {\n      ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n      curve: DC_CURVE\n    });\n    const rightInputForLeftOutputGainNode = createNativeGainNode(nativeContext, {\n      ...SINGLE_CHANNEL_OPTIONS,\n      gain: 0\n    });\n    // Bug #119: Safari does not fully support the WaveShaperNode.\n    const rightInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, {\n      ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n      curve: rightInputForLeftOutputWaveShaperCurve\n    });\n    const rightInputForRightOutputGainNode = createNativeGainNode(nativeContext, {\n      ...SINGLE_CHANNEL_OPTIONS,\n      gain: 0\n    });\n    // Bug #119: Safari does not fully support the WaveShaperNode.\n    const rightInputForRightOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, {\n      ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n      curve: rightInputForRightOutputWaveShaperCurve\n    });\n    return {\n      connectGraph() {\n        inputGainNode.connect(channelSplitterNode);\n        inputGainNode.connect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n        channelSplitterNode.connect(leftInputForLeftOutputGainNode, 0);\n        channelSplitterNode.connect(leftInputForRightOutputGainNode, 0);\n        channelSplitterNode.connect(rightInputForLeftOutputGainNode, 1);\n        channelSplitterNode.connect(rightInputForRightOutputGainNode, 1);\n        panWaveShaperNode.connect(panGainNode);\n        panGainNode.connect(leftInputForLeftOutputWaveShaperNode.inputs === undefined ? leftInputForLeftOutputWaveShaperNode : leftInputForLeftOutputWaveShaperNode.inputs[0]);\n        panGainNode.connect(leftInputForRightOutputWaveShaperNode.inputs === undefined ? leftInputForRightOutputWaveShaperNode : leftInputForRightOutputWaveShaperNode.inputs[0]);\n        panGainNode.connect(rightInputForLeftOutputWaveShaperNode.inputs === undefined ? rightInputForLeftOutputWaveShaperNode : rightInputForLeftOutputWaveShaperNode.inputs[0]);\n        panGainNode.connect(rightInputForRightOutputWaveShaperNode.inputs === undefined ? rightInputForRightOutputWaveShaperNode : rightInputForRightOutputWaveShaperNode.inputs[0]);\n        leftInputForLeftOutputWaveShaperNode.connect(leftInputForLeftOutputGainNode.gain);\n        leftInputForRightOutputWaveShaperNode.connect(leftInputForRightOutputGainNode.gain);\n        rightInputForLeftOutputWaveShaperNode.connect(rightInputForLeftOutputGainNode.gain);\n        rightInputForRightOutputWaveShaperNode.connect(rightInputForRightOutputGainNode.gain);\n        leftInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n        rightInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n        leftInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n        rightInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n      },\n      disconnectGraph() {\n        inputGainNode.disconnect(channelSplitterNode);\n        inputGainNode.disconnect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n        channelSplitterNode.disconnect(leftInputForLeftOutputGainNode, 0);\n        channelSplitterNode.disconnect(leftInputForRightOutputGainNode, 0);\n        channelSplitterNode.disconnect(rightInputForLeftOutputGainNode, 1);\n        channelSplitterNode.disconnect(rightInputForRightOutputGainNode, 1);\n        panWaveShaperNode.disconnect(panGainNode);\n        panGainNode.disconnect(leftInputForLeftOutputWaveShaperNode.inputs === undefined ? leftInputForLeftOutputWaveShaperNode : leftInputForLeftOutputWaveShaperNode.inputs[0]);\n        panGainNode.disconnect(leftInputForRightOutputWaveShaperNode.inputs === undefined ? leftInputForRightOutputWaveShaperNode : leftInputForRightOutputWaveShaperNode.inputs[0]);\n        panGainNode.disconnect(rightInputForLeftOutputWaveShaperNode.inputs === undefined ? rightInputForLeftOutputWaveShaperNode : rightInputForLeftOutputWaveShaperNode.inputs[0]);\n        panGainNode.disconnect(rightInputForRightOutputWaveShaperNode.inputs === undefined ? rightInputForRightOutputWaveShaperNode : rightInputForRightOutputWaveShaperNode.inputs[0]);\n        leftInputForLeftOutputWaveShaperNode.disconnect(leftInputForLeftOutputGainNode.gain);\n        leftInputForRightOutputWaveShaperNode.disconnect(leftInputForRightOutputGainNode.gain);\n        rightInputForLeftOutputWaveShaperNode.disconnect(rightInputForLeftOutputGainNode.gain);\n        rightInputForRightOutputWaveShaperNode.disconnect(rightInputForRightOutputGainNode.gain);\n        leftInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);\n        rightInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);\n        leftInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);\n        rightInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);\n      }\n    };\n  };\n  const buildInternalGraph = (nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode) => {\n    if (channelCount === 1) {\n      return buildInternalGraphForMono(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n    }\n    if (channelCount === 2) {\n      return buildInternalGraphForStereo(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n    }\n    throw createNotSupportedError();\n  };\n  return (nativeContext, _ref) => {\n    let {\n      channelCount,\n      channelCountMode,\n      pan,\n      ...audioNodeOptions\n    } = _ref;\n    if (channelCountMode === 'max') {\n      throw createNotSupportedError();\n    }\n    const channelMergerNode = createNativeChannelMergerNode(nativeContext, {\n      ...audioNodeOptions,\n      channelCount: 1,\n      channelCountMode,\n      numberOfInputs: 2\n    });\n    const inputGainNode = createNativeGainNode(nativeContext, {\n      ...audioNodeOptions,\n      channelCount,\n      channelCountMode,\n      gain: 1\n    });\n    const panGainNode = createNativeGainNode(nativeContext, {\n      channelCount: 1,\n      channelCountMode: 'explicit',\n      channelInterpretation: 'discrete',\n      gain: pan\n    });\n    let {\n      connectGraph,\n      disconnectGraph\n    } = buildInternalGraph(nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode);\n    Object.defineProperty(panGainNode.gain, 'defaultValue', {\n      get: () => 0\n    });\n    Object.defineProperty(panGainNode.gain, 'maxValue', {\n      get: () => 1\n    });\n    Object.defineProperty(panGainNode.gain, 'minValue', {\n      get: () => -1\n    });\n    const nativeStereoPannerNodeFakerFactory = {\n      get bufferSize() {\n        return undefined;\n      },\n      get channelCount() {\n        return inputGainNode.channelCount;\n      },\n      set channelCount(value) {\n        if (inputGainNode.channelCount !== value) {\n          if (isConnected) {\n            disconnectGraph();\n          }\n          ({\n            connectGraph,\n            disconnectGraph\n          } = buildInternalGraph(nativeContext, value, inputGainNode, panGainNode, channelMergerNode));\n          if (isConnected) {\n            connectGraph();\n          }\n        }\n        inputGainNode.channelCount = value;\n      },\n      get channelCountMode() {\n        return inputGainNode.channelCountMode;\n      },\n      set channelCountMode(value) {\n        if (value === 'clamped-max' || value === 'max') {\n          throw createNotSupportedError();\n        }\n        inputGainNode.channelCountMode = value;\n      },\n      get channelInterpretation() {\n        return inputGainNode.channelInterpretation;\n      },\n      set channelInterpretation(value) {\n        inputGainNode.channelInterpretation = value;\n      },\n      get context() {\n        return inputGainNode.context;\n      },\n      get inputs() {\n        return [inputGainNode];\n      },\n      get numberOfInputs() {\n        return inputGainNode.numberOfInputs;\n      },\n      get numberOfOutputs() {\n        return inputGainNode.numberOfOutputs;\n      },\n      get pan() {\n        return panGainNode.gain;\n      },\n      addEventListener() {\n        return inputGainNode.addEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n      },\n      dispatchEvent() {\n        return inputGainNode.dispatchEvent(arguments.length <= 0 ? undefined : arguments[0]);\n      },\n      removeEventListener() {\n        return inputGainNode.removeEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n      }\n    };\n    let isConnected = false;\n    const whenConnected = () => {\n      connectGraph();\n      isConnected = true;\n    };\n    const whenDisconnected = () => {\n      disconnectGraph();\n      isConnected = false;\n    };\n    return monitorConnections(interceptConnections(nativeStereoPannerNodeFakerFactory, channelMergerNode), whenConnected, whenDisconnected);\n  };\n};","map":{"version":3,"names":["interceptConnections","createNativeStereoPannerNodeFakerFactory","createNativeChannelMergerNode","createNativeChannelSplitterNode","createNativeGainNode","createNativeWaveShaperNode","createNotSupportedError","monitorConnections","CURVE_SIZE","DC_CURVE","Float32Array","HALF_PI","Math","PI","SINGLE_CHANNEL_OPTIONS","channelCount","channelCountMode","channelInterpretation","SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS","oversample","buildInternalGraphForMono","nativeContext","inputGainNode","panGainNode","channelMergerNode","leftWaveShaperCurve","rightWaveShaperCurve","i","x","cos","sin","leftGainNode","gain","leftWaveShaperNode","curve","panWaveShaperNode","rightGainNode","rightWaveShaperNode","connectGraph","connect","inputs","undefined","disconnectGraph","disconnect","buildInternalGraphForStereo","leftInputForLeftOutputWaveShaperCurve","leftInputForRightOutputWaveShaperCurve","rightInputForLeftOutputWaveShaperCurve","rightInputForRightOutputWaveShaperCurve","centerIndex","floor","channelSplitterNode","numberOfOutputs","leftInputForLeftOutputGainNode","leftInputForLeftOutputWaveShaperNode","leftInputForRightOutputGainNode","leftInputForRightOutputWaveShaperNode","rightInputForLeftOutputGainNode","rightInputForLeftOutputWaveShaperNode","rightInputForRightOutputGainNode","rightInputForRightOutputWaveShaperNode","buildInternalGraph","_ref","pan","audioNodeOptions","numberOfInputs","Object","defineProperty","get","nativeStereoPannerNodeFakerFactory","bufferSize","value","isConnected","context","addEventListener","arguments","length","dispatchEvent","removeEventListener","whenConnected","whenDisconnected"],"sources":["/Users/ianstrom/Development/code/Capstone/client/node_modules/standardized-audio-context/src/factories/native-stereo-panner-node-faker-factory.ts"],"sourcesContent":["import { interceptConnections } from '../helpers/intercept-connections';\nimport { INativeWaveShaperNodeFaker } from '../interfaces';\nimport {\n    TNativeAudioNode,\n    TNativeChannelMergerNode,\n    TNativeContext,\n    TNativeGainNode,\n    TNativeStereoPannerNode,\n    TNativeStereoPannerNodeFakerFactoryFactory\n} from '../types';\n\nexport const createNativeStereoPannerNodeFakerFactory: TNativeStereoPannerNodeFakerFactoryFactory = (\n    createNativeChannelMergerNode,\n    createNativeChannelSplitterNode,\n    createNativeGainNode,\n    createNativeWaveShaperNode,\n    createNotSupportedError,\n    monitorConnections\n) => {\n    // The curve has a size of 14bit plus 1 value to have an exact representation for zero. This value has been determined experimentally.\n    const CURVE_SIZE = 16385;\n    const DC_CURVE = new Float32Array([1, 1]);\n    const HALF_PI = Math.PI / 2;\n    const SINGLE_CHANNEL_OPTIONS = { channelCount: 1, channelCountMode: 'explicit', channelInterpretation: 'discrete' } as const;\n    const SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS = { ...SINGLE_CHANNEL_OPTIONS, oversample: 'none' } as const;\n\n    const buildInternalGraphForMono = (\n        nativeContext: TNativeContext,\n        inputGainNode: TNativeGainNode,\n        panGainNode: TNativeGainNode,\n        channelMergerNode: TNativeChannelMergerNode\n    ) => {\n        const leftWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightWaveShaperCurve = new Float32Array(CURVE_SIZE);\n\n        for (let i = 0; i < CURVE_SIZE; i += 1) {\n            const x = (i / (CURVE_SIZE - 1)) * HALF_PI;\n\n            leftWaveShaperCurve[i] = Math.cos(x);\n            rightWaveShaperCurve[i] = Math.sin(x);\n        }\n\n        const leftGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftWaveShaperNode = <INativeWaveShaperNodeFaker>(\n            createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: leftWaveShaperCurve })\n        );\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const panWaveShaperNode = <INativeWaveShaperNodeFaker>(\n            createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: DC_CURVE })\n        );\n        const rightGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightWaveShaperNode = <INativeWaveShaperNodeFaker>(\n            createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: rightWaveShaperCurve })\n        );\n\n        return {\n            connectGraph(): void {\n                inputGainNode.connect(leftGainNode);\n                inputGainNode.connect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n                inputGainNode.connect(rightGainNode);\n\n                panWaveShaperNode.connect(panGainNode);\n\n                panGainNode.connect(leftWaveShaperNode.inputs === undefined ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);\n                panGainNode.connect(rightWaveShaperNode.inputs === undefined ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);\n\n                leftWaveShaperNode.connect(leftGainNode.gain);\n                rightWaveShaperNode.connect(rightGainNode.gain);\n\n                leftGainNode.connect(channelMergerNode, 0, 0);\n                rightGainNode.connect(channelMergerNode, 0, 1);\n            },\n            disconnectGraph(): void {\n                inputGainNode.disconnect(leftGainNode);\n                inputGainNode.disconnect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n                inputGainNode.disconnect(rightGainNode);\n\n                panWaveShaperNode.disconnect(panGainNode);\n\n                panGainNode.disconnect(leftWaveShaperNode.inputs === undefined ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);\n                panGainNode.disconnect(rightWaveShaperNode.inputs === undefined ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);\n\n                leftWaveShaperNode.disconnect(leftGainNode.gain);\n                rightWaveShaperNode.disconnect(rightGainNode.gain);\n\n                leftGainNode.disconnect(channelMergerNode, 0, 0);\n                rightGainNode.disconnect(channelMergerNode, 0, 1);\n            }\n        };\n    };\n\n    const buildInternalGraphForStereo = (\n        nativeContext: TNativeContext,\n        inputGainNode: TNativeGainNode,\n        panGainNode: TNativeGainNode,\n        channelMergerNode: TNativeChannelMergerNode\n    ) => {\n        const leftInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const leftInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n\n        const centerIndex = Math.floor(CURVE_SIZE / 2);\n\n        for (let i = 0; i < CURVE_SIZE; i += 1) {\n            if (i > centerIndex) {\n                const x = ((i - centerIndex) / (CURVE_SIZE - 1 - centerIndex)) * HALF_PI;\n\n                leftInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n                leftInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n                rightInputForLeftOutputWaveShaperCurve[i] = 0;\n                rightInputForRightOutputWaveShaperCurve[i] = 1;\n            } else {\n                const x = (i / (CURVE_SIZE - 1 - centerIndex)) * HALF_PI;\n\n                leftInputForLeftOutputWaveShaperCurve[i] = 1;\n                leftInputForRightOutputWaveShaperCurve[i] = 0;\n                rightInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n                rightInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n            }\n        }\n\n        const channelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n            channelCount: 2,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            numberOfOutputs: 2\n        });\n        const leftInputForLeftOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftInputForLeftOutputWaveShaperNode = <INativeWaveShaperNodeFaker>createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: leftInputForLeftOutputWaveShaperCurve\n        });\n        const leftInputForRightOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftInputForRightOutputWaveShaperNode = <INativeWaveShaperNodeFaker>createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: leftInputForRightOutputWaveShaperCurve\n        });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const panWaveShaperNode = <INativeWaveShaperNodeFaker>(\n            createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: DC_CURVE })\n        );\n        const rightInputForLeftOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightInputForLeftOutputWaveShaperNode = <INativeWaveShaperNodeFaker>createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: rightInputForLeftOutputWaveShaperCurve\n        });\n        const rightInputForRightOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightInputForRightOutputWaveShaperNode = <INativeWaveShaperNodeFaker>createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: rightInputForRightOutputWaveShaperCurve\n        });\n\n        return {\n            connectGraph(): void {\n                inputGainNode.connect(channelSplitterNode);\n                inputGainNode.connect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n\n                channelSplitterNode.connect(leftInputForLeftOutputGainNode, 0);\n                channelSplitterNode.connect(leftInputForRightOutputGainNode, 0);\n                channelSplitterNode.connect(rightInputForLeftOutputGainNode, 1);\n                channelSplitterNode.connect(rightInputForRightOutputGainNode, 1);\n\n                panWaveShaperNode.connect(panGainNode);\n\n                panGainNode.connect(\n                    leftInputForLeftOutputWaveShaperNode.inputs === undefined\n                        ? leftInputForLeftOutputWaveShaperNode\n                        : leftInputForLeftOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.connect(\n                    leftInputForRightOutputWaveShaperNode.inputs === undefined\n                        ? leftInputForRightOutputWaveShaperNode\n                        : leftInputForRightOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.connect(\n                    rightInputForLeftOutputWaveShaperNode.inputs === undefined\n                        ? rightInputForLeftOutputWaveShaperNode\n                        : rightInputForLeftOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.connect(\n                    rightInputForRightOutputWaveShaperNode.inputs === undefined\n                        ? rightInputForRightOutputWaveShaperNode\n                        : rightInputForRightOutputWaveShaperNode.inputs[0]\n                );\n\n                leftInputForLeftOutputWaveShaperNode.connect(leftInputForLeftOutputGainNode.gain);\n                leftInputForRightOutputWaveShaperNode.connect(leftInputForRightOutputGainNode.gain);\n                rightInputForLeftOutputWaveShaperNode.connect(rightInputForLeftOutputGainNode.gain);\n                rightInputForRightOutputWaveShaperNode.connect(rightInputForRightOutputGainNode.gain);\n\n                leftInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n                rightInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n\n                leftInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n                rightInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n            },\n            disconnectGraph(): void {\n                inputGainNode.disconnect(channelSplitterNode);\n                inputGainNode.disconnect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n\n                channelSplitterNode.disconnect(leftInputForLeftOutputGainNode, 0);\n                channelSplitterNode.disconnect(leftInputForRightOutputGainNode, 0);\n                channelSplitterNode.disconnect(rightInputForLeftOutputGainNode, 1);\n                channelSplitterNode.disconnect(rightInputForRightOutputGainNode, 1);\n\n                panWaveShaperNode.disconnect(panGainNode);\n\n                panGainNode.disconnect(\n                    leftInputForLeftOutputWaveShaperNode.inputs === undefined\n                        ? leftInputForLeftOutputWaveShaperNode\n                        : leftInputForLeftOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.disconnect(\n                    leftInputForRightOutputWaveShaperNode.inputs === undefined\n                        ? leftInputForRightOutputWaveShaperNode\n                        : leftInputForRightOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.disconnect(\n                    rightInputForLeftOutputWaveShaperNode.inputs === undefined\n                        ? rightInputForLeftOutputWaveShaperNode\n                        : rightInputForLeftOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.disconnect(\n                    rightInputForRightOutputWaveShaperNode.inputs === undefined\n                        ? rightInputForRightOutputWaveShaperNode\n                        : rightInputForRightOutputWaveShaperNode.inputs[0]\n                );\n\n                leftInputForLeftOutputWaveShaperNode.disconnect(leftInputForLeftOutputGainNode.gain);\n                leftInputForRightOutputWaveShaperNode.disconnect(leftInputForRightOutputGainNode.gain);\n                rightInputForLeftOutputWaveShaperNode.disconnect(rightInputForLeftOutputGainNode.gain);\n                rightInputForRightOutputWaveShaperNode.disconnect(rightInputForRightOutputGainNode.gain);\n\n                leftInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);\n                rightInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);\n\n                leftInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);\n                rightInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);\n            }\n        };\n    };\n\n    const buildInternalGraph = (\n        nativeContext: TNativeContext,\n        channelCount: number,\n        inputGainNode: TNativeGainNode,\n        panGainNode: TNativeGainNode,\n        channelMergerNode: TNativeChannelMergerNode\n    ) => {\n        if (channelCount === 1) {\n            return buildInternalGraphForMono(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n        }\n\n        if (channelCount === 2) {\n            return buildInternalGraphForStereo(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n        }\n\n        throw createNotSupportedError();\n    };\n\n    return (nativeContext, { channelCount, channelCountMode, pan, ...audioNodeOptions }) => {\n        if (channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n\n        const channelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            ...audioNodeOptions,\n            channelCount: 1,\n            channelCountMode,\n            numberOfInputs: 2\n        });\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, channelCount, channelCountMode, gain: 1 });\n        const panGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: pan\n        });\n\n        let { connectGraph, disconnectGraph } = buildInternalGraph(\n            nativeContext,\n            channelCount,\n            inputGainNode,\n            panGainNode,\n            channelMergerNode\n        );\n\n        Object.defineProperty(panGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(panGainNode.gain, 'maxValue', { get: () => 1 });\n        Object.defineProperty(panGainNode.gain, 'minValue', { get: () => -1 });\n\n        const nativeStereoPannerNodeFakerFactory = {\n            get bufferSize(): undefined {\n                return undefined;\n            },\n            get channelCount(): number {\n                return inputGainNode.channelCount;\n            },\n            set channelCount(value) {\n                if (inputGainNode.channelCount !== value) {\n                    if (isConnected) {\n                        disconnectGraph();\n                    }\n\n                    ({ connectGraph, disconnectGraph } = buildInternalGraph(\n                        nativeContext,\n                        value,\n                        inputGainNode,\n                        panGainNode,\n                        channelMergerNode\n                    ));\n\n                    if (isConnected) {\n                        connectGraph();\n                    }\n                }\n\n                inputGainNode.channelCount = value;\n            },\n            get channelCountMode(): TNativeStereoPannerNode['channelCountMode'] {\n                return inputGainNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                if (value === 'clamped-max' || value === 'max') {\n                    throw createNotSupportedError();\n                }\n\n                inputGainNode.channelCountMode = value;\n            },\n            get channelInterpretation(): TNativeStereoPannerNode['channelInterpretation'] {\n                return inputGainNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n            },\n            get context(): TNativeStereoPannerNode['context'] {\n                return inputGainNode.context;\n            },\n            get inputs(): TNativeAudioNode[] {\n                return [inputGainNode];\n            },\n            get numberOfInputs(): number {\n                return inputGainNode.numberOfInputs;\n            },\n            get numberOfOutputs(): number {\n                return inputGainNode.numberOfOutputs;\n            },\n            get pan(): TNativeStereoPannerNode['pan'] {\n                return panGainNode.gain;\n            },\n            addEventListener(...args: any[]): void {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args: any[]): boolean {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args: any[]): void {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n\n        let isConnected = false;\n\n        const whenConnected = () => {\n            connectGraph();\n\n            isConnected = true;\n        };\n        const whenDisconnected = () => {\n            disconnectGraph();\n\n            isConnected = false;\n        };\n\n        return monitorConnections(\n            interceptConnections(nativeStereoPannerNodeFakerFactory, channelMergerNode),\n            whenConnected,\n            whenDisconnected\n        );\n    };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}