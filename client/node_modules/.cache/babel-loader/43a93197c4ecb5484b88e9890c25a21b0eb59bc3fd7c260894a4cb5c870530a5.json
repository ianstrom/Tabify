{"ast":null,"code":"import { Effect } from \"./Effect\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { WaveShaper } from \"../signal/WaveShaper\";\n/**\n * Chebyshev is a waveshaper which is good\n * for making different types of distortion sounds.\n * Note that odd orders sound very different from even ones,\n * and order = 1 is no change.\n * Read more at [music.columbia.edu](http://music.columbia.edu/cmc/musicandcomputers/chapter4/04_06.php).\n * @example\n * // create a new cheby\n * const cheby = new Tone.Chebyshev(50).toDestination();\n * // create a monosynth connected to our cheby\n * const synth = new Tone.MonoSynth().connect(cheby);\n * synth.triggerAttackRelease(\"C2\", 0.4);\n * @category Effect\n */\nexport class Chebyshev extends Effect {\n  constructor() {\n    super(optionsFromArguments(Chebyshev.getDefaults(), arguments, [\"order\"]));\n    this.name = \"Chebyshev\";\n    const options = optionsFromArguments(Chebyshev.getDefaults(), arguments, [\"order\"]);\n    this._shaper = new WaveShaper({\n      context: this.context,\n      length: 4096\n    });\n    this._order = options.order;\n    this.connectEffect(this._shaper);\n    this.order = options.order;\n    this.oversample = options.oversample;\n  }\n  static getDefaults() {\n    return Object.assign(Effect.getDefaults(), {\n      order: 1,\n      oversample: \"none\"\n    });\n  }\n  /**\n   * get the coefficient for that degree\n   * @param  x the x value\n   * @param  degree\n   * @param  memo memoize the computed value. this speeds up computation greatly.\n   */\n  _getCoefficient(x, degree, memo) {\n    if (memo.has(degree)) {\n      return memo.get(degree);\n    } else if (degree === 0) {\n      memo.set(degree, 0);\n    } else if (degree === 1) {\n      memo.set(degree, x);\n    } else {\n      memo.set(degree, 2 * x * this._getCoefficient(x, degree - 1, memo) - this._getCoefficient(x, degree - 2, memo));\n    }\n    return memo.get(degree);\n  }\n  /**\n   * The order of the Chebyshev polynomial which creates the equation which is applied to the incoming\n   * signal through a Tone.WaveShaper. The equations are in the form:\n   * ```\n   * order 2: 2x^2 + 1\n   * order 3: 4x^3 + 3x\n   * ```\n   * @min 1\n   * @max 100\n   */\n  get order() {\n    return this._order;\n  }\n  set order(order) {\n    this._order = order;\n    this._shaper.setMap(x => {\n      return this._getCoefficient(x, order, new Map());\n    });\n  }\n  /**\n   * The oversampling of the effect. Can either be \"none\", \"2x\" or \"4x\".\n   */\n  get oversample() {\n    return this._shaper.oversample;\n  }\n  set oversample(oversampling) {\n    this._shaper.oversample = oversampling;\n  }\n  dispose() {\n    super.dispose();\n    this._shaper.dispose();\n    return this;\n  }\n}","map":{"version":3,"names":["Effect","optionsFromArguments","WaveShaper","Chebyshev","constructor","getDefaults","arguments","name","options","_shaper","context","length","_order","order","connectEffect","oversample","Object","assign","_getCoefficient","x","degree","memo","has","get","set","setMap","Map","oversampling","dispose"],"sources":["/Users/ianstrom/Development/code/Capstone/client/node_modules/tone/Tone/effect/Chebyshev.ts"],"sourcesContent":["import { Effect, EffectOptions } from \"./Effect\";\nimport { Positive } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { WaveShaper } from \"../signal/WaveShaper\";\n\nexport interface ChebyshevOptions extends EffectOptions {\n\torder: Positive;\n\toversample: OverSampleType;\n}\n\n/**\n * Chebyshev is a waveshaper which is good \n * for making different types of distortion sounds.\n * Note that odd orders sound very different from even ones, \n * and order = 1 is no change. \n * Read more at [music.columbia.edu](http://music.columbia.edu/cmc/musicandcomputers/chapter4/04_06.php).\n * @example\n * // create a new cheby\n * const cheby = new Tone.Chebyshev(50).toDestination();\n * // create a monosynth connected to our cheby\n * const synth = new Tone.MonoSynth().connect(cheby);\n * synth.triggerAttackRelease(\"C2\", 0.4);\n * @category Effect\n */\nexport class Chebyshev extends Effect<ChebyshevOptions> {\n\n\treadonly name: string = \"Chebyshev\";\n\n\t/**\n\t * The private waveshaper node\n\t */\n\tprivate _shaper: WaveShaper;\n\n\t/**\n\t * holds onto the order of the filter\n\t */\n\tprivate _order: number;\n\n\t/**\n\t * @param order The order of the chebyshev polynomial. Normal range between 1-100. \n\t */\n\tconstructor(order?: Positive);\n\tconstructor(options?: Partial<ChebyshevOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Chebyshev.getDefaults(), arguments, [\"order\"]));\n\t\tconst options = optionsFromArguments(Chebyshev.getDefaults(), arguments, [\"order\"]);\n\n\t\tthis._shaper = new WaveShaper({\n\t\t\tcontext: this.context,\n\t\t\tlength: 4096\n\t\t});\n\t\tthis._order = options.order;\n\n\t\tthis.connectEffect(this._shaper);\n\t\tthis.order = options.order;\n\t\tthis.oversample = options.oversample;\n\t}\n\n\tstatic getDefaults(): ChebyshevOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\torder: 1,\n\t\t\toversample: \"none\" as \"none\"\n\t\t});\n\t}\n\n\t/**\n\t * get the coefficient for that degree\n\t * @param  x the x value\n\t * @param  degree \n\t * @param  memo memoize the computed value. this speeds up computation greatly. \n\t */\n\tprivate _getCoefficient(x: number, degree: number, memo: Map<number, number>): number {\n\t\tif (memo.has(degree)) {\n\t\t\treturn memo.get(degree) as number;\n\t\t} else if (degree === 0) {\n\t\t\tmemo.set(degree, 0);\n\t\t} else if (degree === 1) {\n\t\t\tmemo.set(degree, x);\n\t\t} else {\n\t\t\tmemo.set(degree, 2 * x * this._getCoefficient(x, degree - 1, memo) - this._getCoefficient(x, degree - 2, memo));\n\t\t}\n\t\treturn memo.get(degree) as number;\n\t}\n\n\t/**\n\t * The order of the Chebyshev polynomial which creates the equation which is applied to the incoming \n\t * signal through a Tone.WaveShaper. The equations are in the form:\n\t * ```\n\t * order 2: 2x^2 + 1\n\t * order 3: 4x^3 + 3x \n\t * ```\n\t * @min 1\n\t * @max 100\n\t */\n\tget order(): Positive {\n\t\treturn this._order;\n\t}\n\tset order(order) {\n\t\tthis._order = order;\n\t\tthis._shaper.setMap((x => {\n\t\t\treturn this._getCoefficient(x, order, new Map());\n\t\t}));\n\t}\n\n\t/**\n\t * The oversampling of the effect. Can either be \"none\", \"2x\" or \"4x\".\n\t */\n\tget oversample(): OverSampleType {\n\t\treturn this._shaper.oversample;\n\t}\n\tset oversample(oversampling) {\n\t\tthis._shaper.oversample = oversampling;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._shaper.dispose();\n\t\treturn this;\n\t}\n}\n"],"mappings":"AAAA,SAASA,MAAM,QAAuB,UAAU;AAEhD,SAASC,oBAAoB,QAAQ,uBAAuB;AAC5D,SAASC,UAAU,QAAQ,sBAAsB;AAOjD;;;;;;;;;;;;;;AAcA,OAAM,MAAOC,SAAU,SAAQH,MAAwB;EAmBtDI,YAAA;IAEC,KAAK,CAACH,oBAAoB,CAACE,SAAS,CAACE,WAAW,EAAE,EAAEC,SAAS,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC;IAnBlE,KAAAC,IAAI,GAAW,WAAW;IAoBlC,MAAMC,OAAO,GAAGP,oBAAoB,CAACE,SAAS,CAACE,WAAW,EAAE,EAAEC,SAAS,EAAE,CAAC,OAAO,CAAC,CAAC;IAEnF,IAAI,CAACG,OAAO,GAAG,IAAIP,UAAU,CAAC;MAC7BQ,OAAO,EAAE,IAAI,CAACA,OAAO;MACrBC,MAAM,EAAE;KACR,CAAC;IACF,IAAI,CAACC,MAAM,GAAGJ,OAAO,CAACK,KAAK;IAE3B,IAAI,CAACC,aAAa,CAAC,IAAI,CAACL,OAAO,CAAC;IAChC,IAAI,CAACI,KAAK,GAAGL,OAAO,CAACK,KAAK;IAC1B,IAAI,CAACE,UAAU,GAAGP,OAAO,CAACO,UAAU;EACrC;EAEA,OAAOV,WAAWA,CAAA;IACjB,OAAOW,MAAM,CAACC,MAAM,CAACjB,MAAM,CAACK,WAAW,EAAE,EAAE;MAC1CQ,KAAK,EAAE,CAAC;MACRE,UAAU,EAAE;KACZ,CAAC;EACH;EAEA;;;;;;EAMQG,eAAeA,CAACC,CAAS,EAAEC,MAAc,EAAEC,IAAyB;IAC3E,IAAIA,IAAI,CAACC,GAAG,CAACF,MAAM,CAAC,EAAE;MACrB,OAAOC,IAAI,CAACE,GAAG,CAACH,MAAM,CAAW;KACjC,MAAM,IAAIA,MAAM,KAAK,CAAC,EAAE;MACxBC,IAAI,CAACG,GAAG,CAACJ,MAAM,EAAE,CAAC,CAAC;KACnB,MAAM,IAAIA,MAAM,KAAK,CAAC,EAAE;MACxBC,IAAI,CAACG,GAAG,CAACJ,MAAM,EAAED,CAAC,CAAC;KACnB,MAAM;MACNE,IAAI,CAACG,GAAG,CAACJ,MAAM,EAAE,CAAC,GAAGD,CAAC,GAAG,IAAI,CAACD,eAAe,CAACC,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEC,IAAI,CAAC,GAAG,IAAI,CAACH,eAAe,CAACC,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEC,IAAI,CAAC,CAAC;;IAEhH,OAAOA,IAAI,CAACE,GAAG,CAACH,MAAM,CAAW;EAClC;EAEA;;;;;;;;;;EAUA,IAAIP,KAAKA,CAAA;IACR,OAAO,IAAI,CAACD,MAAM;EACnB;EACA,IAAIC,KAAKA,CAACA,KAAK;IACd,IAAI,CAACD,MAAM,GAAGC,KAAK;IACnB,IAAI,CAACJ,OAAO,CAACgB,MAAM,CAAEN,CAAC,IAAG;MACxB,OAAO,IAAI,CAACD,eAAe,CAACC,CAAC,EAAEN,KAAK,EAAE,IAAIa,GAAG,EAAE,CAAC;IACjD,CAAC,CAAE;EACJ;EAEA;;;EAGA,IAAIX,UAAUA,CAAA;IACb,OAAO,IAAI,CAACN,OAAO,CAACM,UAAU;EAC/B;EACA,IAAIA,UAAUA,CAACY,YAAY;IAC1B,IAAI,CAAClB,OAAO,CAACM,UAAU,GAAGY,YAAY;EACvC;EAEAC,OAAOA,CAAA;IACN,KAAK,CAACA,OAAO,EAAE;IACf,IAAI,CAACnB,OAAO,CAACmB,OAAO,EAAE;IACtB,OAAO,IAAI;EACZ"},"metadata":{},"sourceType":"module","externalDependencies":[]}