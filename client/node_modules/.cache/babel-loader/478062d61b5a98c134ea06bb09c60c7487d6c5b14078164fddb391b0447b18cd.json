{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { connect, ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { Volume } from \"../component/channel/Volume\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { assert } from \"../core/util/Debug\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { isDefined, isNumber } from \"../core/util/TypeCheck\";\n/**\n * UserMedia uses MediaDevices.getUserMedia to open up and external microphone or audio input.\n * Check [MediaDevices API Support](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia)\n * to see which browsers are supported. Access to an external input\n * is limited to secure (HTTPS) connections.\n * @example\n * const meter = new Tone.Meter();\n * const mic = new Tone.UserMedia().connect(meter);\n * mic.open().then(() => {\n * \t// promise resolves when input is available\n * \tconsole.log(\"mic open\");\n * \t// print the incoming mic levels in decibels\n * \tsetInterval(() => console.log(meter.getValue()), 100);\n * }).catch(e => {\n * \t// promise is rejected when the user doesn't have or allow mic access\n * \tconsole.log(\"mic not open\");\n * });\n * @category Source\n */\nexport class UserMedia extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(UserMedia.getDefaults(), arguments, [\"volume\"]));\n    this.name = \"UserMedia\";\n    const options = optionsFromArguments(UserMedia.getDefaults(), arguments, [\"volume\"]);\n    this._volume = this.output = new Volume({\n      context: this.context,\n      volume: options.volume\n    });\n    this.volume = this._volume.volume;\n    readOnly(this, \"volume\");\n    this.mute = options.mute;\n  }\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      mute: false,\n      volume: 0\n    });\n  }\n  /**\n   * Open the media stream. If a string is passed in, it is assumed\n   * to be the label or id of the stream, if a number is passed in,\n   * it is the input number of the stream.\n   * @param  labelOrId The label or id of the audio input media device.\n   *                   With no argument, the default stream is opened.\n   * @return The promise is resolved when the stream is open.\n   */\n  open(labelOrId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      assert(UserMedia.supported, \"UserMedia is not supported\");\n      // close the previous stream\n      if (this.state === \"started\") {\n        this.close();\n      }\n      const devices = yield UserMedia.enumerateDevices();\n      if (isNumber(labelOrId)) {\n        this._device = devices[labelOrId];\n      } else {\n        this._device = devices.find(device => {\n          return device.label === labelOrId || device.deviceId === labelOrId;\n        });\n        // didn't find a matching device\n        if (!this._device && devices.length > 0) {\n          this._device = devices[0];\n        }\n        assert(isDefined(this._device), `No matching device ${labelOrId}`);\n      }\n      // do getUserMedia\n      const constraints = {\n        audio: {\n          echoCancellation: false,\n          sampleRate: this.context.sampleRate,\n          noiseSuppression: false,\n          mozNoiseSuppression: false\n        }\n      };\n      if (this._device) {\n        // @ts-ignore\n        constraints.audio.deviceId = this._device.deviceId;\n      }\n      const stream = yield navigator.mediaDevices.getUserMedia(constraints);\n      // start a new source only if the previous one is closed\n      if (!this._stream) {\n        this._stream = stream;\n        // Wrap a MediaStreamSourceNode around the live input stream.\n        const mediaStreamNode = this.context.createMediaStreamSource(stream);\n        // Connect the MediaStreamSourceNode to a gate gain node\n        connect(mediaStreamNode, this.output);\n        this._mediaStream = mediaStreamNode;\n      }\n      return this;\n    });\n  }\n  /**\n   * Close the media stream\n   */\n  close() {\n    if (this._stream && this._mediaStream) {\n      this._stream.getAudioTracks().forEach(track => {\n        track.stop();\n      });\n      this._stream = undefined;\n      // remove the old media stream\n      this._mediaStream.disconnect();\n      this._mediaStream = undefined;\n    }\n    this._device = undefined;\n    return this;\n  }\n  /**\n   * Returns a promise which resolves with the list of audio input devices available.\n   * @return The promise that is resolved with the devices\n   * @example\n   * Tone.UserMedia.enumerateDevices().then((devices) => {\n   * \t// print the device labels\n   * \tconsole.log(devices.map(device => device.label));\n   * });\n   */\n  static enumerateDevices() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const allDevices = yield navigator.mediaDevices.enumerateDevices();\n      return allDevices.filter(device => {\n        return device.kind === \"audioinput\";\n      });\n    });\n  }\n  /**\n   * Returns the playback state of the source, \"started\" when the microphone is open\n   * and \"stopped\" when the mic is closed.\n   */\n  get state() {\n    return this._stream && this._stream.active ? \"started\" : \"stopped\";\n  }\n  /**\n   * Returns an identifier for the represented device that is\n   * persisted across sessions. It is un-guessable by other applications and\n   * unique to the origin of the calling application. It is reset when the\n   * user clears cookies (for Private Browsing, a different identifier is\n   * used that is not persisted across sessions). Returns undefined when the\n   * device is not open.\n   */\n  get deviceId() {\n    if (this._device) {\n      return this._device.deviceId;\n    } else {\n      return undefined;\n    }\n  }\n  /**\n   * Returns a group identifier. Two devices have the\n   * same group identifier if they belong to the same physical device.\n   * Returns null  when the device is not open.\n   */\n  get groupId() {\n    if (this._device) {\n      return this._device.groupId;\n    } else {\n      return undefined;\n    }\n  }\n  /**\n   * Returns a label describing this device (for example \"Built-in Microphone\").\n   * Returns undefined when the device is not open or label is not available\n   * because of permissions.\n   */\n  get label() {\n    if (this._device) {\n      return this._device.label;\n    } else {\n      return undefined;\n    }\n  }\n  /**\n   * Mute the output.\n   * @example\n   * const mic = new Tone.UserMedia();\n   * mic.open().then(() => {\n   * \t// promise resolves when input is available\n   * });\n   * // mute the output\n   * mic.mute = true;\n   */\n  get mute() {\n    return this._volume.mute;\n  }\n  set mute(mute) {\n    this._volume.mute = mute;\n  }\n  dispose() {\n    super.dispose();\n    this.close();\n    this._volume.dispose();\n    this.volume.dispose();\n    return this;\n  }\n  /**\n   * If getUserMedia is supported by the browser.\n   */\n  static get supported() {\n    return isDefined(navigator.mediaDevices) && isDefined(navigator.mediaDevices.getUserMedia);\n  }\n}","map":{"version":3,"names":["connect","ToneAudioNode","Volume","optionsFromArguments","assert","readOnly","isDefined","isNumber","UserMedia","constructor","getDefaults","arguments","name","options","_volume","output","context","volume","mute","Object","assign","open","labelOrId","supported","state","close","devices","enumerateDevices","_device","find","device","label","deviceId","length","constraints","audio","echoCancellation","sampleRate","noiseSuppression","mozNoiseSuppression","stream","navigator","mediaDevices","getUserMedia","_stream","mediaStreamNode","createMediaStreamSource","_mediaStream","getAudioTracks","forEach","track","stop","undefined","disconnect","allDevices","filter","kind","active","groupId","dispose"],"sources":["/Users/ianstrom/Development/code/Capstone/client/node_modules/tone/Tone/source/UserMedia.ts"],"sourcesContent":["import { connect, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { Decibels } from \"../core/type/Units\";\nimport { Volume } from \"../component/channel/Volume\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { assert } from \"../core/util/Debug\";\nimport { Param } from \"../core/context/Param\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { isDefined, isNumber } from \"../core/util/TypeCheck\";\n\nexport interface UserMediaOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n\tmute: boolean;\n}\n/**\n * UserMedia uses MediaDevices.getUserMedia to open up and external microphone or audio input. \n * Check [MediaDevices API Support](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia)\n * to see which browsers are supported. Access to an external input\n * is limited to secure (HTTPS) connections.\n * @example\n * const meter = new Tone.Meter();\n * const mic = new Tone.UserMedia().connect(meter);\n * mic.open().then(() => {\n * \t// promise resolves when input is available\n * \tconsole.log(\"mic open\");\n * \t// print the incoming mic levels in decibels\n * \tsetInterval(() => console.log(meter.getValue()), 100);\n * }).catch(e => {\n * \t// promise is rejected when the user doesn't have or allow mic access\n * \tconsole.log(\"mic not open\");\n * });\n * @category Source\n */\n\nexport class UserMedia extends ToneAudioNode<UserMediaOptions> {\n\n\treadonly name: string = \"UserMedia\";\n\n\treadonly input: undefined;\n\treadonly output: OutputNode;\n\n\t/**\n\t * The MediaStreamNode\n\t */\n\tprivate _mediaStream?: MediaStreamAudioSourceNode;\n\n\t/**\n\t * The media stream created by getUserMedia.\n\t */\n\tprivate _stream?: MediaStream;\n\n\t/**\n\t * The open device\n\t */\n\tprivate _device?: MediaDeviceInfo;\n\n\t/**\n\t * The output volume node\n\t */\n\tprivate _volume: Volume;\n\n\t/**\n\t * The volume of the output in decibels.\n\t */\n\treadonly volume: Param<\"decibels\">;\n\n\t/**\n\t * @param volume The level of the input in decibels\n\t */\n\tconstructor(volume?: Decibels);\n\tconstructor(options?: Partial<UserMediaOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(UserMedia.getDefaults(), arguments, [\"volume\"]));\n\t\tconst options = optionsFromArguments(UserMedia.getDefaults(), arguments, [\"volume\"]);\n\n\t\tthis._volume = this.output = new Volume({\n\t\t\tcontext: this.context,\n\t\t\tvolume: options.volume,\n\t\t});\n\t\tthis.volume = this._volume.volume;\n\t\treadOnly(this, \"volume\");\n\t\tthis.mute = options.mute;\n\t}\n\n\tstatic getDefaults(): UserMediaOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tvolume: 0\n\t\t});\n\t}\n\n\t/**\n\t * Open the media stream. If a string is passed in, it is assumed\n\t * to be the label or id of the stream, if a number is passed in,\n\t * it is the input number of the stream.\n\t * @param  labelOrId The label or id of the audio input media device.\n\t *                   With no argument, the default stream is opened.\n\t * @return The promise is resolved when the stream is open.\n\t */\n\tasync open(labelOrId?: string | number): Promise<this> {\n\t\tassert(UserMedia.supported, \"UserMedia is not supported\");\n\t\t// close the previous stream\n\t\tif (this.state === \"started\") {\n\t\t\tthis.close();\n\t\t}\n\t\tconst devices = await UserMedia.enumerateDevices();\n\t\tif (isNumber(labelOrId)) {\n\t\t\tthis._device = devices[labelOrId];\n\t\t} else {\n\t\t\tthis._device = devices.find((device) => {\n\t\t\t\treturn device.label === labelOrId || device.deviceId === labelOrId;\n\t\t\t});\n\t\t\t// didn't find a matching device\n\t\t\tif (!this._device && devices.length > 0) {\n\t\t\t\tthis._device = devices[0];\n\t\t\t}\n\t\t\tassert(isDefined(this._device), `No matching device ${labelOrId}`);\n\t\t}\n\t\t// do getUserMedia\n\t\tconst constraints = {\n\t\t\taudio: {\n\t\t\t\techoCancellation: false,\n\t\t\t\tsampleRate: this.context.sampleRate,\n\t\t\t\tnoiseSuppression: false,\n\t\t\t\tmozNoiseSuppression: false,\n\t\t\t}\n\t\t};\n\t\tif (this._device) {\n\t\t\t// @ts-ignore\n\t\t\tconstraints.audio.deviceId = this._device.deviceId;\n\t\t}\n\t\tconst stream = await navigator.mediaDevices.getUserMedia(constraints);\n\t\t// start a new source only if the previous one is closed\n\t\tif (!this._stream) {\n\t\t\tthis._stream = stream;\n\t\t\t// Wrap a MediaStreamSourceNode around the live input stream.\n\t\t\tconst mediaStreamNode = this.context.createMediaStreamSource(stream);\n\t\t\t// Connect the MediaStreamSourceNode to a gate gain node\n\t\t\tconnect(mediaStreamNode, this.output);\n\t\t\tthis._mediaStream = mediaStreamNode;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Close the media stream\n\t */\n\tclose(): this {\n\t\tif (this._stream && this._mediaStream) {\n\t\t\tthis._stream.getAudioTracks().forEach((track) => {\n\t\t\t\ttrack.stop();\n\t\t\t});\n\t\t\tthis._stream = undefined;\n\t\t\t// remove the old media stream\n\t\t\tthis._mediaStream.disconnect();\n\t\t\tthis._mediaStream = undefined;\n\t\t}\n\t\tthis._device = undefined;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns a promise which resolves with the list of audio input devices available.\n\t * @return The promise that is resolved with the devices\n\t * @example\n\t * Tone.UserMedia.enumerateDevices().then((devices) => {\n\t * \t// print the device labels\n\t * \tconsole.log(devices.map(device => device.label));\n\t * });\n\t */\n\tstatic async enumerateDevices(): Promise<MediaDeviceInfo[]> {\n\t\tconst allDevices = await navigator.mediaDevices.enumerateDevices();\n\t\treturn allDevices.filter(device => {\n\t\t\treturn device.kind === \"audioinput\";\n\t\t});\n\t}\n\n\t/**\n\t * Returns the playback state of the source, \"started\" when the microphone is open\n\t * and \"stopped\" when the mic is closed.\n\t */\n\tget state() {\n\t\treturn this._stream && this._stream.active ? \"started\" : \"stopped\";\n\t}\n\n\t/**\n\t * Returns an identifier for the represented device that is\n\t * persisted across sessions. It is un-guessable by other applications and\n\t * unique to the origin of the calling application. It is reset when the\n\t * user clears cookies (for Private Browsing, a different identifier is\n\t * used that is not persisted across sessions). Returns undefined when the\n\t * device is not open.\n\t */\n\tget deviceId(): string | undefined {\n\t\tif (this._device) {\n\t\t\treturn this._device.deviceId;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Returns a group identifier. Two devices have the\n\t * same group identifier if they belong to the same physical device.\n\t * Returns null  when the device is not open.\n\t */\n\tget groupId(): string | undefined {\n\t\tif (this._device) {\n\t\t\treturn this._device.groupId;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Returns a label describing this device (for example \"Built-in Microphone\").\n\t * Returns undefined when the device is not open or label is not available\n\t * because of permissions.\n\t */\n\tget label(): string | undefined {\n\t\tif (this._device) {\n\t\t\treturn this._device.label;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * const mic = new Tone.UserMedia();\n\t * mic.open().then(() => {\n\t * \t// promise resolves when input is available\n\t * });\n\t * // mute the output\n\t * mic.mute = true;\n\t */\n\tget mute(): boolean {\n\t\treturn this._volume.mute;\n\t}\n\tset mute(mute) {\n\t\tthis._volume.mute = mute;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.close();\n\t\tthis._volume.dispose();\n\t\tthis.volume.dispose();\n\t\treturn this;\n\t}\n\n\t/**\n\t * If getUserMedia is supported by the browser.\n\t */\n\tstatic get supported(): boolean {\n\t\treturn isDefined(navigator.mediaDevices) &&\n\t\t\tisDefined(navigator.mediaDevices.getUserMedia);\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}