{"ast":null,"code":"import { Gain } from \"../core/context/Gain\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { noOp } from \"../core/util/Interface\";\nimport { assert } from \"../core/util/Debug\";\n/**\n * Base class for fire-and-forget nodes\n */\nexport class OneShotSource extends ToneAudioNode {\n  constructor(options) {\n    super(options);\n    /**\n     * The callback to invoke after the\n     * source is done playing.\n     */\n    this.onended = noOp;\n    /**\n     * The start time\n     */\n    this._startTime = -1;\n    /**\n     * The stop time\n     */\n    this._stopTime = -1;\n    /**\n     * The id of the timeout\n     */\n    this._timeout = -1;\n    /**\n     * The public output node\n     */\n    this.output = new Gain({\n      context: this.context,\n      gain: 0\n    });\n    /**\n     * The output gain node.\n     */\n    this._gainNode = this.output;\n    /**\n     * Get the playback state at the given time\n     */\n    this.getStateAtTime = function (time) {\n      const computedTime = this.toSeconds(time);\n      if (this._startTime !== -1 && computedTime >= this._startTime && (this._stopTime === -1 || computedTime <= this._stopTime)) {\n        return \"started\";\n      } else {\n        return \"stopped\";\n      }\n    };\n    this._fadeIn = options.fadeIn;\n    this._fadeOut = options.fadeOut;\n    this._curve = options.curve;\n    this.onended = options.onended;\n  }\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      curve: \"linear\",\n      fadeIn: 0,\n      fadeOut: 0,\n      onended: noOp\n    });\n  }\n  /**\n   * Start the source at the given time\n   * @param  time When to start the source\n   */\n  _startGain(time) {\n    let gain = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    assert(this._startTime === -1, \"Source cannot be started more than once\");\n    // apply a fade in envelope\n    const fadeInTime = this.toSeconds(this._fadeIn);\n    // record the start time\n    this._startTime = time + fadeInTime;\n    this._startTime = Math.max(this._startTime, this.context.currentTime);\n    // schedule the envelope\n    if (fadeInTime > 0) {\n      this._gainNode.gain.setValueAtTime(0, time);\n      if (this._curve === \"linear\") {\n        this._gainNode.gain.linearRampToValueAtTime(gain, time + fadeInTime);\n      } else {\n        this._gainNode.gain.exponentialApproachValueAtTime(gain, time, fadeInTime);\n      }\n    } else {\n      this._gainNode.gain.setValueAtTime(gain, time);\n    }\n    return this;\n  }\n  /**\n   * Stop the source node at the given time.\n   * @param time When to stop the source\n   */\n  stop(time) {\n    this.log(\"stop\", time);\n    this._stopGain(this.toSeconds(time));\n    return this;\n  }\n  /**\n   * Stop the source at the given time\n   * @param  time When to stop the source\n   */\n  _stopGain(time) {\n    assert(this._startTime !== -1, \"'start' must be called before 'stop'\");\n    // cancel the previous stop\n    this.cancelStop();\n    // the fadeOut time\n    const fadeOutTime = this.toSeconds(this._fadeOut);\n    // schedule the stop callback\n    this._stopTime = this.toSeconds(time) + fadeOutTime;\n    this._stopTime = Math.max(this._stopTime, this.context.currentTime);\n    if (fadeOutTime > 0) {\n      // start the fade out curve at the given time\n      if (this._curve === \"linear\") {\n        this._gainNode.gain.linearRampTo(0, fadeOutTime, time);\n      } else {\n        this._gainNode.gain.targetRampTo(0, fadeOutTime, time);\n      }\n    } else {\n      // stop any ongoing ramps, and set the value to 0\n      this._gainNode.gain.cancelAndHoldAtTime(time);\n      this._gainNode.gain.setValueAtTime(0, time);\n    }\n    this.context.clearTimeout(this._timeout);\n    this._timeout = this.context.setTimeout(() => {\n      // allow additional time for the exponential curve to fully decay\n      const additionalTail = this._curve === \"exponential\" ? fadeOutTime * 2 : 0;\n      this._stopSource(this.now() + additionalTail);\n      this._onended();\n    }, this._stopTime - this.context.currentTime);\n    return this;\n  }\n  /**\n   * Invoke the onended callback\n   */\n  _onended() {\n    if (this.onended !== noOp) {\n      this.onended(this);\n      // overwrite onended to make sure it only is called once\n      this.onended = noOp;\n      // dispose when it's ended to free up for garbage collection only in the online context\n      if (!this.context.isOffline) {\n        const disposeCallback = () => this.dispose();\n        // @ts-ignore\n        if (typeof window.requestIdleCallback !== \"undefined\") {\n          // @ts-ignore\n          window.requestIdleCallback(disposeCallback);\n        } else {\n          setTimeout(disposeCallback, 1000);\n        }\n      }\n    }\n  }\n  /**\n   * Get the playback state at the current time\n   */\n  get state() {\n    return this.getStateAtTime(this.now());\n  }\n  /**\n   * Cancel a scheduled stop event\n   */\n  cancelStop() {\n    this.log(\"cancelStop\");\n    assert(this._startTime !== -1, \"Source is not started\");\n    // cancel the stop envelope\n    this._gainNode.gain.cancelScheduledValues(this._startTime + this.sampleTime);\n    this.context.clearTimeout(this._timeout);\n    this._stopTime = -1;\n    return this;\n  }\n  dispose() {\n    super.dispose();\n    this._gainNode.disconnect();\n    return this;\n  }\n}","map":{"version":3,"names":["Gain","ToneAudioNode","noOp","assert","OneShotSource","constructor","options","onended","_startTime","_stopTime","_timeout","output","context","gain","_gainNode","getStateAtTime","time","computedTime","toSeconds","_fadeIn","fadeIn","_fadeOut","fadeOut","_curve","curve","getDefaults","Object","assign","_startGain","arguments","length","undefined","fadeInTime","Math","max","currentTime","setValueAtTime","linearRampToValueAtTime","exponentialApproachValueAtTime","stop","log","_stopGain","cancelStop","fadeOutTime","linearRampTo","targetRampTo","cancelAndHoldAtTime","clearTimeout","setTimeout","additionalTail","_stopSource","now","_onended","isOffline","disposeCallback","dispose","window","requestIdleCallback","state","cancelScheduledValues","sampleTime","disconnect"],"sources":["/Users/ianstrom/Development/code/Capstone/client/node_modules/tone/Tone/source/OneShotSource.ts"],"sourcesContent":["import { Gain } from \"../core/context/Gain\";\nimport {\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../core/context/ToneAudioNode\";\nimport { GainFactor, Seconds, Time } from \"../core/type/Units\";\nimport { noOp } from \"../core/util/Interface\";\nimport { assert } from \"../core/util/Debug\";\nimport { BasicPlaybackState } from \"../core/util/StateTimeline\";\n\nexport type OneShotSourceCurve = \"linear\" | \"exponential\";\n\ntype onEndedCallback = (source: OneShotSource<any>) => void;\n\nexport interface OneShotSourceOptions extends ToneAudioNodeOptions {\n\tonended: onEndedCallback;\n\tfadeIn: Time;\n\tfadeOut: Time;\n\tcurve: OneShotSourceCurve;\n}\n\n/**\n * Base class for fire-and-forget nodes\n */\nexport abstract class OneShotSource<\n\tOptions extends ToneAudioNodeOptions\n> extends ToneAudioNode<Options> {\n\t/**\n\t * The callback to invoke after the\n\t * source is done playing.\n\t */\n\tonended: onEndedCallback = noOp;\n\n\t/**\n\t * Sources do not have input nodes\n\t */\n\tinput: undefined;\n\n\t/**\n\t * The start time\n\t */\n\tprotected _startTime = -1;\n\n\t/**\n\t * The stop time\n\t */\n\tprotected _stopTime = -1;\n\n\t/**\n\t * The id of the timeout\n\t */\n\tprivate _timeout = -1;\n\n\t/**\n\t * The public output node\n\t */\n\toutput: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\n\t/**\n\t * The output gain node.\n\t */\n\tprotected _gainNode = this.output;\n\n\t/**\n\t * The fadeIn time of the amplitude envelope.\n\t */\n\tprotected _fadeIn: Time;\n\n\t/**\n\t * The fadeOut time of the amplitude envelope.\n\t */\n\tprotected _fadeOut: Time;\n\n\t/**\n\t * The curve applied to the fades, either \"linear\" or \"exponential\"\n\t */\n\tprotected _curve: OneShotSourceCurve;\n\n\tconstructor(options: OneShotSourceOptions) {\n\t\tsuper(options);\n\n\t\tthis._fadeIn = options.fadeIn;\n\t\tthis._fadeOut = options.fadeOut;\n\t\tthis._curve = options.curve;\n\t\tthis.onended = options.onended;\n\t}\n\n\tstatic getDefaults(): OneShotSourceOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tcurve: \"linear\" as OneShotSourceCurve,\n\t\t\tfadeIn: 0,\n\t\t\tfadeOut: 0,\n\t\t\tonended: noOp,\n\t\t});\n\t}\n\n\t/**\n\t * Stop the source node\n\t */\n\tprotected abstract _stopSource(time: Seconds): void;\n\n\t/**\n\t * Start the source node at the given time\n\t * @param  time When to start the node\n\t */\n\tprotected abstract start(time?: Time): this;\n\t/**\n\t * Start the source at the given time\n\t * @param  time When to start the source\n\t */\n\tprotected _startGain(time: Seconds, gain: GainFactor = 1): this {\n\t\tassert(\n\t\t\tthis._startTime === -1,\n\t\t\t\"Source cannot be started more than once\"\n\t\t);\n\t\t// apply a fade in envelope\n\t\tconst fadeInTime = this.toSeconds(this._fadeIn);\n\n\t\t// record the start time\n\t\tthis._startTime = time + fadeInTime;\n\t\tthis._startTime = Math.max(this._startTime, this.context.currentTime);\n\n\t\t// schedule the envelope\n\t\tif (fadeInTime > 0) {\n\t\t\tthis._gainNode.gain.setValueAtTime(0, time);\n\t\t\tif (this._curve === \"linear\") {\n\t\t\t\tthis._gainNode.gain.linearRampToValueAtTime(\n\t\t\t\t\tgain,\n\t\t\t\t\ttime + fadeInTime\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthis._gainNode.gain.exponentialApproachValueAtTime(\n\t\t\t\t\tgain,\n\t\t\t\t\ttime,\n\t\t\t\t\tfadeInTime\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._gainNode.gain.setValueAtTime(gain, time);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the source node at the given time.\n\t * @param time When to stop the source\n\t */\n\tstop(time?: Time): this {\n\t\tthis.log(\"stop\", time);\n\t\tthis._stopGain(this.toSeconds(time));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the source at the given time\n\t * @param  time When to stop the source\n\t */\n\tprotected _stopGain(time: Seconds): this {\n\t\tassert(this._startTime !== -1, \"'start' must be called before 'stop'\");\n\t\t// cancel the previous stop\n\t\tthis.cancelStop();\n\n\t\t// the fadeOut time\n\t\tconst fadeOutTime = this.toSeconds(this._fadeOut);\n\n\t\t// schedule the stop callback\n\t\tthis._stopTime = this.toSeconds(time) + fadeOutTime;\n\t\tthis._stopTime = Math.max(this._stopTime, this.context.currentTime);\n\t\tif (fadeOutTime > 0) {\n\t\t\t// start the fade out curve at the given time\n\t\t\tif (this._curve === \"linear\") {\n\t\t\t\tthis._gainNode.gain.linearRampTo(0, fadeOutTime, time);\n\t\t\t} else {\n\t\t\t\tthis._gainNode.gain.targetRampTo(0, fadeOutTime, time);\n\t\t\t}\n\t\t} else {\n\t\t\t// stop any ongoing ramps, and set the value to 0\n\t\t\tthis._gainNode.gain.cancelAndHoldAtTime(time);\n\t\t\tthis._gainNode.gain.setValueAtTime(0, time);\n\t\t}\n\t\tthis.context.clearTimeout(this._timeout);\n\t\tthis._timeout = this.context.setTimeout(() => {\n\t\t\t// allow additional time for the exponential curve to fully decay\n\t\t\tconst additionalTail =\n\t\t\t\tthis._curve === \"exponential\" ? fadeOutTime * 2 : 0;\n\t\t\tthis._stopSource(this.now() + additionalTail);\n\t\t\tthis._onended();\n\t\t}, this._stopTime - this.context.currentTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Invoke the onended callback\n\t */\n\tprotected _onended(): void {\n\t\tif (this.onended !== noOp) {\n\t\t\tthis.onended(this);\n\t\t\t// overwrite onended to make sure it only is called once\n\t\t\tthis.onended = noOp;\n\t\t\t// dispose when it's ended to free up for garbage collection only in the online context\n\t\t\tif (!this.context.isOffline) {\n\t\t\t\tconst disposeCallback = () => this.dispose();\n\t\t\t\t// @ts-ignore\n\t\t\t\tif (typeof window.requestIdleCallback !== \"undefined\") {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\twindow.requestIdleCallback(disposeCallback);\n\t\t\t\t} else {\n\t\t\t\t\tsetTimeout(disposeCallback, 1000);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the playback state at the given time\n\t */\n\tgetStateAtTime = function(time: Time): BasicPlaybackState {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (\n\t\t\tthis._startTime !== -1 &&\n\t\t\tcomputedTime >= this._startTime &&\n\t\t\t(this._stopTime === -1 || computedTime <= this._stopTime)\n\t\t) {\n\t\t\treturn \"started\";\n\t\t} else {\n\t\t\treturn \"stopped\";\n\t\t}\n\t};\n\n\t/**\n\t * Get the playback state at the current time\n\t */\n\tget state(): BasicPlaybackState {\n\t\treturn this.getStateAtTime(this.now());\n\t}\n\n\t/**\n\t * Cancel a scheduled stop event\n\t */\n\tcancelStop(): this {\n\t\tthis.log(\"cancelStop\");\n\t\tassert(this._startTime !== -1, \"Source is not started\");\n\t\t// cancel the stop envelope\n\t\tthis._gainNode.gain.cancelScheduledValues(\n\t\t\tthis._startTime + this.sampleTime\n\t\t);\n\t\tthis.context.clearTimeout(this._timeout);\n\t\tthis._stopTime = -1;\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._gainNode.disconnect();\n\t\treturn this;\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}