{"ast":null,"code":"export const createRenderInputsOfAudioNode = (getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle) => {\n  return async (audioNode, nativeOfflineAudioContext, nativeAudioNode) => {\n    const audioNodeConnections = getAudioNodeConnections(audioNode);\n    await Promise.all(audioNodeConnections.activeInputs.map((connections, input) => Array.from(connections).map(async _ref => {\n      let [source, output] = _ref;\n      const audioNodeRenderer = getAudioNodeRenderer(source);\n      const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext);\n      const destination = audioNode.context.destination;\n      if (!isPartOfACycle(source) && (audioNode !== destination || !isPartOfACycle(audioNode))) {\n        renderedNativeAudioNode.connect(nativeAudioNode, output, input);\n      }\n    })).reduce((allRenderingPromises, renderingPromises) => [...allRenderingPromises, ...renderingPromises], []));\n  };\n};","map":{"version":3,"names":["createRenderInputsOfAudioNode","getAudioNodeConnections","getAudioNodeRenderer","isPartOfACycle","audioNode","nativeOfflineAudioContext","nativeAudioNode","audioNodeConnections","Promise","all","activeInputs","map","connections","input","Array","from","_ref","source","output","audioNodeRenderer","renderedNativeAudioNode","render","destination","context","connect","reduce","allRenderingPromises","renderingPromises"],"sources":["/Users/ianstrom/Development/code/Capstone/client/node_modules/standardized-audio-context/src/factories/render-inputs-of-audio-node.ts"],"sourcesContent":["import { IAudioDestinationNode } from '../interfaces';\nimport { TRenderInputsOfAudioNodeFactory } from '../types';\n\nexport const createRenderInputsOfAudioNode: TRenderInputsOfAudioNodeFactory = (\n    getAudioNodeConnections,\n    getAudioNodeRenderer,\n    isPartOfACycle\n) => {\n    return async (audioNode, nativeOfflineAudioContext, nativeAudioNode) => {\n        const audioNodeConnections = getAudioNodeConnections(audioNode);\n\n        await Promise.all(\n            audioNodeConnections.activeInputs\n                .map((connections, input) =>\n                    Array.from(connections).map(async ([source, output]) => {\n                        const audioNodeRenderer = getAudioNodeRenderer(source);\n                        const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext);\n                        const destination = <IAudioDestinationNode<typeof audioNode.context>>audioNode.context.destination;\n\n                        if (!isPartOfACycle(source) && (audioNode !== destination || !isPartOfACycle(audioNode))) {\n                            renderedNativeAudioNode.connect(nativeAudioNode, output, input);\n                        }\n                    })\n                )\n                .reduce((allRenderingPromises, renderingPromises) => [...allRenderingPromises, ...renderingPromises], [])\n        );\n    };\n};\n"],"mappings":"AAGA,OAAO,MAAMA,6BAA6B,GAAoCA,CAC1EC,uBAAuB,EACvBC,oBAAoB,EACpBC,cAAc,KACd;EACA,OAAO,OAAOC,SAAS,EAAEC,yBAAyB,EAAEC,eAAe,KAAI;IACnE,MAAMC,oBAAoB,GAAGN,uBAAuB,CAACG,SAAS,CAAC;IAE/D,MAAMI,OAAO,CAACC,GAAG,CACbF,oBAAoB,CAACG,YAAY,CAC5BC,GAAG,CAAC,CAACC,WAAW,EAAEC,KAAK,KACpBC,KAAK,CAACC,IAAI,CAACH,WAAW,CAAC,CAACD,GAAG,CAAC,MAAAK,IAAA,IAA2B;MAAA,IAApB,CAACC,MAAM,EAAEC,MAAM,CAAC,GAAAF,IAAA;MAC/C,MAAMG,iBAAiB,GAAGjB,oBAAoB,CAACe,MAAM,CAAC;MACtD,MAAMG,uBAAuB,GAAG,MAAMD,iBAAiB,CAACE,MAAM,CAACJ,MAAM,EAAEZ,yBAAyB,CAAC;MACjG,MAAMiB,WAAW,GAAoDlB,SAAS,CAACmB,OAAO,CAACD,WAAW;MAElG,IAAI,CAACnB,cAAc,CAACc,MAAM,CAAC,KAAKb,SAAS,KAAKkB,WAAW,IAAI,CAACnB,cAAc,CAACC,SAAS,CAAC,CAAC,EAAE;QACtFgB,uBAAuB,CAACI,OAAO,CAAClB,eAAe,EAAEY,MAAM,EAAEL,KAAK,CAAC;;IAEvE,CAAC,CAAC,CACL,CACAY,MAAM,CAAC,CAACC,oBAAoB,EAAEC,iBAAiB,KAAK,CAAC,GAAGD,oBAAoB,EAAE,GAAGC,iBAAiB,CAAC,EAAE,EAAE,CAAC,CAChH;EACL,CAAC;AACL,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}