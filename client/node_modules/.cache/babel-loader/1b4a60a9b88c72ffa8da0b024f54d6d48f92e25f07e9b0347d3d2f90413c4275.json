{"ast":null,"code":"import { ToneWithContext } from \"../context/ToneWithContext\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { noOp, readOnly } from \"../util/Interface\";\nimport { StateTimeline } from \"../util/StateTimeline\";\nimport { TickSource } from \"./TickSource\";\nimport { assertContextRunning } from \"../util/Debug\";\n/**\n * A sample accurate clock which provides a callback at the given rate.\n * While the callback is not sample-accurate (it is still susceptible to\n * loose JS timing), the time passed in as the argument to the callback\n * is precise. For most applications, it is better to use Tone.Transport\n * instead of the Clock by itself since you can synchronize multiple callbacks.\n * @example\n * // the callback will be invoked approximately once a second\n * // and will print the time exactly once a second apart.\n * const clock = new Tone.Clock(time => {\n * \tconsole.log(time);\n * }, 1);\n * clock.start();\n * @category Core\n */\nexport class Clock extends ToneWithContext {\n  constructor() {\n    super(optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]));\n    this.name = \"Clock\";\n    /**\n     * The callback function to invoke at the scheduled tick.\n     */\n    this.callback = noOp;\n    /**\n     * The last time the loop callback was invoked\n     */\n    this._lastUpdate = 0;\n    /**\n     * Keep track of the playback state\n     */\n    this._state = new StateTimeline(\"stopped\");\n    /**\n     * Context bound reference to the _loop method\n     * This is necessary to remove the event in the end.\n     */\n    this._boundLoop = this._loop.bind(this);\n    const options = optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]);\n    this.callback = options.callback;\n    this._tickSource = new TickSource({\n      context: this.context,\n      frequency: options.frequency,\n      units: options.units\n    });\n    this._lastUpdate = 0;\n    this.frequency = this._tickSource.frequency;\n    readOnly(this, \"frequency\");\n    // add an initial state\n    this._state.setStateAtTime(\"stopped\", 0);\n    // bind a callback to the worker thread\n    this.context.on(\"tick\", this._boundLoop);\n  }\n  static getDefaults() {\n    return Object.assign(ToneWithContext.getDefaults(), {\n      callback: noOp,\n      frequency: 1,\n      units: \"hertz\"\n    });\n  }\n  /**\n   * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n   */\n  get state() {\n    return this._state.getValueAtTime(this.now());\n  }\n  /**\n   * Start the clock at the given time. Optionally pass in an offset\n   * of where to start the tick counter from.\n   * @param  time    The time the clock should start\n   * @param offset  Where the tick counter starts counting from.\n   */\n  start(time, offset) {\n    // make sure the context is running\n    assertContextRunning(this.context);\n    // start the loop\n    const computedTime = this.toSeconds(time);\n    this.log(\"start\", computedTime);\n    if (this._state.getValueAtTime(computedTime) !== \"started\") {\n      this._state.setStateAtTime(\"started\", computedTime);\n      this._tickSource.start(computedTime, offset);\n      if (computedTime < this._lastUpdate) {\n        this.emit(\"start\", computedTime, offset);\n      }\n    }\n    return this;\n  }\n  /**\n   * Stop the clock. Stopping the clock resets the tick counter to 0.\n   * @param time The time when the clock should stop.\n   * @example\n   * const clock = new Tone.Clock(time => {\n   * \tconsole.log(time);\n   * }, 1);\n   * clock.start();\n   * // stop the clock after 10 seconds\n   * clock.stop(\"+10\");\n   */\n  stop(time) {\n    const computedTime = this.toSeconds(time);\n    this.log(\"stop\", computedTime);\n    this._state.cancel(computedTime);\n    this._state.setStateAtTime(\"stopped\", computedTime);\n    this._tickSource.stop(computedTime);\n    if (computedTime < this._lastUpdate) {\n      this.emit(\"stop\", computedTime);\n    }\n    return this;\n  }\n  /**\n   * Pause the clock. Pausing does not reset the tick counter.\n   * @param time The time when the clock should stop.\n   */\n  pause(time) {\n    const computedTime = this.toSeconds(time);\n    if (this._state.getValueAtTime(computedTime) === \"started\") {\n      this._state.setStateAtTime(\"paused\", computedTime);\n      this._tickSource.pause(computedTime);\n      if (computedTime < this._lastUpdate) {\n        this.emit(\"pause\", computedTime);\n      }\n    }\n    return this;\n  }\n  /**\n   * The number of times the callback was invoked. Starts counting at 0\n   * and increments after the callback was invoked.\n   */\n  get ticks() {\n    return Math.ceil(this.getTicksAtTime(this.now()));\n  }\n  set ticks(t) {\n    this._tickSource.ticks = t;\n  }\n  /**\n   * The time since ticks=0 that the Clock has been running. Accounts for tempo curves\n   */\n  get seconds() {\n    return this._tickSource.seconds;\n  }\n  set seconds(s) {\n    this._tickSource.seconds = s;\n  }\n  /**\n   * Return the elapsed seconds at the given time.\n   * @param  time  When to get the elapsed seconds\n   * @return  The number of elapsed seconds\n   */\n  getSecondsAtTime(time) {\n    return this._tickSource.getSecondsAtTime(time);\n  }\n  /**\n   * Set the clock's ticks at the given time.\n   * @param  ticks The tick value to set\n   * @param  time  When to set the tick value\n   */\n  setTicksAtTime(ticks, time) {\n    this._tickSource.setTicksAtTime(ticks, time);\n    return this;\n  }\n  /**\n   * Get the time of the given tick. The second argument\n   * is when to test before. Since ticks can be set (with setTicksAtTime)\n   * there may be multiple times for a given tick value.\n   * @param  tick The tick number.\n   * @param  before When to measure the tick value from.\n   * @return The time of the tick\n   */\n  getTimeOfTick(tick) {\n    let before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.now();\n    return this._tickSource.getTimeOfTick(tick, before);\n  }\n  /**\n   * Get the clock's ticks at the given time.\n   * @param  time  When to get the tick value\n   * @return The tick value at the given time.\n   */\n  getTicksAtTime(time) {\n    return this._tickSource.getTicksAtTime(time);\n  }\n  /**\n   * Get the time of the next tick\n   * @param  offset The tick number.\n   */\n  nextTickTime(offset, when) {\n    const computedTime = this.toSeconds(when);\n    const currentTick = this.getTicksAtTime(computedTime);\n    return this._tickSource.getTimeOfTick(currentTick + offset, computedTime);\n  }\n  /**\n   * The scheduling loop.\n   */\n  _loop() {\n    const startTime = this._lastUpdate;\n    const endTime = this.now();\n    this._lastUpdate = endTime;\n    this.log(\"loop\", startTime, endTime);\n    if (startTime !== endTime) {\n      // the state change events\n      this._state.forEachBetween(startTime, endTime, e => {\n        switch (e.state) {\n          case \"started\":\n            const offset = this._tickSource.getTicksAtTime(e.time);\n            this.emit(\"start\", e.time, offset);\n            break;\n          case \"stopped\":\n            if (e.time !== 0) {\n              this.emit(\"stop\", e.time);\n            }\n            break;\n          case \"paused\":\n            this.emit(\"pause\", e.time);\n            break;\n        }\n      });\n      // the tick callbacks\n      this._tickSource.forEachTickBetween(startTime, endTime, (time, ticks) => {\n        this.callback(time, ticks);\n      });\n    }\n  }\n  /**\n   * Returns the scheduled state at the given time.\n   * @param  time  The time to query.\n   * @return  The name of the state input in setStateAtTime.\n   * @example\n   * const clock = new Tone.Clock();\n   * clock.start(\"+0.1\");\n   * clock.getStateAtTime(\"+0.1\"); // returns \"started\"\n   */\n  getStateAtTime(time) {\n    const computedTime = this.toSeconds(time);\n    return this._state.getValueAtTime(computedTime);\n  }\n  /**\n   * Clean up\n   */\n  dispose() {\n    super.dispose();\n    this.context.off(\"tick\", this._boundLoop);\n    this._tickSource.dispose();\n    this._state.dispose();\n    return this;\n  }\n}\nEmitter.mixin(Clock);","map":{"version":3,"names":["ToneWithContext","optionsFromArguments","Emitter","noOp","readOnly","StateTimeline","TickSource","assertContextRunning","Clock","constructor","getDefaults","arguments","name","callback","_lastUpdate","_state","_boundLoop","_loop","bind","options","_tickSource","context","frequency","units","setStateAtTime","on","Object","assign","state","getValueAtTime","now","start","time","offset","computedTime","toSeconds","log","emit","stop","cancel","pause","ticks","Math","ceil","getTicksAtTime","t","seconds","s","getSecondsAtTime","setTicksAtTime","getTimeOfTick","tick","before","length","undefined","nextTickTime","when","currentTick","startTime","endTime","forEachBetween","e","forEachTickBetween","getStateAtTime","dispose","off","mixin"],"sources":["/Users/ianstrom/Development/code/Capstone/node_modules/tone/Tone/core/clock/Clock.ts"],"sourcesContent":["import { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { Frequency, Hertz, Seconds, Ticks, Time } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { noOp, readOnly } from \"../util/Interface\";\nimport { PlaybackState, StateTimeline } from \"../util/StateTimeline\";\nimport { TickSignal } from \"./TickSignal\";\nimport { TickSource } from \"./TickSource\";\nimport { assertContextRunning } from \"../util/Debug\";\n\ntype ClockCallback = (time: Seconds, ticks?: Ticks) => void;\n\ninterface ClockOptions extends ToneWithContextOptions {\n\tfrequency: Hertz;\n\tcallback: ClockCallback;\n\tunits: \"hertz\" | \"bpm\";\n}\n\ntype ClockEvent = \"start\" | \"stop\" | \"pause\";\n\n/**\n * A sample accurate clock which provides a callback at the given rate.\n * While the callback is not sample-accurate (it is still susceptible to\n * loose JS timing), the time passed in as the argument to the callback\n * is precise. For most applications, it is better to use Tone.Transport\n * instead of the Clock by itself since you can synchronize multiple callbacks.\n * @example\n * // the callback will be invoked approximately once a second\n * // and will print the time exactly once a second apart.\n * const clock = new Tone.Clock(time => {\n * \tconsole.log(time);\n * }, 1);\n * clock.start();\n * @category Core\n */\nexport class Clock<TypeName extends \"bpm\" | \"hertz\" = \"hertz\">\n\textends ToneWithContext<ClockOptions> implements Emitter<ClockEvent> {\n\n\treadonly name: string = \"Clock\";\n\n\t/**\n\t * The callback function to invoke at the scheduled tick.\n\t */\n\tcallback: ClockCallback = noOp;\n\n\t/**\n\t * The tick counter\n\t */\n\tprivate _tickSource: TickSource<TypeName>;\n\n\t/**\n\t * The last time the loop callback was invoked\n\t */\n\tprivate _lastUpdate = 0;\n\n\t/**\n\t * Keep track of the playback state\n\t */\n\tprivate _state: StateTimeline = new StateTimeline(\"stopped\");\n\n\t/**\n\t * Context bound reference to the _loop method\n\t * This is necessary to remove the event in the end.\n\t */\n\tprivate _boundLoop: () => void = this._loop.bind(this);\n\n\t/**\n\t * The rate the callback function should be invoked.\n\t */\n\tfrequency: TickSignal<TypeName>;\n\n\t/**\n\t * @param callback The callback to be invoked with the time of the audio event\n\t * @param frequency The rate of the callback\n\t */\n\tconstructor(callback?: ClockCallback, frequency?: Frequency);\n\tconstructor(options: Partial<ClockOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]));\n\t\tconst options = optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]);\n\n\t\tthis.callback = options.callback;\n\t\tthis._tickSource = new TickSource({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency,\n\t\t\tunits: options.units,\n\t\t});\n\t\tthis._lastUpdate = 0;\n\t\tthis.frequency = this._tickSource.frequency;\n\t\treadOnly(this, \"frequency\");\n\n\t\t// add an initial state\n\t\tthis._state.setStateAtTime(\"stopped\", 0);\n\n\t\t// bind a callback to the worker thread\n\t\tthis.context.on(\"tick\", this._boundLoop);\n\t}\n\n\tstatic getDefaults(): ClockOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tcallback: noOp as ClockCallback,\n\t\t\tfrequency: 1,\n\t\t\tunits: \"hertz\",\n\t\t}) as ClockOptions;\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n\t */\n\tget state(): PlaybackState {\n\t\treturn this._state.getValueAtTime(this.now());\n\t}\n\n\t/**\n\t * Start the clock at the given time. Optionally pass in an offset\n\t * of where to start the tick counter from.\n\t * @param  time    The time the clock should start\n\t * @param offset  Where the tick counter starts counting from.\n\t */\n\tstart(time?: Time, offset?: Ticks): this {\n\t\t// make sure the context is running\n\t\tassertContextRunning(this.context);\n\t\t// start the loop\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"start\", computedTime);\n\t\tif (this._state.getValueAtTime(computedTime) !== \"started\") {\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tthis._tickSource.start(computedTime, offset);\n\t\t\tif (computedTime < this._lastUpdate) {\n\t\t\t\tthis.emit(\"start\", computedTime, offset);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the clock. Stopping the clock resets the tick counter to 0.\n\t * @param time The time when the clock should stop.\n\t * @example\n\t * const clock = new Tone.Clock(time => {\n\t * \tconsole.log(time);\n\t * }, 1);\n\t * clock.start();\n\t * // stop the clock after 10 seconds\n\t * clock.stop(\"+10\");\n\t */\n\tstop(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"stop\", computedTime);\n\t\tthis._state.cancel(computedTime);\n\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\tthis._tickSource.stop(computedTime);\n\t\tif (computedTime < this._lastUpdate) {\n\t\t\tthis.emit(\"stop\", computedTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Pause the clock. Pausing does not reset the tick counter.\n\t * @param time The time when the clock should stop.\n\t */\n\tpause(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"paused\", computedTime);\n\t\t\tthis._tickSource.pause(computedTime);\n\t\t\tif (computedTime < this._lastUpdate) {\n\t\t\t\tthis.emit(\"pause\", computedTime);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * The number of times the callback was invoked. Starts counting at 0\n\t * and increments after the callback was invoked.\n\t */\n\tget ticks(): Ticks {\n\t\treturn Math.ceil(this.getTicksAtTime(this.now()));\n\t}\n\tset ticks(t: Ticks) {\n\t\tthis._tickSource.ticks = t;\n\t}\n\n\t/**\n\t * The time since ticks=0 that the Clock has been running. Accounts for tempo curves\n\t */\n\tget seconds(): Seconds {\n\t\treturn this._tickSource.seconds;\n\t}\n\tset seconds(s: Seconds) {\n\t\tthis._tickSource.seconds = s;\n\t}\n\n\t/**\n\t * Return the elapsed seconds at the given time.\n\t * @param  time  When to get the elapsed seconds\n\t * @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\treturn this._tickSource.getSecondsAtTime(time);\n\t}\n\n\t/**\n\t * Set the clock's ticks at the given time.\n\t * @param  ticks The tick value to set\n\t * @param  time  When to set the tick value\n\t */\n\tsetTicksAtTime(ticks: Ticks, time: Time): this {\n\t\tthis._tickSource.setTicksAtTime(ticks, time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the time of the given tick. The second argument\n\t * is when to test before. Since ticks can be set (with setTicksAtTime)\n\t * there may be multiple times for a given tick value.\n\t * @param  tick The tick number.\n\t * @param  before When to measure the tick value from.\n\t * @return The time of the tick\n\t */\n\tgetTimeOfTick(tick: Ticks, before = this.now()): Seconds {\n\t\treturn this._tickSource.getTimeOfTick(tick, before);\n\t}\n\n\t/**\n\t * Get the clock's ticks at the given time.\n\t * @param  time  When to get the tick value\n\t * @return The tick value at the given time.\n\t */\n\tgetTicksAtTime(time?: Time): Ticks {\n\t\treturn this._tickSource.getTicksAtTime(time);\n\t}\n\n\t/**\n\t * Get the time of the next tick\n\t * @param  offset The tick number.\n\t */\n\tnextTickTime(offset: Ticks, when: Time): Seconds {\n\t\tconst computedTime = this.toSeconds(when);\n\t\tconst currentTick = this.getTicksAtTime(computedTime);\n\t\treturn this._tickSource.getTimeOfTick(currentTick + offset, computedTime);\n\t}\n\n\t/**\n\t * The scheduling loop.\n\t */\n\tprivate _loop(): void {\n\n\t\tconst startTime = this._lastUpdate;\n\t\tconst endTime = this.now();\n\t\tthis._lastUpdate = endTime;\n\t\tthis.log(\"loop\", startTime, endTime);\n\n\t\tif (startTime !== endTime) {\n\t\t\t// the state change events\n\t\t\tthis._state.forEachBetween(startTime, endTime, e => {\n\t\t\t\tswitch (e.state) {\n\t\t\t\t\tcase \"started\":\n\t\t\t\t\t\tconst offset = this._tickSource.getTicksAtTime(e.time);\n\t\t\t\t\t\tthis.emit(\"start\", e.time, offset);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"stopped\":\n\t\t\t\t\t\tif (e.time !== 0) {\n\t\t\t\t\t\t\tthis.emit(\"stop\", e.time);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"paused\":\n\t\t\t\t\t\tthis.emit(\"pause\", e.time);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t});\n\t\t\t// the tick callbacks\n\t\t\tthis._tickSource.forEachTickBetween(startTime, endTime, (time, ticks) => {\n\t\t\t\tthis.callback(time, ticks);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Returns the scheduled state at the given time.\n\t * @param  time  The time to query.\n\t * @return  The name of the state input in setStateAtTime.\n\t * @example\n\t * const clock = new Tone.Clock();\n\t * clock.start(\"+0.1\");\n\t * clock.getStateAtTime(\"+0.1\"); // returns \"started\"\n\t */\n\tgetStateAtTime(time: Time): PlaybackState {\n\t\tconst computedTime = this.toSeconds(time);\n\t\treturn this._state.getValueAtTime(computedTime);\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.context.off(\"tick\", this._boundLoop);\n\t\tthis._tickSource.dispose();\n\t\tthis._state.dispose();\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// EMITTER MIXIN TO SATISFY COMPILER\n\t//-------------------------------------\n\n\ton!: (event: ClockEvent, callback: (...args: any[]) => void) => this;\n\tonce!: (event: ClockEvent, callback: (...args: any[]) => void) => this;\n\toff!: (event: ClockEvent, callback?: ((...args: any[]) => void) | undefined) => this;\n\temit!: (event: any, ...args: any[]) => this;\n}\n\nEmitter.mixin(Clock);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}