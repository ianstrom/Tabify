{"ast":null,"code":"import { Volume } from \"../component/channel/Volume\";\nimport \"../core/context/Destination\";\nimport \"../core/clock/Transport\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { defaultArg } from \"../core/util/Defaults\";\nimport { noOp, readOnly } from \"../core/util/Interface\";\nimport { StateTimeline } from \"../core/util/StateTimeline\";\nimport { isDefined, isUndef } from \"../core/util/TypeCheck\";\nimport { assert, assertContextRunning } from \"../core/util/Debug\";\nimport { GT } from \"../core/util/Math\";\n/**\n * Base class for sources.\n * start/stop of this.context.transport.\n *\n * ```\n * // Multiple state change events can be chained together,\n * // but must be set in the correct order and with ascending times\n * // OK\n * state.start().stop(\"+0.2\");\n * // OK\n * state.start().stop(\"+0.2\").start(\"+0.4\").stop(\"+0.7\")\n * // BAD\n * state.stop(\"+0.2\").start();\n * // BAD\n * state.start(\"+0.3\").stop(\"+0.2\");\n * ```\n */\nexport class Source extends ToneAudioNode {\n  constructor(options) {\n    super(options);\n    /**\n     * Sources have no inputs\n     */\n    this.input = undefined;\n    /**\n     * Keep track of the scheduled state.\n     */\n    this._state = new StateTimeline(\"stopped\");\n    /**\n     * The synced `start` callback function from the transport\n     */\n    this._synced = false;\n    /**\n     * Keep track of all of the scheduled event ids\n     */\n    this._scheduled = [];\n    /**\n     * Placeholder functions for syncing/unsyncing to transport\n     */\n    this._syncedStart = noOp;\n    this._syncedStop = noOp;\n    this._state.memory = 100;\n    this._state.increasing = true;\n    this._volume = this.output = new Volume({\n      context: this.context,\n      mute: options.mute,\n      volume: options.volume\n    });\n    this.volume = this._volume.volume;\n    readOnly(this, \"volume\");\n    this.onstop = options.onstop;\n  }\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      mute: false,\n      onstop: noOp,\n      volume: 0\n    });\n  }\n  /**\n   * Returns the playback state of the source, either \"started\" or \"stopped\".\n   * @example\n   * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/ahntone_c3.mp3\", () => {\n   * \tplayer.start();\n   * \tconsole.log(player.state);\n   * }).toDestination();\n   */\n  get state() {\n    if (this._synced) {\n      if (this.context.transport.state === \"started\") {\n        return this._state.getValueAtTime(this.context.transport.seconds);\n      } else {\n        return \"stopped\";\n      }\n    } else {\n      return this._state.getValueAtTime(this.now());\n    }\n  }\n  /**\n   * Mute the output.\n   * @example\n   * const osc = new Tone.Oscillator().toDestination().start();\n   * // mute the output\n   * osc.mute = true;\n   */\n  get mute() {\n    return this._volume.mute;\n  }\n  set mute(mute) {\n    this._volume.mute = mute;\n  }\n  /**\n   * Ensure that the scheduled time is not before the current time.\n   * Should only be used when scheduled unsynced.\n   */\n  _clampToCurrentTime(time) {\n    if (this._synced) {\n      return time;\n    } else {\n      return Math.max(time, this.context.currentTime);\n    }\n  }\n  /**\n   * Start the source at the specified time. If no time is given,\n   * start the source now.\n   * @param  time When the source should be started.\n   * @example\n   * const source = new Tone.Oscillator().toDestination();\n   * source.start(\"+0.5\"); // starts the source 0.5 seconds from now\n   */\n  start(time, offset, duration) {\n    let computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n    computedTime = this._clampToCurrentTime(computedTime);\n    // if it's started, stop it and restart it\n    if (!this._synced && this._state.getValueAtTime(computedTime) === \"started\") {\n      // time should be strictly greater than the previous start time\n      assert(GT(computedTime, this._state.get(computedTime).time), \"Start time must be strictly greater than previous start time\");\n      this._state.cancel(computedTime);\n      this._state.setStateAtTime(\"started\", computedTime);\n      this.log(\"restart\", computedTime);\n      this.restart(computedTime, offset, duration);\n    } else {\n      this.log(\"start\", computedTime);\n      this._state.setStateAtTime(\"started\", computedTime);\n      if (this._synced) {\n        // add the offset time to the event\n        const event = this._state.get(computedTime);\n        if (event) {\n          event.offset = this.toSeconds(defaultArg(offset, 0));\n          event.duration = duration ? this.toSeconds(duration) : undefined;\n        }\n        const sched = this.context.transport.schedule(t => {\n          this._start(t, offset, duration);\n        }, computedTime);\n        this._scheduled.push(sched);\n        // if the transport is already started\n        // and the time is greater than where the transport is\n        if (this.context.transport.state === \"started\" && this.context.transport.getSecondsAtTime(this.immediate()) > computedTime) {\n          this._syncedStart(this.now(), this.context.transport.seconds);\n        }\n      } else {\n        assertContextRunning(this.context);\n        this._start(computedTime, offset, duration);\n      }\n    }\n    return this;\n  }\n  /**\n   * Stop the source at the specified time. If no time is given,\n   * stop the source now.\n   * @param  time When the source should be stopped.\n   * @example\n   * const source = new Tone.Oscillator().toDestination();\n   * source.start();\n   * source.stop(\"+0.5\"); // stops the source 0.5 seconds from now\n   */\n  stop(time) {\n    let computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n    computedTime = this._clampToCurrentTime(computedTime);\n    if (this._state.getValueAtTime(computedTime) === \"started\" || isDefined(this._state.getNextState(\"started\", computedTime))) {\n      this.log(\"stop\", computedTime);\n      if (!this._synced) {\n        this._stop(computedTime);\n      } else {\n        const sched = this.context.transport.schedule(this._stop.bind(this), computedTime);\n        this._scheduled.push(sched);\n      }\n      this._state.cancel(computedTime);\n      this._state.setStateAtTime(\"stopped\", computedTime);\n    }\n    return this;\n  }\n  /**\n   * Restart the source.\n   */\n  restart(time, offset, duration) {\n    time = this.toSeconds(time);\n    if (this._state.getValueAtTime(time) === \"started\") {\n      this._state.cancel(time);\n      this._restart(time, offset, duration);\n    }\n    return this;\n  }\n  /**\n   * Sync the source to the Transport so that all subsequent\n   * calls to `start` and `stop` are synced to the TransportTime\n   * instead of the AudioContext time.\n   *\n   * @example\n   * const osc = new Tone.Oscillator().toDestination();\n   * // sync the source so that it plays between 0 and 0.3 on the Transport's timeline\n   * osc.sync().start(0).stop(0.3);\n   * // start the transport.\n   * Tone.Transport.start();\n   * // set it to loop once a second\n   * Tone.Transport.loop = true;\n   * Tone.Transport.loopEnd = 1;\n   */\n  sync() {\n    if (!this._synced) {\n      this._synced = true;\n      this._syncedStart = (time, offset) => {\n        if (offset > 0) {\n          // get the playback state at that time\n          const stateEvent = this._state.get(offset);\n          // listen for start events which may occur in the middle of the sync'ed time\n          if (stateEvent && stateEvent.state === \"started\" && stateEvent.time !== offset) {\n            // get the offset\n            const startOffset = offset - this.toSeconds(stateEvent.time);\n            let duration;\n            if (stateEvent.duration) {\n              duration = this.toSeconds(stateEvent.duration) - startOffset;\n            }\n            this._start(time, this.toSeconds(stateEvent.offset) + startOffset, duration);\n          }\n        }\n      };\n      this._syncedStop = time => {\n        const seconds = this.context.transport.getSecondsAtTime(Math.max(time - this.sampleTime, 0));\n        if (this._state.getValueAtTime(seconds) === \"started\") {\n          this._stop(time);\n        }\n      };\n      this.context.transport.on(\"start\", this._syncedStart);\n      this.context.transport.on(\"loopStart\", this._syncedStart);\n      this.context.transport.on(\"stop\", this._syncedStop);\n      this.context.transport.on(\"pause\", this._syncedStop);\n      this.context.transport.on(\"loopEnd\", this._syncedStop);\n    }\n    return this;\n  }\n  /**\n   * Unsync the source to the Transport. See Source.sync\n   */\n  unsync() {\n    if (this._synced) {\n      this.context.transport.off(\"stop\", this._syncedStop);\n      this.context.transport.off(\"pause\", this._syncedStop);\n      this.context.transport.off(\"loopEnd\", this._syncedStop);\n      this.context.transport.off(\"start\", this._syncedStart);\n      this.context.transport.off(\"loopStart\", this._syncedStart);\n    }\n    this._synced = false;\n    // clear all of the scheduled ids\n    this._scheduled.forEach(id => this.context.transport.clear(id));\n    this._scheduled = [];\n    this._state.cancel(0);\n    // stop it also\n    this._stop(0);\n    return this;\n  }\n  /**\n   * Clean up.\n   */\n  dispose() {\n    super.dispose();\n    this.onstop = noOp;\n    this.unsync();\n    this._volume.dispose();\n    this._state.dispose();\n    return this;\n  }\n}","map":{"version":3,"names":["Volume","ToneAudioNode","defaultArg","noOp","readOnly","StateTimeline","isDefined","isUndef","assert","assertContextRunning","GT","Source","constructor","options","input","undefined","_state","_synced","_scheduled","_syncedStart","_syncedStop","memory","increasing","_volume","output","context","mute","volume","onstop","getDefaults","Object","assign","state","transport","getValueAtTime","seconds","now","_clampToCurrentTime","time","Math","max","currentTime","start","offset","duration","computedTime","toSeconds","get","cancel","setStateAtTime","log","restart","event","sched","schedule","t","_start","push","getSecondsAtTime","immediate","stop","getNextState","_stop","bind","_restart","sync","stateEvent","startOffset","sampleTime","on","unsync","off","forEach","id","clear","dispose"],"sources":["/Users/ianstrom/Development/code/Capstone/node_modules/tone/Tone/source/Source.ts"],"sourcesContent":["import { Volume } from \"../component/channel/Volume\";\nimport \"../core/context/Destination\";\nimport \"../core/clock/Transport\";\nimport { Param } from \"../core/context/Param\";\nimport { OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { Decibels, Seconds, Time } from \"../core/type/Units\";\nimport { defaultArg } from \"../core/util/Defaults\";\nimport { noOp, readOnly } from \"../core/util/Interface\";\nimport { BasicPlaybackState, StateTimeline, StateTimelineEvent } from \"../core/util/StateTimeline\";\nimport { isDefined, isUndef } from \"../core/util/TypeCheck\";\nimport { assert, assertContextRunning } from \"../core/util/Debug\";\nimport { GT } from \"../core/util/Math\";\n\ntype onStopCallback = (source: Source<any>) => void;\n\nexport interface SourceOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n\tmute: boolean;\n\tonstop: onStopCallback;\n}\n\n/**\n * Base class for sources. \n * start/stop of this.context.transport.\n * \n * ```\n * // Multiple state change events can be chained together,\n * // but must be set in the correct order and with ascending times\n * // OK\n * state.start().stop(\"+0.2\");\n * // OK\n * state.start().stop(\"+0.2\").start(\"+0.4\").stop(\"+0.7\")\n * // BAD\n * state.stop(\"+0.2\").start();\n * // BAD\n * state.start(\"+0.3\").stop(\"+0.2\");\n * ```\n */\nexport abstract class Source<Options extends SourceOptions> extends ToneAudioNode<Options> {\n\n\t/**\n\t * The output volume node\n\t */\n\tprivate _volume: Volume;\n\n\t/**\n\t * The output note\n\t */\n\toutput: OutputNode;\n\n\t/**\n\t * Sources have no inputs\n\t */\n\tinput = undefined;\n\n\t/**\n\t * The volume of the output in decibels.\n\t * @example\n\t * const source = new Tone.PWMOscillator().toDestination();\n\t * source.volume.value = -6;\n\t */\n\tvolume: Param<\"decibels\">;\n\n\t/**\n\t * The callback to invoke when the source is stopped.\n\t */\n\tonstop: onStopCallback;\n\n\t/**\n\t * Keep track of the scheduled state.\n\t */\n\tprotected _state: StateTimeline<{\n\t\tduration?: Seconds;\n\t\toffset?: Seconds;\n\t\t/**\n\t\t * Either the buffer is explicitly scheduled to end using the stop method,\n\t\t * or it's implicitly ended when the buffer is over.\n\t\t */\n\t\timplicitEnd?: boolean;\n\t}> = new StateTimeline(\"stopped\");\n\n\t/**\n\t * The synced `start` callback function from the transport\n\t */\n\tprotected _synced = false;\n\n\t/**\n\t * Keep track of all of the scheduled event ids\n\t */\n\tprivate _scheduled: number[] = [];\n\n\t/**\n\t * Placeholder functions for syncing/unsyncing to transport\n\t */\n\tprivate _syncedStart: (time: Seconds, offset: Seconds) => void = noOp;\n\tprivate _syncedStop: (time: Seconds) => void = noOp;\n\n\tconstructor(options: SourceOptions) {\n\t\tsuper(options);\n\t\tthis._state.memory = 100;\n\t\tthis._state.increasing = true;\n\n\t\tthis._volume = this.output = new Volume({\n\t\t\tcontext: this.context,\n\t\t\tmute: options.mute,\n\t\t\tvolume: options.volume,\n\t\t});\n\t\tthis.volume = this._volume.volume;\n\t\treadOnly(this, \"volume\");\n\t\tthis.onstop = options.onstop;\n\t}\n\n\tstatic getDefaults(): SourceOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tonstop: noOp,\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\" or \"stopped\".\n\t * @example\n\t * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/ahntone_c3.mp3\", () => {\n\t * \tplayer.start();\n\t * \tconsole.log(player.state);\n\t * }).toDestination();\n\t */\n\tget state(): BasicPlaybackState {\n\t\tif (this._synced) {\n\t\t\tif (this.context.transport.state === \"started\") {\n\t\t\t\treturn this._state.getValueAtTime(this.context.transport.seconds) as BasicPlaybackState;\n\t\t\t} else {\n\t\t\t\treturn \"stopped\";\n\t\t\t}\n\t\t} else {\n\t\t\treturn this._state.getValueAtTime(this.now()) as BasicPlaybackState;\n\t\t}\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * const osc = new Tone.Oscillator().toDestination().start();\n\t * // mute the output\n\t * osc.mute = true;\n\t */\n\tget mute(): boolean {\n\t\treturn this._volume.mute;\n\t}\n\tset mute(mute: boolean) {\n\t\tthis._volume.mute = mute;\n\t}\n\n\t// overwrite these functions\n\tprotected abstract _start(time: Time, offset?: Time, duration?: Time): void;\n\tprotected abstract _stop(time: Time): void;\n\tprotected abstract _restart(time: Seconds, offset?: Time, duration?: Time): void;\n\n\t/**\n\t * Ensure that the scheduled time is not before the current time.\n\t * Should only be used when scheduled unsynced.\n\t */\n\tprivate _clampToCurrentTime(time: Seconds): Seconds {\n\t\tif (this._synced) {\n\t\t\treturn time;\n\t\t} else {\n\t\t\treturn Math.max(time, this.context.currentTime);\n\t\t}\n\t}\n\n\t/**\n\t * Start the source at the specified time. If no time is given,\n\t * start the source now.\n\t * @param  time When the source should be started.\n\t * @example\n\t * const source = new Tone.Oscillator().toDestination();\n\t * source.start(\"+0.5\"); // starts the source 0.5 seconds from now\n\t */\n\tstart(time?: Time, offset?: Time, duration?: Time): this {\n\t\tlet computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n\t\tcomputedTime = this._clampToCurrentTime(computedTime);\n\t\t// if it's started, stop it and restart it\n\t\tif (!this._synced && this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\t// time should be strictly greater than the previous start time\n\t\t\tassert(GT(computedTime, (this._state.get(computedTime) as StateTimelineEvent).time), \"Start time must be strictly greater than previous start time\");\n\t\t\tthis._state.cancel(computedTime);\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tthis.log(\"restart\", computedTime);\n\t\t\tthis.restart(computedTime, offset, duration);\n\t\t} else {\n\t\t\tthis.log(\"start\", computedTime);\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tif (this._synced) {\n\t\t\t\t// add the offset time to the event\n\t\t\t\tconst event = this._state.get(computedTime);\n\t\t\t\tif (event) {\n\t\t\t\t\tevent.offset = this.toSeconds(defaultArg(offset, 0));\n\t\t\t\t\tevent.duration = duration ? this.toSeconds(duration) : undefined;\n\t\t\t\t}\n\t\t\t\tconst sched = this.context.transport.schedule(t => {\n\t\t\t\t\tthis._start(t, offset, duration);\n\t\t\t\t}, computedTime);\n\t\t\t\tthis._scheduled.push(sched);\n\n\t\t\t\t// if the transport is already started\n\t\t\t\t// and the time is greater than where the transport is\n\t\t\t\tif (this.context.transport.state === \"started\" && \n\t\t\t\t\tthis.context.transport.getSecondsAtTime(this.immediate()) > computedTime) {\n\t\t\t\t\tthis._syncedStart(this.now(), this.context.transport.seconds);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tassertContextRunning(this.context);\n\t\t\t\tthis._start(computedTime, offset, duration);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the source at the specified time. If no time is given,\n\t * stop the source now.\n\t * @param  time When the source should be stopped.\n\t * @example\n\t * const source = new Tone.Oscillator().toDestination();\n\t * source.start();\n\t * source.stop(\"+0.5\"); // stops the source 0.5 seconds from now\n\t */\n\tstop(time?: Time): this {\n\t\tlet computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n\t\tcomputedTime = this._clampToCurrentTime(computedTime);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\" || isDefined(this._state.getNextState(\"started\", computedTime))) {\n\t\t\tthis.log(\"stop\", computedTime);\n\t\t\tif (!this._synced) {\n\t\t\t\tthis._stop(computedTime);\n\t\t\t} else {\n\t\t\t\tconst sched = this.context.transport.schedule(this._stop.bind(this), computedTime);\n\t\t\t\tthis._scheduled.push(sched);\n\t\t\t}\n\t\t\tthis._state.cancel(computedTime);\n\t\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Restart the source.\n\t */\n\trestart(time?: Time, offset?: Time, duration?: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(time) === \"started\") {\n\t\t\tthis._state.cancel(time);\n\t\t\tthis._restart(time, offset, duration);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the source to the Transport so that all subsequent\n\t * calls to `start` and `stop` are synced to the TransportTime\n\t * instead of the AudioContext time.\n\t *\n\t * @example\n\t * const osc = new Tone.Oscillator().toDestination();\n\t * // sync the source so that it plays between 0 and 0.3 on the Transport's timeline\n\t * osc.sync().start(0).stop(0.3);\n\t * // start the transport.\n\t * Tone.Transport.start();\n\t * // set it to loop once a second\n\t * Tone.Transport.loop = true;\n\t * Tone.Transport.loopEnd = 1;\n\t */\n\tsync(): this {\n\t\tif (!this._synced) {\n\t\t\tthis._synced = true;\n\t\t\tthis._syncedStart = (time, offset) => {\n\t\t\t\tif (offset > 0) {\n\t\t\t\t\t// get the playback state at that time\n\t\t\t\t\tconst stateEvent = this._state.get(offset);\n\t\t\t\t\t// listen for start events which may occur in the middle of the sync'ed time\n\t\t\t\t\tif (stateEvent && stateEvent.state === \"started\" && stateEvent.time !== offset) {\n\t\t\t\t\t\t// get the offset\n\t\t\t\t\t\tconst startOffset = offset - this.toSeconds(stateEvent.time);\n\t\t\t\t\t\tlet duration: number | undefined;\n\t\t\t\t\t\tif (stateEvent.duration) {\n\t\t\t\t\t\t\tduration = this.toSeconds(stateEvent.duration) - startOffset;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._start(time, this.toSeconds(stateEvent.offset) + startOffset, duration);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis._syncedStop = time => {\n\t\t\t\tconst seconds = this.context.transport.getSecondsAtTime(Math.max(time - this.sampleTime, 0));\n\t\t\t\tif (this._state.getValueAtTime(seconds) === \"started\") {\n\t\t\t\t\tthis._stop(time);\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis.context.transport.on(\"start\", this._syncedStart);\n\t\t\tthis.context.transport.on(\"loopStart\", this._syncedStart);\n\t\t\tthis.context.transport.on(\"stop\", this._syncedStop);\n\t\t\tthis.context.transport.on(\"pause\", this._syncedStop);\n\t\t\tthis.context.transport.on(\"loopEnd\", this._syncedStop);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unsync the source to the Transport. See Source.sync\n\t */\n\tunsync(): this {\n\t\tif (this._synced) {\n\t\t\tthis.context.transport.off(\"stop\", this._syncedStop);\n\t\t\tthis.context.transport.off(\"pause\", this._syncedStop);\n\t\t\tthis.context.transport.off(\"loopEnd\", this._syncedStop);\n\t\t\tthis.context.transport.off(\"start\", this._syncedStart);\n\t\t\tthis.context.transport.off(\"loopStart\", this._syncedStart);\n\t\t}\n\t\tthis._synced = false;\n\t\t// clear all of the scheduled ids\n\t\tthis._scheduled.forEach(id => this.context.transport.clear(id));\n\t\tthis._scheduled = [];\n\t\tthis._state.cancel(0);\n\t\t// stop it also\n\t\tthis._stop(0);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.onstop = noOp;\n\t\tthis.unsync();\n\t\tthis._volume.dispose();\n\t\tthis._state.dispose();\n\t\treturn this;\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}