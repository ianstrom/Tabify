{"ast":null,"code":"import { Tone } from \"../Tone\";\nimport { isDefined } from \"./TypeCheck\";\nimport { assert } from \"./Debug\";\n/**\n * Similar to Tone.Timeline, but all events represent\n * intervals with both \"time\" and \"duration\" times. The\n * events are placed in a tree structure optimized\n * for querying an intersection point with the timeline\n * events. Internally uses an [Interval Tree](https://en.wikipedia.org/wiki/Interval_tree)\n * to represent the data.\n */\nexport class IntervalTimeline extends Tone {\n  constructor() {\n    super(...arguments);\n    this.name = \"IntervalTimeline\";\n    /**\n     * The root node of the inteval tree\n     */\n    this._root = null;\n    /**\n     * Keep track of the length of the timeline.\n     */\n    this._length = 0;\n  }\n  /**\n   * The event to add to the timeline. All events must\n   * have a time and duration value\n   * @param  event  The event to add to the timeline\n   */\n  add(event) {\n    assert(isDefined(event.time), \"Events must have a time property\");\n    assert(isDefined(event.duration), \"Events must have a duration parameter\");\n    event.time = event.time.valueOf();\n    let node = new IntervalNode(event.time, event.time + event.duration, event);\n    if (this._root === null) {\n      this._root = node;\n    } else {\n      this._root.insert(node);\n    }\n    this._length++;\n    // Restructure tree to be balanced\n    while (node !== null) {\n      node.updateHeight();\n      node.updateMax();\n      this._rebalance(node);\n      node = node.parent;\n    }\n    return this;\n  }\n  /**\n   * Remove an event from the timeline.\n   * @param  event  The event to remove from the timeline\n   */\n  remove(event) {\n    if (this._root !== null) {\n      const results = [];\n      this._root.search(event.time, results);\n      for (const node of results) {\n        if (node.event === event) {\n          this._removeNode(node);\n          this._length--;\n          break;\n        }\n      }\n    }\n    return this;\n  }\n  /**\n   * The number of items in the timeline.\n   * @readOnly\n   */\n  get length() {\n    return this._length;\n  }\n  /**\n   * Remove events whose time time is after the given time\n   * @param  after  The time to query.\n   */\n  cancel(after) {\n    this.forEachFrom(after, event => this.remove(event));\n    return this;\n  }\n  /**\n   * Set the root node as the given node\n   */\n  _setRoot(node) {\n    this._root = node;\n    if (this._root !== null) {\n      this._root.parent = null;\n    }\n  }\n  /**\n   * Replace the references to the node in the node's parent\n   * with the replacement node.\n   */\n  _replaceNodeInParent(node, replacement) {\n    if (node.parent !== null) {\n      if (node.isLeftChild()) {\n        node.parent.left = replacement;\n      } else {\n        node.parent.right = replacement;\n      }\n      this._rebalance(node.parent);\n    } else {\n      this._setRoot(replacement);\n    }\n  }\n  /**\n   * Remove the node from the tree and replace it with\n   * a successor which follows the schema.\n   */\n  _removeNode(node) {\n    if (node.left === null && node.right === null) {\n      this._replaceNodeInParent(node, null);\n    } else if (node.right === null) {\n      this._replaceNodeInParent(node, node.left);\n    } else if (node.left === null) {\n      this._replaceNodeInParent(node, node.right);\n    } else {\n      const balance = node.getBalance();\n      let replacement;\n      let temp = null;\n      if (balance > 0) {\n        if (node.left.right === null) {\n          replacement = node.left;\n          replacement.right = node.right;\n          temp = replacement;\n        } else {\n          replacement = node.left.right;\n          while (replacement.right !== null) {\n            replacement = replacement.right;\n          }\n          if (replacement.parent) {\n            replacement.parent.right = replacement.left;\n            temp = replacement.parent;\n            replacement.left = node.left;\n            replacement.right = node.right;\n          }\n        }\n      } else if (node.right.left === null) {\n        replacement = node.right;\n        replacement.left = node.left;\n        temp = replacement;\n      } else {\n        replacement = node.right.left;\n        while (replacement.left !== null) {\n          replacement = replacement.left;\n        }\n        if (replacement.parent) {\n          replacement.parent.left = replacement.right;\n          temp = replacement.parent;\n          replacement.left = node.left;\n          replacement.right = node.right;\n        }\n      }\n      if (node.parent !== null) {\n        if (node.isLeftChild()) {\n          node.parent.left = replacement;\n        } else {\n          node.parent.right = replacement;\n        }\n      } else {\n        this._setRoot(replacement);\n      }\n      if (temp) {\n        this._rebalance(temp);\n      }\n    }\n    node.dispose();\n  }\n  /**\n   * Rotate the tree to the left\n   */\n  _rotateLeft(node) {\n    const parent = node.parent;\n    const isLeftChild = node.isLeftChild();\n    // Make node.right the new root of this sub tree (instead of node)\n    const pivotNode = node.right;\n    if (pivotNode) {\n      node.right = pivotNode.left;\n      pivotNode.left = node;\n    }\n    if (parent !== null) {\n      if (isLeftChild) {\n        parent.left = pivotNode;\n      } else {\n        parent.right = pivotNode;\n      }\n    } else {\n      this._setRoot(pivotNode);\n    }\n  }\n  /**\n   * Rotate the tree to the right\n   */\n  _rotateRight(node) {\n    const parent = node.parent;\n    const isLeftChild = node.isLeftChild();\n    // Make node.left the new root of this sub tree (instead of node)\n    const pivotNode = node.left;\n    if (pivotNode) {\n      node.left = pivotNode.right;\n      pivotNode.right = node;\n    }\n    if (parent !== null) {\n      if (isLeftChild) {\n        parent.left = pivotNode;\n      } else {\n        parent.right = pivotNode;\n      }\n    } else {\n      this._setRoot(pivotNode);\n    }\n  }\n  /**\n   * Balance the BST\n   */\n  _rebalance(node) {\n    const balance = node.getBalance();\n    if (balance > 1 && node.left) {\n      if (node.left.getBalance() < 0) {\n        this._rotateLeft(node.left);\n      } else {\n        this._rotateRight(node);\n      }\n    } else if (balance < -1 && node.right) {\n      if (node.right.getBalance() > 0) {\n        this._rotateRight(node.right);\n      } else {\n        this._rotateLeft(node);\n      }\n    }\n  }\n  /**\n   * Get an event whose time and duration span the give time. Will\n   * return the match whose \"time\" value is closest to the given time.\n   * @return  The event which spans the desired time\n   */\n  get(time) {\n    if (this._root !== null) {\n      const results = [];\n      this._root.search(time, results);\n      if (results.length > 0) {\n        let max = results[0];\n        for (let i = 1; i < results.length; i++) {\n          if (results[i].low > max.low) {\n            max = results[i];\n          }\n        }\n        return max.event;\n      }\n    }\n    return null;\n  }\n  /**\n   * Iterate over everything in the timeline.\n   * @param  callback The callback to invoke with every item\n   */\n  forEach(callback) {\n    if (this._root !== null) {\n      const allNodes = [];\n      this._root.traverse(node => allNodes.push(node));\n      allNodes.forEach(node => {\n        if (node.event) {\n          callback(node.event);\n        }\n      });\n    }\n    return this;\n  }\n  /**\n   * Iterate over everything in the array in which the given time\n   * overlaps with the time and duration time of the event.\n   * @param  time The time to check if items are overlapping\n   * @param  callback The callback to invoke with every item\n   */\n  forEachAtTime(time, callback) {\n    if (this._root !== null) {\n      const results = [];\n      this._root.search(time, results);\n      results.forEach(node => {\n        if (node.event) {\n          callback(node.event);\n        }\n      });\n    }\n    return this;\n  }\n  /**\n   * Iterate over everything in the array in which the time is greater\n   * than or equal to the given time.\n   * @param  time The time to check if items are before\n   * @param  callback The callback to invoke with every item\n   */\n  forEachFrom(time, callback) {\n    if (this._root !== null) {\n      const results = [];\n      this._root.searchAfter(time, results);\n      results.forEach(node => {\n        if (node.event) {\n          callback(node.event);\n        }\n      });\n    }\n    return this;\n  }\n  /**\n   * Clean up\n   */\n  dispose() {\n    super.dispose();\n    if (this._root !== null) {\n      this._root.traverse(node => node.dispose());\n    }\n    this._root = null;\n    return this;\n  }\n}\n//-------------------------------------\n// \tINTERVAL NODE HELPER\n//-------------------------------------\n/**\n * Represents a node in the binary search tree, with the addition\n * of a \"high\" value which keeps track of the highest value of\n * its children.\n * References:\n * https://brooknovak.wordpress.com/2013/12/07/augmented-interval-tree-in-c/\n * http://www.mif.vu.lt/~valdas/ALGORITMAI/LITERATURA/Cormen/Cormen.pdf\n * @param low\n * @param high\n */\nclass IntervalNode {\n  constructor(low, high, event) {\n    // the nodes to the left\n    this._left = null;\n    // the nodes to the right\n    this._right = null;\n    // the parent node\n    this.parent = null;\n    // the number of child nodes\n    this.height = 0;\n    this.event = event;\n    // the low value\n    this.low = low;\n    // the high value\n    this.high = high;\n    // the high value for this and all child nodes\n    this.max = this.high;\n  }\n  /**\n   * Insert a node into the correct spot in the tree\n   */\n  insert(node) {\n    if (node.low <= this.low) {\n      if (this.left === null) {\n        this.left = node;\n      } else {\n        this.left.insert(node);\n      }\n    } else if (this.right === null) {\n      this.right = node;\n    } else {\n      this.right.insert(node);\n    }\n  }\n  /**\n   * Search the tree for nodes which overlap\n   * with the given point\n   * @param  point  The point to query\n   * @param  results  The array to put the results\n   */\n  search(point, results) {\n    // If p is to the right of the rightmost point of any interval\n    // in this node and all children, there won't be any matches.\n    if (point > this.max) {\n      return;\n    }\n    // Search left children\n    if (this.left !== null) {\n      this.left.search(point, results);\n    }\n    // Check this node\n    if (this.low <= point && this.high > point) {\n      results.push(this);\n    }\n    // If p is to the left of the time of this interval,\n    // then it can't be in any child to the right.\n    if (this.low > point) {\n      return;\n    }\n    // Search right children\n    if (this.right !== null) {\n      this.right.search(point, results);\n    }\n  }\n  /**\n   * Search the tree for nodes which are less\n   * than the given point\n   * @param  point  The point to query\n   * @param  results  The array to put the results\n   */\n  searchAfter(point, results) {\n    // Check this node\n    if (this.low >= point) {\n      results.push(this);\n      if (this.left !== null) {\n        this.left.searchAfter(point, results);\n      }\n    }\n    // search the right side\n    if (this.right !== null) {\n      this.right.searchAfter(point, results);\n    }\n  }\n  /**\n   * Invoke the callback on this element and both it's branches\n   * @param  {Function}  callback\n   */\n  traverse(callback) {\n    callback(this);\n    if (this.left !== null) {\n      this.left.traverse(callback);\n    }\n    if (this.right !== null) {\n      this.right.traverse(callback);\n    }\n  }\n  /**\n   * Update the height of the node\n   */\n  updateHeight() {\n    if (this.left !== null && this.right !== null) {\n      this.height = Math.max(this.left.height, this.right.height) + 1;\n    } else if (this.right !== null) {\n      this.height = this.right.height + 1;\n    } else if (this.left !== null) {\n      this.height = this.left.height + 1;\n    } else {\n      this.height = 0;\n    }\n  }\n  /**\n   * Update the height of the node\n   */\n  updateMax() {\n    this.max = this.high;\n    if (this.left !== null) {\n      this.max = Math.max(this.max, this.left.max);\n    }\n    if (this.right !== null) {\n      this.max = Math.max(this.max, this.right.max);\n    }\n  }\n  /**\n   * The balance is how the leafs are distributed on the node\n   * @return  Negative numbers are balanced to the right\n   */\n  getBalance() {\n    let balance = 0;\n    if (this.left !== null && this.right !== null) {\n      balance = this.left.height - this.right.height;\n    } else if (this.left !== null) {\n      balance = this.left.height + 1;\n    } else if (this.right !== null) {\n      balance = -(this.right.height + 1);\n    }\n    return balance;\n  }\n  /**\n   * @returns true if this node is the left child of its parent\n   */\n  isLeftChild() {\n    return this.parent !== null && this.parent.left === this;\n  }\n  /**\n   * get/set the left node\n   */\n  get left() {\n    return this._left;\n  }\n  set left(node) {\n    this._left = node;\n    if (node !== null) {\n      node.parent = this;\n    }\n    this.updateHeight();\n    this.updateMax();\n  }\n  /**\n   * get/set the right node\n   */\n  get right() {\n    return this._right;\n  }\n  set right(node) {\n    this._right = node;\n    if (node !== null) {\n      node.parent = this;\n    }\n    this.updateHeight();\n    this.updateMax();\n  }\n  /**\n   * null out references.\n   */\n  dispose() {\n    this.parent = null;\n    this._left = null;\n    this._right = null;\n    this.event = null;\n  }\n}","map":{"version":3,"names":["Tone","isDefined","assert","IntervalTimeline","constructor","name","_root","_length","add","event","time","duration","valueOf","node","IntervalNode","insert","updateHeight","updateMax","_rebalance","parent","remove","results","search","_removeNode","length","cancel","after","forEachFrom","_setRoot","_replaceNodeInParent","replacement","isLeftChild","left","right","balance","getBalance","temp","dispose","_rotateLeft","pivotNode","_rotateRight","get","max","i","low","forEach","callback","allNodes","traverse","push","forEachAtTime","searchAfter","high","_left","_right","height","point","Math"],"sources":["/Users/ianstrom/Development/code/Capstone/client/node_modules/tone/Tone/core/util/IntervalTimeline.ts"],"sourcesContent":["import { Tone } from \"../Tone\";\nimport { isDefined } from \"./TypeCheck\";\nimport { assert } from \"./Debug\";\n\n/**\n * An IntervalTimeline event must have a time and duration\n */\nexport interface IntervalTimelineEvent {\n\ttime: number;\n\tduration: number;\n\t[propName: string]: any;\n}\n\ntype IteratorCallback = (event: IntervalTimelineEvent) => void;\n\n/**\n * Similar to Tone.Timeline, but all events represent\n * intervals with both \"time\" and \"duration\" times. The\n * events are placed in a tree structure optimized\n * for querying an intersection point with the timeline\n * events. Internally uses an [Interval Tree](https://en.wikipedia.org/wiki/Interval_tree)\n * to represent the data.\n */\nexport class IntervalTimeline extends Tone {\n\n\treadonly name: string = \"IntervalTimeline\";\n\n\t/**\n\t * The root node of the inteval tree\n\t */\n\tprivate _root: IntervalNode | null = null;\n\n\t/**\n\t * Keep track of the length of the timeline.\n\t */\n\tprivate _length = 0;\n\n\t/**\n\t * The event to add to the timeline. All events must\n\t * have a time and duration value\n\t * @param  event  The event to add to the timeline\n\t */\n\tadd(event: IntervalTimelineEvent): this {\n\t\tassert(isDefined(event.time), \"Events must have a time property\");\n\t\tassert(isDefined(event.duration), \"Events must have a duration parameter\");\n\n\t\tevent.time = event.time.valueOf();\n\t\tlet node: IntervalNode | null = new IntervalNode(event.time, event.time + event.duration, event);\n\t\tif (this._root === null) {\n\t\t\tthis._root = node;\n\t\t} else {\n\t\t\tthis._root.insert(node);\n\t\t}\n\t\tthis._length++;\n\t\t// Restructure tree to be balanced\n\t\twhile (node !== null) {\n\t\t\tnode.updateHeight();\n\t\t\tnode.updateMax();\n\t\t\tthis._rebalance(node);\n\t\t\tnode = node.parent;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove an event from the timeline.\n\t * @param  event  The event to remove from the timeline\n\t */\n\tremove(event: IntervalTimelineEvent): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(event.time, results);\n\t\t\tfor (const node of results) {\n\t\t\t\tif (node.event === event) {\n\t\t\t\t\tthis._removeNode(node);\n\t\t\t\t\tthis._length--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * The number of items in the timeline.\n\t * @readOnly\n\t */\n\tget length(): number {\n\t\treturn this._length;\n\t}\n\n\t/**\n\t * Remove events whose time time is after the given time\n\t * @param  after  The time to query.\n\t */\n\tcancel(after: number): this {\n\t\tthis.forEachFrom(after, event => this.remove(event));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the root node as the given node\n\t */\n\tprivate _setRoot(node: IntervalNode | null): void {\n\t\tthis._root = node;\n\t\tif (this._root !== null) {\n\t\t\tthis._root.parent = null;\n\t\t}\n\t}\n\n\t/**\n\t * Replace the references to the node in the node's parent\n\t * with the replacement node.\n\t */\n\tprivate _replaceNodeInParent(node: IntervalNode, replacement: IntervalNode | null): void {\n\t\tif (node.parent !== null) {\n\t\t\tif (node.isLeftChild()) {\n\t\t\t\tnode.parent.left = replacement;\n\t\t\t} else {\n\t\t\t\tnode.parent.right = replacement;\n\t\t\t}\n\t\t\tthis._rebalance(node.parent);\n\t\t} else {\n\t\t\tthis._setRoot(replacement);\n\t\t}\n\t}\n\n\t/**\n\t * Remove the node from the tree and replace it with\n\t * a successor which follows the schema.\n\t */\n\tprivate _removeNode(node: IntervalNode): void {\n\t\tif (node.left === null && node.right === null) {\n\t\t\tthis._replaceNodeInParent(node, null);\n\t\t} else if (node.right === null) {\n\t\t\tthis._replaceNodeInParent(node, node.left);\n\t\t} else if (node.left === null) {\n\t\t\tthis._replaceNodeInParent(node, node.right);\n\t\t} else {\n\t\t\tconst balance = node.getBalance();\n\t\t\tlet replacement: IntervalNode;\n\t\t\tlet temp: IntervalNode | null = null;\n\t\t\tif (balance > 0) {\n\t\t\t\tif (node.left.right === null) {\n\t\t\t\t\treplacement = node.left;\n\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t\ttemp = replacement;\n\t\t\t\t} else {\n\t\t\t\t\treplacement = node.left.right;\n\t\t\t\t\twhile (replacement.right !== null) {\n\t\t\t\t\t\treplacement = replacement.right;\n\t\t\t\t\t}\n\t\t\t\t\tif (replacement.parent) {\n\t\t\t\t\t\treplacement.parent.right = replacement.left;\n\t\t\t\t\t\ttemp = replacement.parent;\n\t\t\t\t\t\treplacement.left = node.left;\n\t\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (node.right.left === null) {\n\t\t\t\treplacement = node.right;\n\t\t\t\treplacement.left = node.left;\n\t\t\t\ttemp = replacement;\n\t\t\t} else {\n\t\t\t\treplacement = node.right.left;\n\t\t\t\twhile (replacement.left !== null) {\n\t\t\t\t\treplacement = replacement.left;\n\t\t\t\t}\n\t\t\t\tif (replacement.parent) {\n\t\t\t\t\treplacement.parent.left = replacement.right;\n\t\t\t\t\ttemp = replacement.parent;\n\t\t\t\t\treplacement.left = node.left;\n\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (node.parent !== null) {\n\t\t\t\tif (node.isLeftChild()) {\n\t\t\t\t\tnode.parent.left = replacement;\n\t\t\t\t} else {\n\t\t\t\t\tnode.parent.right = replacement;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._setRoot(replacement);\n\t\t\t}\n\t\t\tif (temp) {\n\t\t\t\tthis._rebalance(temp);\n\t\t\t}\n\t\t}\n\t\tnode.dispose();\n\t}\n\n\t/**\n\t * Rotate the tree to the left\n\t */\n\tprivate _rotateLeft(node: IntervalNode): void {\n\t\tconst parent = node.parent;\n\t\tconst isLeftChild = node.isLeftChild();\n\n\t\t// Make node.right the new root of this sub tree (instead of node)\n\t\tconst pivotNode = node.right;\n\t\tif (pivotNode) {\n\t\t\tnode.right = pivotNode.left;\n\t\t\tpivotNode.left = node;\n\t\t}\n\n\t\tif (parent !== null) {\n\t\t\tif (isLeftChild) {\n\t\t\t\tparent.left = pivotNode;\n\t\t\t} else {\n\t\t\t\tparent.right = pivotNode;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._setRoot(pivotNode);\n\t\t}\n\t}\n\n\t/**\n\t * Rotate the tree to the right\n\t */\n\tprivate _rotateRight(node: IntervalNode): void {\n\t\tconst parent = node.parent;\n\t\tconst isLeftChild = node.isLeftChild();\n\n\t\t// Make node.left the new root of this sub tree (instead of node)\n\t\tconst pivotNode = node.left;\n\t\tif (pivotNode) {\n\t\t\tnode.left = pivotNode.right;\n\t\t\tpivotNode.right = node;\n\t\t}\n\n\t\tif (parent !== null) {\n\t\t\tif (isLeftChild) {\n\t\t\t\tparent.left = pivotNode;\n\t\t\t} else {\n\t\t\t\tparent.right = pivotNode;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._setRoot(pivotNode);\n\t\t}\n\t}\n\n\t/**\n\t * Balance the BST\n\t */\n\tprivate _rebalance(node: IntervalNode): void {\n\t\tconst balance = node.getBalance();\n\t\tif (balance > 1 && node.left) {\n\t\t\tif (node.left.getBalance() < 0) {\n\t\t\t\tthis._rotateLeft(node.left);\n\t\t\t} else {\n\t\t\t\tthis._rotateRight(node);\n\t\t\t}\n\t\t} else if (balance < -1 && node.right) {\n\t\t\tif (node.right.getBalance() > 0) {\n\t\t\t\tthis._rotateRight(node.right);\n\t\t\t} else {\n\t\t\t\tthis._rotateLeft(node);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get an event whose time and duration span the give time. Will\n\t * return the match whose \"time\" value is closest to the given time.\n\t * @return  The event which spans the desired time\n\t */\n\tget(time: number): IntervalTimelineEvent | null {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(time, results);\n\t\t\tif (results.length > 0) {\n\t\t\t\tlet max = results[0];\n\t\t\t\tfor (let i = 1; i < results.length; i++) {\n\t\t\t\t\tif (results[i].low > max.low) {\n\t\t\t\t\t\tmax = results[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn max.event;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Iterate over everything in the timeline.\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEach(callback: IteratorCallback): this {\n\t\tif (this._root !== null) {\n\t\t\tconst allNodes: IntervalNode[] = [];\n\t\t\tthis._root.traverse(node => allNodes.push(node));\n\t\t\tallNodes.forEach(node => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array in which the given time\n\t * overlaps with the time and duration time of the event.\n\t * @param  time The time to check if items are overlapping\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachAtTime(time: number, callback: IteratorCallback): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(time, results);\n\t\t\tresults.forEach(node => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array in which the time is greater\n\t * than or equal to the given time.\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachFrom(time: number, callback: IteratorCallback): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.searchAfter(time, results);\n\t\t\tresults.forEach(node => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this._root !== null) {\n\t\t\tthis._root.traverse(node => node.dispose());\n\t\t}\n\t\tthis._root = null;\n\t\treturn this;\n\t}\n}\n\n//-------------------------------------\n// \tINTERVAL NODE HELPER\n//-------------------------------------\n\n/**\n * Represents a node in the binary search tree, with the addition\n * of a \"high\" value which keeps track of the highest value of\n * its children.\n * References:\n * https://brooknovak.wordpress.com/2013/12/07/augmented-interval-tree-in-c/\n * http://www.mif.vu.lt/~valdas/ALGORITMAI/LITERATURA/Cormen/Cormen.pdf\n * @param low\n * @param high\n */\nclass IntervalNode {\n\n\t// the event container\n\tevent: IntervalTimelineEvent | null;\n\t// the low value\n\tlow: number;\n\t// the high value\n\thigh: number;\n\t// the high value for this and all child nodes\n\tmax: number;\n\t// the nodes to the left\n\tprivate _left: IntervalNode | null = null;\n\t// the nodes to the right\n\tprivate _right: IntervalNode | null = null;\n\t// the parent node\n\tparent: IntervalNode | null = null;\n\t// the number of child nodes\n\theight = 0;\n\n\tconstructor(low: number, high: number, event: IntervalTimelineEvent) {\n\t\tthis.event = event;\n\t\t// the low value\n\t\tthis.low = low;\n\t\t// the high value\n\t\tthis.high = high;\n\t\t// the high value for this and all child nodes\n\t\tthis.max = this.high;\n\t}\n\n\t/**\n\t * Insert a node into the correct spot in the tree\n\t */\n\tinsert(node: IntervalNode): void {\n\t\tif (node.low <= this.low) {\n\t\t\tif (this.left === null) {\n\t\t\t\tthis.left = node;\n\t\t\t} else {\n\t\t\t\tthis.left.insert(node);\n\t\t\t}\n\t\t} else if (this.right === null) {\n\t\t\tthis.right = node;\n\t\t} else {\n\t\t\tthis.right.insert(node);\n\t\t}\n\t}\n\n\t/**\n\t * Search the tree for nodes which overlap\n\t * with the given point\n\t * @param  point  The point to query\n\t * @param  results  The array to put the results\n\t */\n\tsearch(point: number, results: IntervalNode[]): void {\n\t\t// If p is to the right of the rightmost point of any interval\n\t\t// in this node and all children, there won't be any matches.\n\t\tif (point > this.max) {\n\t\t\treturn;\n\t\t}\n\t\t// Search left children\n\t\tif (this.left !== null) {\n\t\t\tthis.left.search(point, results);\n\t\t}\n\t\t// Check this node\n\t\tif (this.low <= point && this.high > point) {\n\t\t\tresults.push(this);\n\t\t}\n\t\t// If p is to the left of the time of this interval,\n\t\t// then it can't be in any child to the right.\n\t\tif (this.low > point) {\n\t\t\treturn;\n\t\t}\n\t\t// Search right children\n\t\tif (this.right !== null) {\n\t\t\tthis.right.search(point, results);\n\t\t}\n\t}\n\n\t/**\n\t * Search the tree for nodes which are less\n\t * than the given point\n\t * @param  point  The point to query\n\t * @param  results  The array to put the results\n\t */\n\tsearchAfter(point: number, results: IntervalNode[]): void {\n\t\t// Check this node\n\t\tif (this.low >= point) {\n\t\t\tresults.push(this);\n\t\t\tif (this.left !== null) {\n\t\t\t\tthis.left.searchAfter(point, results);\n\t\t\t}\n\t\t}\n\t\t// search the right side\n\t\tif (this.right !== null) {\n\t\t\tthis.right.searchAfter(point, results);\n\t\t}\n\t}\n\n\t/**\n\t * Invoke the callback on this element and both it's branches\n\t * @param  {Function}  callback\n\t */\n\ttraverse(callback: (self: IntervalNode) => void): void {\n\t\tcallback(this);\n\t\tif (this.left !== null) {\n\t\t\tthis.left.traverse(callback);\n\t\t}\n\t\tif (this.right !== null) {\n\t\t\tthis.right.traverse(callback);\n\t\t}\n\t}\n\n\t/**\n\t * Update the height of the node\n\t */\n\tupdateHeight(): void {\n\t\tif (this.left !== null && this.right !== null) {\n\t\t\tthis.height = Math.max(this.left.height, this.right.height) + 1;\n\t\t} else if (this.right !== null) {\n\t\t\tthis.height = this.right.height + 1;\n\t\t} else if (this.left !== null) {\n\t\t\tthis.height = this.left.height + 1;\n\t\t} else {\n\t\t\tthis.height = 0;\n\t\t}\n\t}\n\n\t/**\n\t * Update the height of the node\n\t */\n\tupdateMax(): void {\n\t\tthis.max = this.high;\n\t\tif (this.left !== null) {\n\t\t\tthis.max = Math.max(this.max, this.left.max);\n\t\t}\n\t\tif (this.right !== null) {\n\t\t\tthis.max = Math.max(this.max, this.right.max);\n\t\t}\n\t}\n\n\t/**\n\t * The balance is how the leafs are distributed on the node\n\t * @return  Negative numbers are balanced to the right\n\t */\n\tgetBalance(): number {\n\t\tlet balance = 0;\n\t\tif (this.left !== null && this.right !== null) {\n\t\t\tbalance = this.left.height - this.right.height;\n\t\t} else if (this.left !== null) {\n\t\t\tbalance = this.left.height + 1;\n\t\t} else if (this.right !== null) {\n\t\t\tbalance = -(this.right.height + 1);\n\t\t}\n\t\treturn balance;\n\t}\n\n\t/**\n\t * @returns true if this node is the left child of its parent\n\t */\n\tisLeftChild(): boolean {\n\t\treturn this.parent !== null && this.parent.left === this;\n\t}\n\n\t/**\n\t * get/set the left node\n\t */\n\tget left(): IntervalNode | null {\n\t\treturn this._left;\n\t}\n\n\tset left(node: IntervalNode | null) {\n\t\tthis._left = node;\n\t\tif (node !== null) {\n\t\t\tnode.parent = this;\n\t\t}\n\t\tthis.updateHeight();\n\t\tthis.updateMax();\n\t}\n\n\t/**\n\t * get/set the right node\n\t */\n\tget right(): IntervalNode | null {\n\t\treturn this._right;\n\t}\n\n\tset right(node: IntervalNode | null) {\n\t\tthis._right = node;\n\t\tif (node !== null) {\n\t\t\tnode.parent = this;\n\t\t}\n\t\tthis.updateHeight();\n\t\tthis.updateMax();\n\t}\n\n\t/**\n\t * null out references.\n\t */\n\tdispose(): void {\n\t\tthis.parent = null;\n\t\tthis._left = null;\n\t\tthis._right = null;\n\t\tthis.event = null;\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}