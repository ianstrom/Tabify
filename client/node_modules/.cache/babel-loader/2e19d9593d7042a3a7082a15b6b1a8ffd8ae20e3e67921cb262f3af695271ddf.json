{"ast":null,"code":"import { isNativeAudioNode } from '../guards/native-audio-node';\nexport const wrapAudioNodeDisconnectMethod = nativeAudioNode => {\n  const connections = new Map();\n  nativeAudioNode.connect = (connect => {\n    // tslint:disable-next-line:invalid-void no-inferrable-types\n    return function (destination) {\n      let output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      let input = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      const returnValue = isNativeAudioNode(destination) ? connect(destination, output, input) : connect(destination, output);\n      // Save the new connection only if the calls to connect above didn't throw an error.\n      const connectionsToDestination = connections.get(destination);\n      if (connectionsToDestination === undefined) {\n        connections.set(destination, [{\n          input,\n          output\n        }]);\n      } else {\n        if (connectionsToDestination.every(connection => connection.input !== input || connection.output !== output)) {\n          connectionsToDestination.push({\n            input,\n            output\n          });\n        }\n      }\n      return returnValue;\n    };\n  })(nativeAudioNode.connect.bind(nativeAudioNode));\n  nativeAudioNode.disconnect = (disconnect => {\n    return (destinationOrOutput, output, input) => {\n      disconnect.apply(nativeAudioNode);\n      if (destinationOrOutput === undefined) {\n        connections.clear();\n      } else if (typeof destinationOrOutput === 'number') {\n        for (const [destination, connectionsToDestination] of connections) {\n          const filteredConnections = connectionsToDestination.filter(connection => connection.output !== destinationOrOutput);\n          if (filteredConnections.length === 0) {\n            connections.delete(destination);\n          } else {\n            connections.set(destination, filteredConnections);\n          }\n        }\n      } else if (connections.has(destinationOrOutput)) {\n        if (output === undefined) {\n          connections.delete(destinationOrOutput);\n        } else {\n          const connectionsToDestination = connections.get(destinationOrOutput);\n          if (connectionsToDestination !== undefined) {\n            const filteredConnections = connectionsToDestination.filter(connection => connection.output !== output && (connection.input !== input || input === undefined));\n            if (filteredConnections.length === 0) {\n              connections.delete(destinationOrOutput);\n            } else {\n              connections.set(destinationOrOutput, filteredConnections);\n            }\n          }\n        }\n      }\n      for (const [destination, connectionsToDestination] of connections) {\n        connectionsToDestination.forEach(connection => {\n          if (isNativeAudioNode(destination)) {\n            nativeAudioNode.connect(destination, connection.output, connection.input);\n          } else {\n            nativeAudioNode.connect(destination, connection.output);\n          }\n        });\n      }\n    };\n  })(nativeAudioNode.disconnect);\n};","map":{"version":3,"names":["isNativeAudioNode","wrapAudioNodeDisconnectMethod","nativeAudioNode","connections","Map","connect","destination","output","arguments","length","undefined","input","returnValue","connectionsToDestination","get","set","every","connection","push","bind","disconnect","destinationOrOutput","apply","clear","filteredConnections","filter","delete","has","forEach"],"sources":["/Users/ianstrom/Development/code/Capstone/client/node_modules/standardized-audio-context/src/helpers/wrap-audio-node-disconnect-method.ts"],"sourcesContent":["import { isNativeAudioNode } from '../guards/native-audio-node';\nimport { TNativeAudioNode, TNativeAudioParam } from '../types';\n\nexport const wrapAudioNodeDisconnectMethod = (nativeAudioNode: TNativeAudioNode): void => {\n    const connections = new Map<TNativeAudioNode | TNativeAudioParam, { input: number; output: number }[]>();\n\n    nativeAudioNode.connect = <TNativeAudioNode['connect']>((connect) => {\n        // tslint:disable-next-line:invalid-void no-inferrable-types\n        return (destination: TNativeAudioNode | TNativeAudioParam, output = 0, input: number = 0): void | TNativeAudioNode => {\n            const returnValue = isNativeAudioNode(destination) ? connect(destination, output, input) : connect(destination, output);\n\n            // Save the new connection only if the calls to connect above didn't throw an error.\n            const connectionsToDestination = connections.get(destination);\n\n            if (connectionsToDestination === undefined) {\n                connections.set(destination, [{ input, output }]);\n            } else {\n                if (connectionsToDestination.every((connection) => connection.input !== input || connection.output !== output)) {\n                    connectionsToDestination.push({ input, output });\n                }\n            }\n\n            return returnValue;\n        };\n    })(nativeAudioNode.connect.bind(nativeAudioNode));\n\n    nativeAudioNode.disconnect = ((disconnect) => {\n        return (destinationOrOutput?: number | TNativeAudioNode | TNativeAudioParam, output?: number, input?: number): void => {\n            disconnect.apply(nativeAudioNode);\n\n            if (destinationOrOutput === undefined) {\n                connections.clear();\n            } else if (typeof destinationOrOutput === 'number') {\n                for (const [destination, connectionsToDestination] of connections) {\n                    const filteredConnections = connectionsToDestination.filter((connection) => connection.output !== destinationOrOutput);\n\n                    if (filteredConnections.length === 0) {\n                        connections.delete(destination);\n                    } else {\n                        connections.set(destination, filteredConnections);\n                    }\n                }\n            } else if (connections.has(destinationOrOutput)) {\n                if (output === undefined) {\n                    connections.delete(destinationOrOutput);\n                } else {\n                    const connectionsToDestination = connections.get(destinationOrOutput);\n\n                    if (connectionsToDestination !== undefined) {\n                        const filteredConnections = connectionsToDestination.filter(\n                            (connection) => connection.output !== output && (connection.input !== input || input === undefined)\n                        );\n\n                        if (filteredConnections.length === 0) {\n                            connections.delete(destinationOrOutput);\n                        } else {\n                            connections.set(destinationOrOutput, filteredConnections);\n                        }\n                    }\n                }\n            }\n\n            for (const [destination, connectionsToDestination] of connections) {\n                connectionsToDestination.forEach((connection) => {\n                    if (isNativeAudioNode(destination)) {\n                        nativeAudioNode.connect(destination, connection.output, connection.input);\n                    } else {\n                        nativeAudioNode.connect(destination, connection.output);\n                    }\n                });\n            }\n        };\n    })(nativeAudioNode.disconnect);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}