{"ast":null,"code":"import { AUDIO_NODE_STORE, EVENT_LISTENERS } from '../globals';\nimport { isAudioNode } from '../guards/audio-node';\nimport { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nimport { addActiveInputConnectionToAudioParam } from '../helpers/add-active-input-connection-to-audio-param';\nimport { addPassiveInputConnectionToAudioParam } from '../helpers/add-passive-input-connection-to-audio-param';\nimport { connectNativeAudioNodeToNativeAudioNode } from '../helpers/connect-native-audio-node-to-native-audio-node';\nimport { deleteActiveInputConnection } from '../helpers/delete-active-input-connection';\nimport { deleteActiveInputConnectionToAudioParam } from '../helpers/delete-active-input-connection-to-audio-param';\nimport { deleteEventListenerOfAudioNode } from '../helpers/delete-event-listeners-of-audio-node';\nimport { deletePassiveInputConnectionToAudioNode } from '../helpers/delete-passive-input-connection-to-audio-node';\nimport { deletePassiveInputConnectionToAudioParam } from '../helpers/delete-passive-input-connection-to-audio-param';\nimport { disconnectNativeAudioNodeFromNativeAudioNode } from '../helpers/disconnect-native-audio-node-from-native-audio-node';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioParamConnections } from '../helpers/get-audio-param-connections';\nimport { getEventListenersOfAudioNode } from '../helpers/get-event-listeners-of-audio-node';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { getNativeAudioParam } from '../helpers/get-native-audio-param';\nimport { insertElementInSet } from '../helpers/insert-element-in-set';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { isPartOfACycle } from '../helpers/is-part-of-a-cycle';\nimport { isPassiveAudioNode } from '../helpers/is-passive-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassiveWhenNecessary } from '../helpers/set-internal-state-to-passive-when-necessary';\nimport { testAudioNodeDisconnectMethodSupport } from '../helpers/test-audio-node-disconnect-method-support';\nimport { visitEachAudioNodeOnce } from '../helpers/visit-each-audio-node-once';\nimport { wrapAudioNodeDisconnectMethod } from '../helpers/wrap-audio-node-disconnect-method';\nconst addConnectionToAudioParamOfAudioContext = (source, destination, output, isOffline) => {\n  const {\n    activeInputs,\n    passiveInputs\n  } = getAudioParamConnections(destination);\n  const {\n    outputs\n  } = getAudioNodeConnections(source);\n  const eventListeners = getEventListenersOfAudioNode(source);\n  const eventListener = isActive => {\n    const nativeAudioNode = getNativeAudioNode(source);\n    const nativeAudioParam = getNativeAudioParam(destination);\n    if (isActive) {\n      const partialConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n      addActiveInputConnectionToAudioParam(activeInputs, source, partialConnection, false);\n      if (!isOffline && !isPartOfACycle(source)) {\n        nativeAudioNode.connect(nativeAudioParam, output);\n      }\n    } else {\n      const partialConnection = deleteActiveInputConnectionToAudioParam(activeInputs, source, output);\n      addPassiveInputConnectionToAudioParam(passiveInputs, partialConnection, false);\n      if (!isOffline && !isPartOfACycle(source)) {\n        nativeAudioNode.disconnect(nativeAudioParam, output);\n      }\n    }\n  };\n  if (insertElementInSet(outputs, [destination, output], outputConnection => outputConnection[0] === destination && outputConnection[1] === output, true)) {\n    eventListeners.add(eventListener);\n    if (isActiveAudioNode(source)) {\n      addActiveInputConnectionToAudioParam(activeInputs, source, [output, eventListener], true);\n    } else {\n      addPassiveInputConnectionToAudioParam(passiveInputs, [source, output, eventListener], true);\n    }\n    return true;\n  }\n  return false;\n};\nconst deleteInputConnectionOfAudioNode = (source, destination, output, input) => {\n  const {\n    activeInputs,\n    passiveInputs\n  } = getAudioNodeConnections(destination);\n  const activeInputConnection = deleteActiveInputConnection(activeInputs[input], source, output);\n  if (activeInputConnection === null) {\n    const passiveInputConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n    return [passiveInputConnection[2], false];\n  }\n  return [activeInputConnection[2], true];\n};\nconst deleteInputConnectionOfAudioParam = (source, destination, output) => {\n  const {\n    activeInputs,\n    passiveInputs\n  } = getAudioParamConnections(destination);\n  const activeInputConnection = deleteActiveInputConnection(activeInputs, source, output);\n  if (activeInputConnection === null) {\n    const passiveInputConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n    return [passiveInputConnection[1], false];\n  }\n  return [activeInputConnection[2], true];\n};\nconst deleteInputsOfAudioNode = (source, isOffline, destination, output, input) => {\n  const [listener, isActive] = deleteInputConnectionOfAudioNode(source, destination, output, input);\n  if (listener !== null) {\n    deleteEventListenerOfAudioNode(source, listener);\n    if (isActive && !isOffline && !isPartOfACycle(source)) {\n      disconnectNativeAudioNodeFromNativeAudioNode(getNativeAudioNode(source), getNativeAudioNode(destination), output, input);\n    }\n  }\n  if (isActiveAudioNode(destination)) {\n    const {\n      activeInputs\n    } = getAudioNodeConnections(destination);\n    setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n  }\n};\nconst deleteInputsOfAudioParam = (source, isOffline, destination, output) => {\n  const [listener, isActive] = deleteInputConnectionOfAudioParam(source, destination, output);\n  if (listener !== null) {\n    deleteEventListenerOfAudioNode(source, listener);\n    if (isActive && !isOffline && !isPartOfACycle(source)) {\n      getNativeAudioNode(source).disconnect(getNativeAudioParam(destination), output);\n    }\n  }\n};\nconst deleteAnyConnection = (source, isOffline) => {\n  const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n  const destinations = [];\n  for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n    if (isAudioNodeOutputConnection(outputConnection)) {\n      deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n    } else {\n      deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n    }\n    destinations.push(outputConnection[0]);\n  }\n  audioNodeConnectionsOfSource.outputs.clear();\n  return destinations;\n};\nconst deleteConnectionAtOutput = (source, isOffline, output) => {\n  const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n  const destinations = [];\n  for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n    if (outputConnection[1] === output) {\n      if (isAudioNodeOutputConnection(outputConnection)) {\n        deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n      } else {\n        deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n      }\n      destinations.push(outputConnection[0]);\n      audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n    }\n  }\n  return destinations;\n};\nconst deleteConnectionToDestination = (source, isOffline, destination, output, input) => {\n  const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n  return Array.from(audioNodeConnectionsOfSource.outputs).filter(outputConnection => outputConnection[0] === destination && (output === undefined || outputConnection[1] === output) && (input === undefined || outputConnection[2] === input)).map(outputConnection => {\n    if (isAudioNodeOutputConnection(outputConnection)) {\n      deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n    } else {\n      deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n    }\n    audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n    return outputConnection[0];\n  });\n};\nexport const createAudioNodeConstructor = (addAudioNodeConnections, addConnectionToAudioNode, cacheTestResult, createIncrementCycleCounter, createIndexSizeError, createInvalidAccessError, createNotSupportedError, decrementCycleCounter, detectCycles, eventTargetConstructor, getNativeContext, isNativeAudioContext, isNativeAudioNode, isNativeAudioParam, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor) => {\n  return class AudioNode extends eventTargetConstructor {\n    constructor(context, isActive, nativeAudioNode, audioNodeRenderer) {\n      super(nativeAudioNode);\n      this._context = context;\n      this._nativeAudioNode = nativeAudioNode;\n      const nativeContext = getNativeContext(context);\n      // Bug #12: Safari does not support to disconnect a specific destination.\n      if (isNativeAudioContext(nativeContext) && true !== cacheTestResult(testAudioNodeDisconnectMethodSupport, () => {\n        return testAudioNodeDisconnectMethodSupport(nativeContext, nativeAudioWorkletNodeConstructor);\n      })) {\n        wrapAudioNodeDisconnectMethod(nativeAudioNode);\n      }\n      AUDIO_NODE_STORE.set(this, nativeAudioNode);\n      EVENT_LISTENERS.set(this, new Set());\n      if (context.state !== 'closed' && isActive) {\n        setInternalStateToActive(this);\n      }\n      addAudioNodeConnections(this, audioNodeRenderer, nativeAudioNode);\n    }\n    get channelCount() {\n      return this._nativeAudioNode.channelCount;\n    }\n    set channelCount(value) {\n      this._nativeAudioNode.channelCount = value;\n    }\n    get channelCountMode() {\n      return this._nativeAudioNode.channelCountMode;\n    }\n    set channelCountMode(value) {\n      this._nativeAudioNode.channelCountMode = value;\n    }\n    get channelInterpretation() {\n      return this._nativeAudioNode.channelInterpretation;\n    }\n    set channelInterpretation(value) {\n      this._nativeAudioNode.channelInterpretation = value;\n    }\n    get context() {\n      return this._context;\n    }\n    get numberOfInputs() {\n      return this._nativeAudioNode.numberOfInputs;\n    }\n    get numberOfOutputs() {\n      return this._nativeAudioNode.numberOfOutputs;\n    }\n    // tslint:disable-next-line:invalid-void\n    connect(destination) {\n      let output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      let input = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      // Bug #174: Safari does expose a wrong numberOfOutputs for MediaStreamAudioDestinationNodes.\n      if (output < 0 || output >= this._nativeAudioNode.numberOfOutputs) {\n        throw createIndexSizeError();\n      }\n      const nativeContext = getNativeContext(this._context);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n      if (isNativeAudioNode(destination) || isNativeAudioParam(destination)) {\n        throw createInvalidAccessError();\n      }\n      if (isAudioNode(destination)) {\n        const nativeDestinationAudioNode = getNativeAudioNode(destination);\n        try {\n          const connection = connectNativeAudioNodeToNativeAudioNode(this._nativeAudioNode, nativeDestinationAudioNode, output, input);\n          const isPassive = isPassiveAudioNode(this);\n          if (isOffline || isPassive) {\n            this._nativeAudioNode.disconnect(...connection);\n          }\n          if (this.context.state !== 'closed' && !isPassive && isPassiveAudioNode(destination)) {\n            setInternalStateToActive(destination);\n          }\n        } catch (err) {\n          // Bug #41: Safari does not throw the correct exception so far.\n          if (err.code === 12) {\n            throw createInvalidAccessError();\n          }\n          throw err;\n        }\n        const isNewConnectionToAudioNode = addConnectionToAudioNode(this, destination, output, input, isOffline);\n        // Bug #164: Only Firefox detects cycles so far.\n        if (isNewConnectionToAudioNode) {\n          const cycles = detectCycles([this], destination);\n          visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n        }\n        return destination;\n      }\n      const nativeAudioParam = getNativeAudioParam(destination);\n      /*\n       * Bug #73, #147 & #153: Safari does not support to connect an input signal to the playbackRate AudioParam of an\n       * AudioBufferSourceNode. This can't be easily detected and that's why the outdated name property is used here to identify\n       * Safari. In addition to that the maxValue property is used to only detect the affected versions below v14.0.2.\n       */\n      if (nativeAudioParam.name === 'playbackRate' && nativeAudioParam.maxValue === 1024) {\n        throw createNotSupportedError();\n      }\n      try {\n        this._nativeAudioNode.connect(nativeAudioParam, output);\n        if (isOffline || isPassiveAudioNode(this)) {\n          this._nativeAudioNode.disconnect(nativeAudioParam, output);\n        }\n      } catch (err) {\n        // Bug #58: Safari doesn't throw an InvalidAccessError yet.\n        if (err.code === 12) {\n          throw createInvalidAccessError();\n        }\n        throw err;\n      }\n      const isNewConnectionToAudioParam = addConnectionToAudioParamOfAudioContext(this, destination, output, isOffline);\n      // Bug #164: Only Firefox detects cycles so far.\n      if (isNewConnectionToAudioParam) {\n        const cycles = detectCycles([this], destination);\n        visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n      }\n    }\n    disconnect(destinationOrOutput, output, input) {\n      let destinations;\n      const nativeContext = getNativeContext(this._context);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n      if (destinationOrOutput === undefined) {\n        destinations = deleteAnyConnection(this, isOffline);\n      } else if (typeof destinationOrOutput === 'number') {\n        if (destinationOrOutput < 0 || destinationOrOutput >= this.numberOfOutputs) {\n          throw createIndexSizeError();\n        }\n        destinations = deleteConnectionAtOutput(this, isOffline, destinationOrOutput);\n      } else {\n        if (output !== undefined && (output < 0 || output >= this.numberOfOutputs)) {\n          throw createIndexSizeError();\n        }\n        if (isAudioNode(destinationOrOutput) && input !== undefined && (input < 0 || input >= destinationOrOutput.numberOfInputs)) {\n          throw createIndexSizeError();\n        }\n        destinations = deleteConnectionToDestination(this, isOffline, destinationOrOutput, output, input);\n        if (destinations.length === 0) {\n          throw createInvalidAccessError();\n        }\n      }\n      // Bug #164: Only Firefox detects cycles so far.\n      for (const destination of destinations) {\n        const cycles = detectCycles([this], destination);\n        visitEachAudioNodeOnce(cycles, decrementCycleCounter);\n      }\n    }\n  };\n};","map":{"version":3,"names":["AUDIO_NODE_STORE","EVENT_LISTENERS","isAudioNode","isAudioNodeOutputConnection","addActiveInputConnectionToAudioParam","addPassiveInputConnectionToAudioParam","connectNativeAudioNodeToNativeAudioNode","deleteActiveInputConnection","deleteActiveInputConnectionToAudioParam","deleteEventListenerOfAudioNode","deletePassiveInputConnectionToAudioNode","deletePassiveInputConnectionToAudioParam","disconnectNativeAudioNodeFromNativeAudioNode","getAudioNodeConnections","getAudioParamConnections","getEventListenersOfAudioNode","getNativeAudioNode","getNativeAudioParam","insertElementInSet","isActiveAudioNode","isPartOfACycle","isPassiveAudioNode","setInternalStateToActive","setInternalStateToPassiveWhenNecessary","testAudioNodeDisconnectMethodSupport","visitEachAudioNodeOnce","wrapAudioNodeDisconnectMethod","addConnectionToAudioParamOfAudioContext","source","destination","output","isOffline","activeInputs","passiveInputs","outputs","eventListeners","eventListener","isActive","nativeAudioNode","nativeAudioParam","partialConnection","connect","disconnect","outputConnection","add","deleteInputConnectionOfAudioNode","input","activeInputConnection","passiveInputConnection","deleteInputConnectionOfAudioParam","deleteInputsOfAudioNode","listener","deleteInputsOfAudioParam","deleteAnyConnection","audioNodeConnectionsOfSource","destinations","push","clear","deleteConnectionAtOutput","delete","deleteConnectionToDestination","Array","from","filter","undefined","map","createAudioNodeConstructor","addAudioNodeConnections","addConnectionToAudioNode","cacheTestResult","createIncrementCycleCounter","createIndexSizeError","createInvalidAccessError","createNotSupportedError","decrementCycleCounter","detectCycles","eventTargetConstructor","getNativeContext","isNativeAudioContext","isNativeAudioNode","isNativeAudioParam","isNativeOfflineAudioContext","nativeAudioWorkletNodeConstructor","AudioNode","constructor","context","audioNodeRenderer","_context","_nativeAudioNode","nativeContext","set","Set","state","channelCount","value","channelCountMode","channelInterpretation","numberOfInputs","numberOfOutputs","arguments","length","nativeDestinationAudioNode","connection","isPassive","err","code","isNewConnectionToAudioNode","cycles","name","maxValue","isNewConnectionToAudioParam","destinationOrOutput"],"sources":["/Users/ianstrom/Development/code/Capstone/client/node_modules/standardized-audio-context/src/factories/audio-node-constructor.ts"],"sourcesContent":["import { AUDIO_NODE_STORE, EVENT_LISTENERS } from '../globals';\nimport { isAudioNode } from '../guards/audio-node';\nimport { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nimport { addActiveInputConnectionToAudioParam } from '../helpers/add-active-input-connection-to-audio-param';\nimport { addPassiveInputConnectionToAudioParam } from '../helpers/add-passive-input-connection-to-audio-param';\nimport { connectNativeAudioNodeToNativeAudioNode } from '../helpers/connect-native-audio-node-to-native-audio-node';\nimport { deleteActiveInputConnection } from '../helpers/delete-active-input-connection';\nimport { deleteActiveInputConnectionToAudioParam } from '../helpers/delete-active-input-connection-to-audio-param';\nimport { deleteEventListenerOfAudioNode } from '../helpers/delete-event-listeners-of-audio-node';\nimport { deletePassiveInputConnectionToAudioNode } from '../helpers/delete-passive-input-connection-to-audio-node';\nimport { deletePassiveInputConnectionToAudioParam } from '../helpers/delete-passive-input-connection-to-audio-param';\nimport { disconnectNativeAudioNodeFromNativeAudioNode } from '../helpers/disconnect-native-audio-node-from-native-audio-node';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioParamConnections } from '../helpers/get-audio-param-connections';\nimport { getEventListenersOfAudioNode } from '../helpers/get-event-listeners-of-audio-node';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { getNativeAudioParam } from '../helpers/get-native-audio-param';\nimport { insertElementInSet } from '../helpers/insert-element-in-set';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { isPartOfACycle } from '../helpers/is-part-of-a-cycle';\nimport { isPassiveAudioNode } from '../helpers/is-passive-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassiveWhenNecessary } from '../helpers/set-internal-state-to-passive-when-necessary';\nimport { testAudioNodeDisconnectMethodSupport } from '../helpers/test-audio-node-disconnect-method-support';\nimport { visitEachAudioNodeOnce } from '../helpers/visit-each-audio-node-once';\nimport { wrapAudioNodeDisconnectMethod } from '../helpers/wrap-audio-node-disconnect-method';\nimport {\n    IAudioNode,\n    IAudioNodeRenderer,\n    IAudioParam,\n    IMinimalOfflineAudioContext,\n    INativeAudioNodeFaker,\n    IOfflineAudioContext\n} from '../interfaces';\nimport {\n    TAudioNodeConstructorFactory,\n    TChannelCountMode,\n    TChannelInterpretation,\n    TContext,\n    TInternalStateEventListener,\n    TNativeAudioNode,\n    TNativeAudioParam\n} from '../types';\n\nconst addConnectionToAudioParamOfAudioContext = <T extends TContext>(\n    source: IAudioNode<T>,\n    destination: IAudioParam,\n    output: number,\n    isOffline: boolean\n): boolean => {\n    const { activeInputs, passiveInputs } = getAudioParamConnections<T>(destination);\n    const { outputs } = getAudioNodeConnections(source);\n    const eventListeners = getEventListenersOfAudioNode(source);\n\n    const eventListener: TInternalStateEventListener = (isActive) => {\n        const nativeAudioNode = getNativeAudioNode(source);\n        const nativeAudioParam = getNativeAudioParam(destination);\n\n        if (isActive) {\n            const partialConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n\n            addActiveInputConnectionToAudioParam(activeInputs, source, partialConnection, false);\n\n            if (!isOffline && !isPartOfACycle(source)) {\n                nativeAudioNode.connect(nativeAudioParam, output);\n            }\n        } else {\n            const partialConnection = deleteActiveInputConnectionToAudioParam(activeInputs, source, output);\n\n            addPassiveInputConnectionToAudioParam(passiveInputs, partialConnection, false);\n\n            if (!isOffline && !isPartOfACycle(source)) {\n                nativeAudioNode.disconnect(nativeAudioParam, output);\n            }\n        }\n    };\n\n    if (\n        insertElementInSet(\n            outputs,\n            [destination, output],\n            (outputConnection) => outputConnection[0] === destination && outputConnection[1] === output,\n            true\n        )\n    ) {\n        eventListeners.add(eventListener);\n\n        if (isActiveAudioNode(source)) {\n            addActiveInputConnectionToAudioParam(activeInputs, source, [output, eventListener], true);\n        } else {\n            addPassiveInputConnectionToAudioParam(passiveInputs, [source, output, eventListener], true);\n        }\n\n        return true;\n    }\n\n    return false;\n};\n\nconst deleteInputConnectionOfAudioNode = <T extends TContext>(\n    source: IAudioNode<T>,\n    destination: IAudioNode<T>,\n    output: number,\n    input: number\n): [null | TInternalStateEventListener, boolean] => {\n    const { activeInputs, passiveInputs } = getAudioNodeConnections(destination);\n\n    const activeInputConnection = deleteActiveInputConnection(activeInputs[input], source, output);\n\n    if (activeInputConnection === null) {\n        const passiveInputConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n\n        return [passiveInputConnection[2], false];\n    }\n\n    return [activeInputConnection[2], true];\n};\n\nconst deleteInputConnectionOfAudioParam = <T extends TContext>(\n    source: IAudioNode<T>,\n    destination: IAudioParam,\n    output: number\n): [null | TInternalStateEventListener, boolean] => {\n    const { activeInputs, passiveInputs } = getAudioParamConnections<T>(destination);\n\n    const activeInputConnection = deleteActiveInputConnection(activeInputs, source, output);\n\n    if (activeInputConnection === null) {\n        const passiveInputConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n\n        return [passiveInputConnection[1], false];\n    }\n\n    return [activeInputConnection[2], true];\n};\n\nconst deleteInputsOfAudioNode = <T extends TContext>(\n    source: IAudioNode<T>,\n    isOffline: boolean,\n    destination: IAudioNode<T>,\n    output: number,\n    input: number\n) => {\n    const [listener, isActive] = deleteInputConnectionOfAudioNode(source, destination, output, input);\n\n    if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n\n        if (isActive && !isOffline && !isPartOfACycle(source)) {\n            disconnectNativeAudioNodeFromNativeAudioNode(getNativeAudioNode(source), getNativeAudioNode(destination), output, input);\n        }\n    }\n\n    if (isActiveAudioNode(destination)) {\n        const { activeInputs } = getAudioNodeConnections(destination);\n\n        setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n    }\n};\n\nconst deleteInputsOfAudioParam = <T extends TContext>(\n    source: IAudioNode<T>,\n    isOffline: boolean,\n    destination: IAudioParam,\n    output: number\n) => {\n    const [listener, isActive] = deleteInputConnectionOfAudioParam(source, destination, output);\n\n    if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n\n        if (isActive && !isOffline && !isPartOfACycle(source)) {\n            getNativeAudioNode(source).disconnect(getNativeAudioParam(destination), output);\n        }\n    }\n};\n\nconst deleteAnyConnection = <T extends TContext>(source: IAudioNode<T>, isOffline: boolean): (IAudioNode<T> | IAudioParam)[] => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    const destinations = [];\n\n    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n        if (isAudioNodeOutputConnection(outputConnection)) {\n            deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n        } else {\n            deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n        }\n\n        destinations.push(outputConnection[0]);\n    }\n\n    audioNodeConnectionsOfSource.outputs.clear();\n\n    return destinations;\n};\n\nconst deleteConnectionAtOutput = <T extends TContext>(\n    source: IAudioNode<T>,\n    isOffline: boolean,\n    output: number\n): (IAudioNode<T> | IAudioParam)[] => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    const destinations = [];\n\n    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n        if (outputConnection[1] === output) {\n            if (isAudioNodeOutputConnection(outputConnection)) {\n                deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n            } else {\n                deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n            }\n\n            destinations.push(outputConnection[0]);\n            audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n        }\n    }\n\n    return destinations;\n};\n\nconst deleteConnectionToDestination = <T extends TContext, U extends TContext>(\n    source: IAudioNode<T>,\n    isOffline: boolean,\n    destination: IAudioNode<U> | IAudioParam,\n    output?: number,\n    input?: number\n): (IAudioNode<T> | IAudioParam)[] => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n\n    return Array.from(audioNodeConnectionsOfSource.outputs)\n        .filter(\n            (outputConnection) =>\n                outputConnection[0] === destination &&\n                (output === undefined || outputConnection[1] === output) &&\n                (input === undefined || outputConnection[2] === input)\n        )\n        .map((outputConnection) => {\n            if (isAudioNodeOutputConnection(outputConnection)) {\n                deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n            } else {\n                deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n            }\n\n            audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n\n            return outputConnection[0];\n        });\n};\n\nexport const createAudioNodeConstructor: TAudioNodeConstructorFactory = (\n    addAudioNodeConnections,\n    addConnectionToAudioNode,\n    cacheTestResult,\n    createIncrementCycleCounter,\n    createIndexSizeError,\n    createInvalidAccessError,\n    createNotSupportedError,\n    decrementCycleCounter,\n    detectCycles,\n    eventTargetConstructor,\n    getNativeContext,\n    isNativeAudioContext,\n    isNativeAudioNode,\n    isNativeAudioParam,\n    isNativeOfflineAudioContext,\n    nativeAudioWorkletNodeConstructor\n) => {\n    return class AudioNode<T extends TContext, EventMap extends Record<string, Event> = {}>\n        extends eventTargetConstructor<EventMap>\n        implements IAudioNode<T, EventMap>\n    {\n        private _context: T;\n\n        private _nativeAudioNode: INativeAudioNodeFaker | TNativeAudioNode;\n\n        constructor(\n            context: T,\n            isActive: boolean,\n            nativeAudioNode: INativeAudioNodeFaker | TNativeAudioNode,\n            audioNodeRenderer: T extends IMinimalOfflineAudioContext | IOfflineAudioContext ? IAudioNodeRenderer<T, IAudioNode<T>> : null\n        ) {\n            super(nativeAudioNode);\n\n            this._context = context;\n            this._nativeAudioNode = nativeAudioNode;\n\n            const nativeContext = getNativeContext(context);\n\n            // Bug #12: Safari does not support to disconnect a specific destination.\n            if (\n                isNativeAudioContext(nativeContext) &&\n                true !==\n                    cacheTestResult(testAudioNodeDisconnectMethodSupport, () => {\n                        return testAudioNodeDisconnectMethodSupport(nativeContext, nativeAudioWorkletNodeConstructor);\n                    })\n            ) {\n                wrapAudioNodeDisconnectMethod(nativeAudioNode);\n            }\n\n            AUDIO_NODE_STORE.set(this, nativeAudioNode);\n            EVENT_LISTENERS.set(this, new Set());\n\n            if (context.state !== 'closed' && isActive) {\n                setInternalStateToActive(this);\n            }\n\n            addAudioNodeConnections(this, audioNodeRenderer, nativeAudioNode);\n        }\n\n        get channelCount(): number {\n            return this._nativeAudioNode.channelCount;\n        }\n\n        set channelCount(value) {\n            this._nativeAudioNode.channelCount = value;\n        }\n\n        get channelCountMode(): TChannelCountMode {\n            return this._nativeAudioNode.channelCountMode;\n        }\n\n        set channelCountMode(value) {\n            this._nativeAudioNode.channelCountMode = value;\n        }\n\n        get channelInterpretation(): TChannelInterpretation {\n            return this._nativeAudioNode.channelInterpretation;\n        }\n\n        set channelInterpretation(value) {\n            this._nativeAudioNode.channelInterpretation = value;\n        }\n\n        get context(): T {\n            return this._context;\n        }\n\n        get numberOfInputs(): number {\n            return this._nativeAudioNode.numberOfInputs;\n        }\n\n        get numberOfOutputs(): number {\n            return this._nativeAudioNode.numberOfOutputs;\n        }\n\n        public connect<U extends TContext, V extends IAudioNode<U>>(destinationNode: V, output?: number, input?: number): V;\n        public connect(destinationParam: IAudioParam, output?: number): void;\n        // tslint:disable-next-line:invalid-void\n        public connect<U extends TContext, V extends IAudioNode<U>>(destination: V | IAudioParam, output = 0, input = 0): void | V {\n            // Bug #174: Safari does expose a wrong numberOfOutputs for MediaStreamAudioDestinationNodes.\n            if (output < 0 || output >= this._nativeAudioNode.numberOfOutputs) {\n                throw createIndexSizeError();\n            }\n\n            const nativeContext = getNativeContext(this._context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n\n            if (isNativeAudioNode(destination) || isNativeAudioParam(destination)) {\n                throw createInvalidAccessError();\n            }\n\n            if (isAudioNode(destination)) {\n                const nativeDestinationAudioNode = getNativeAudioNode(destination);\n\n                try {\n                    const connection = connectNativeAudioNodeToNativeAudioNode(\n                        this._nativeAudioNode,\n                        nativeDestinationAudioNode,\n                        output,\n                        input\n                    );\n\n                    const isPassive = isPassiveAudioNode(this);\n\n                    if (isOffline || isPassive) {\n                        this._nativeAudioNode.disconnect(...connection);\n                    }\n\n                    if (this.context.state !== 'closed' && !isPassive && isPassiveAudioNode(destination)) {\n                        setInternalStateToActive(destination);\n                    }\n                } catch (err) {\n                    // Bug #41: Safari does not throw the correct exception so far.\n                    if (err.code === 12) {\n                        throw createInvalidAccessError();\n                    }\n\n                    throw err;\n                }\n\n                const isNewConnectionToAudioNode = addConnectionToAudioNode(\n                    this,\n                    <IAudioNode<TContext>>destination,\n                    output,\n                    input,\n                    isOffline\n                );\n\n                // Bug #164: Only Firefox detects cycles so far.\n                if (isNewConnectionToAudioNode) {\n                    const cycles = detectCycles([this], <IAudioNode<T>>(<unknown>destination));\n\n                    visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n                }\n\n                return destination;\n            }\n\n            const nativeAudioParam = getNativeAudioParam(destination);\n\n            /*\n             * Bug #73, #147 & #153: Safari does not support to connect an input signal to the playbackRate AudioParam of an\n             * AudioBufferSourceNode. This can't be easily detected and that's why the outdated name property is used here to identify\n             * Safari. In addition to that the maxValue property is used to only detect the affected versions below v14.0.2.\n             */\n            if ((<TNativeAudioParam & { name: string }>nativeAudioParam).name === 'playbackRate' && nativeAudioParam.maxValue === 1024) {\n                throw createNotSupportedError();\n            }\n\n            try {\n                this._nativeAudioNode.connect(nativeAudioParam, output);\n\n                if (isOffline || isPassiveAudioNode(this)) {\n                    this._nativeAudioNode.disconnect(nativeAudioParam, output);\n                }\n            } catch (err) {\n                // Bug #58: Safari doesn't throw an InvalidAccessError yet.\n                if (err.code === 12) {\n                    throw createInvalidAccessError();\n                }\n\n                throw err;\n            }\n\n            const isNewConnectionToAudioParam = addConnectionToAudioParamOfAudioContext(this, destination, output, isOffline);\n\n            // Bug #164: Only Firefox detects cycles so far.\n            if (isNewConnectionToAudioParam) {\n                const cycles = detectCycles([this], destination);\n\n                visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n            }\n        }\n\n        public disconnect(output?: number): void;\n        public disconnect<U extends TContext>(destinationNode: IAudioNode<U>, output?: number, input?: number): void;\n        public disconnect(destinationParam: IAudioParam, output?: number): void;\n        public disconnect<U extends TContext>(\n            destinationOrOutput?: number | IAudioNode<U> | IAudioParam,\n            output?: number,\n            input?: number\n        ): void {\n            let destinations: (IAudioNode<T> | IAudioParam)[];\n\n            const nativeContext = getNativeContext(this._context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n\n            if (destinationOrOutput === undefined) {\n                destinations = deleteAnyConnection(this, isOffline);\n            } else if (typeof destinationOrOutput === 'number') {\n                if (destinationOrOutput < 0 || destinationOrOutput >= this.numberOfOutputs) {\n                    throw createIndexSizeError();\n                }\n\n                destinations = deleteConnectionAtOutput(this, isOffline, destinationOrOutput);\n            } else {\n                if (output !== undefined && (output < 0 || output >= this.numberOfOutputs)) {\n                    throw createIndexSizeError();\n                }\n\n                if (isAudioNode(destinationOrOutput) && input !== undefined && (input < 0 || input >= destinationOrOutput.numberOfInputs)) {\n                    throw createIndexSizeError();\n                }\n\n                destinations = deleteConnectionToDestination(this, isOffline, destinationOrOutput, output, input);\n\n                if (destinations.length === 0) {\n                    throw createInvalidAccessError();\n                }\n            }\n\n            // Bug #164: Only Firefox detects cycles so far.\n            for (const destination of destinations) {\n                const cycles = detectCycles([this], destination);\n\n                visitEachAudioNodeOnce(cycles, decrementCycleCounter);\n            }\n        }\n    };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}