{"ast":null,"code":"import { Gain } from \"../../core/context/Gain\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { AudioToGain } from \"../../signal/AudioToGain\";\nimport { Scale } from \"../../signal/Scale\";\nimport { connectSignal, Signal } from \"../../signal/Signal\";\nimport { Zero } from \"../../signal/Zero\";\nimport { Oscillator } from \"./Oscillator\";\n/**\n * LFO stands for low frequency oscillator. LFO produces an output signal\n * which can be attached to an AudioParam or Tone.Signal\n * in order to modulate that parameter with an oscillator. The LFO can\n * also be synced to the transport to start/stop and change when the tempo changes.\n * @example\n * return Tone.Offline(() => {\n * \tconst lfo = new Tone.LFO(\"4n\", 400, 4000).start().toDestination();\n * }, 0.5, 1);\n * @category Source\n */\nexport class LFO extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(LFO.getDefaults(), arguments, [\"frequency\", \"min\", \"max\"]));\n    this.name = \"LFO\";\n    /**\n     * The value that the LFO outputs when it's stopped\n     */\n    this._stoppedValue = 0;\n    /**\n     * A private placeholder for the units\n     */\n    this._units = \"number\";\n    /**\n     * If the input value is converted using the [[units]]\n     */\n    this.convert = true;\n    /**\n     * Private methods borrowed from Param\n     */\n    // @ts-ignore\n    this._fromType = Param.prototype._fromType;\n    // @ts-ignore\n    this._toType = Param.prototype._toType;\n    // @ts-ignore\n    this._is = Param.prototype._is;\n    // @ts-ignore\n    this._clampValue = Param.prototype._clampValue;\n    const options = optionsFromArguments(LFO.getDefaults(), arguments, [\"frequency\", \"min\", \"max\"]);\n    this._oscillator = new Oscillator(options);\n    this.frequency = this._oscillator.frequency;\n    this._amplitudeGain = new Gain({\n      context: this.context,\n      gain: options.amplitude,\n      units: \"normalRange\"\n    });\n    this.amplitude = this._amplitudeGain.gain;\n    this._stoppedSignal = new Signal({\n      context: this.context,\n      units: \"audioRange\",\n      value: 0\n    });\n    this._zeros = new Zero({\n      context: this.context\n    });\n    this._a2g = new AudioToGain({\n      context: this.context\n    });\n    this._scaler = this.output = new Scale({\n      context: this.context,\n      max: options.max,\n      min: options.min\n    });\n    this.units = options.units;\n    this.min = options.min;\n    this.max = options.max;\n    // connect it up\n    this._oscillator.chain(this._amplitudeGain, this._a2g, this._scaler);\n    this._zeros.connect(this._a2g);\n    this._stoppedSignal.connect(this._a2g);\n    readOnly(this, [\"amplitude\", \"frequency\"]);\n    this.phase = options.phase;\n  }\n  static getDefaults() {\n    return Object.assign(Oscillator.getDefaults(), {\n      amplitude: 1,\n      frequency: \"4n\",\n      max: 1,\n      min: 0,\n      type: \"sine\",\n      units: \"number\"\n    });\n  }\n  /**\n   * Start the LFO.\n   * @param time The time the LFO will start\n   */\n  start(time) {\n    time = this.toSeconds(time);\n    this._stoppedSignal.setValueAtTime(0, time);\n    this._oscillator.start(time);\n    return this;\n  }\n  /**\n   * Stop the LFO.\n   * @param  time The time the LFO will stop\n   */\n  stop(time) {\n    time = this.toSeconds(time);\n    this._stoppedSignal.setValueAtTime(this._stoppedValue, time);\n    this._oscillator.stop(time);\n    return this;\n  }\n  /**\n   * Sync the start/stop/pause to the transport\n   * and the frequency to the bpm of the transport\n   * @example\n   * const lfo = new Tone.LFO(\"8n\");\n   * lfo.sync().start(0);\n   * // the rate of the LFO will always be an eighth note, even as the tempo changes\n   */\n  sync() {\n    this._oscillator.sync();\n    this._oscillator.syncFrequency();\n    return this;\n  }\n  /**\n   * unsync the LFO from transport control\n   */\n  unsync() {\n    this._oscillator.unsync();\n    this._oscillator.unsyncFrequency();\n    return this;\n  }\n  /**\n   * After the oscillator waveform is updated, reset the `_stoppedSignal` value to match the updated waveform\n   */\n  _setStoppedValue() {\n    this._stoppedValue = this._oscillator.getInitialValue();\n    this._stoppedSignal.value = this._stoppedValue;\n  }\n  /**\n   * The minimum output of the LFO.\n   */\n  get min() {\n    return this._toType(this._scaler.min);\n  }\n  set min(min) {\n    min = this._fromType(min);\n    this._scaler.min = min;\n  }\n  /**\n   * The maximum output of the LFO.\n   */\n  get max() {\n    return this._toType(this._scaler.max);\n  }\n  set max(max) {\n    max = this._fromType(max);\n    this._scaler.max = max;\n  }\n  /**\n   * The type of the oscillator: See [[Oscillator.type]]\n   */\n  get type() {\n    return this._oscillator.type;\n  }\n  set type(type) {\n    this._oscillator.type = type;\n    this._setStoppedValue();\n  }\n  /**\n   * The oscillator's partials array: See [[Oscillator.partials]]\n   */\n  get partials() {\n    return this._oscillator.partials;\n  }\n  set partials(partials) {\n    this._oscillator.partials = partials;\n    this._setStoppedValue();\n  }\n  /**\n   * The phase of the LFO.\n   */\n  get phase() {\n    return this._oscillator.phase;\n  }\n  set phase(phase) {\n    this._oscillator.phase = phase;\n    this._setStoppedValue();\n  }\n  /**\n   * The output units of the LFO.\n   */\n  get units() {\n    return this._units;\n  }\n  set units(val) {\n    const currentMin = this.min;\n    const currentMax = this.max;\n    // convert the min and the max\n    this._units = val;\n    this.min = currentMin;\n    this.max = currentMax;\n  }\n  /**\n   * Returns the playback state of the source, either \"started\" or \"stopped\".\n   */\n  get state() {\n    return this._oscillator.state;\n  }\n  /**\n   * @param node the destination to connect to\n   * @param outputNum the optional output number\n   * @param inputNum the input number\n   */\n  connect(node, outputNum, inputNum) {\n    if (node instanceof Param || node instanceof Signal) {\n      this.convert = node.convert;\n      this.units = node.units;\n    }\n    connectSignal(this, node, outputNum, inputNum);\n    return this;\n  }\n  dispose() {\n    super.dispose();\n    this._oscillator.dispose();\n    this._stoppedSignal.dispose();\n    this._zeros.dispose();\n    this._scaler.dispose();\n    this._a2g.dispose();\n    this._amplitudeGain.dispose();\n    this.amplitude.dispose();\n    return this;\n  }\n}","map":{"version":3,"names":["Gain","Param","ToneAudioNode","optionsFromArguments","readOnly","AudioToGain","Scale","connectSignal","Signal","Zero","Oscillator","LFO","constructor","getDefaults","arguments","name","_stoppedValue","_units","convert","_fromType","prototype","_toType","_is","_clampValue","options","_oscillator","frequency","_amplitudeGain","context","gain","amplitude","units","_stoppedSignal","value","_zeros","_a2g","_scaler","output","max","min","chain","connect","phase","Object","assign","type","start","time","toSeconds","setValueAtTime","stop","sync","syncFrequency","unsync","unsyncFrequency","_setStoppedValue","getInitialValue","partials","val","currentMin","currentMax","state","node","outputNum","inputNum","dispose"],"sources":["/Users/ianstrom/Development/code/Capstone/client/node_modules/tone/Tone/source/oscillator/LFO.ts"],"sourcesContent":["import { Gain } from \"../../core/context/Gain\";\nimport { Param } from \"../../core/context/Param\";\nimport { InputNode, OutputNode, ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { Degrees, Frequency, NormalRange, Time, UnitName } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { BasicPlaybackState } from \"../../core/util/StateTimeline\";\nimport { AudioToGain } from \"../../signal/AudioToGain\";\nimport { Scale } from \"../../signal/Scale\";\nimport { connectSignal, Signal } from \"../../signal/Signal\";\nimport { Zero } from \"../../signal/Zero\";\nimport { Oscillator, ToneOscillatorType } from \"./Oscillator\";\nimport { ToneOscillatorConstructorOptions, ToneOscillatorOptions } from \"./OscillatorInterface\";\n\nexport type LFOOptions = {\n\tmin: number;\n\tmax: number;\n\tamplitude: NormalRange;\n\tunits: UnitName;\n} & ToneOscillatorOptions;\n\n/**\n * LFO stands for low frequency oscillator. LFO produces an output signal\n * which can be attached to an AudioParam or Tone.Signal\n * in order to modulate that parameter with an oscillator. The LFO can\n * also be synced to the transport to start/stop and change when the tempo changes.\n * @example\n * return Tone.Offline(() => {\n * \tconst lfo = new Tone.LFO(\"4n\", 400, 4000).start().toDestination();\n * }, 0.5, 1);\n * @category Source\n */\nexport class LFO extends ToneAudioNode<LFOOptions> {\n\n\treadonly name: string = \"LFO\";\n\n\t/**\n\t * The oscillator.\n\t */\n\tprivate _oscillator: Oscillator;\n\n\t/**\n\t * The gain of the output\n\t */\n\tprivate _amplitudeGain: Gain<\"normalRange\">;\n\n\t/**\n\t * The amplitude of the LFO, which controls the output range between\n\t * the min and max output. For example if the min is -10 and the max\n\t * is 10, setting the amplitude to 0.5 would make the LFO modulate\n\t * between -5 and 5.\n\t */\n\treadonly amplitude: Param<\"normalRange\">;\n\n\t/**\n\t * The signal which is output when the LFO is stopped\n\t */\n\tprivate _stoppedSignal: Signal<\"audioRange\">;\n\n\t/**\n\t * Just outputs zeros. This is used so that scaled signal is not\n\t * optimized to silence.\n\t */\n\tprivate _zeros: Zero;\n\n\t/**\n\t * The value that the LFO outputs when it's stopped\n\t */\n\tprivate _stoppedValue = 0;\n\n\t/**\n\t * Convert the oscillators audio range to an output between 0-1 so it can be scaled\n\t */\n\tprivate _a2g: AudioToGain;\n\n\t/**\n\t * Scales the final output to the min and max value\n\t */\n\tprivate _scaler: Scale;\n\n\t/**\n\t * The output of the LFO\n\t */\n\treadonly output: OutputNode;\n\n\t/**\n\t * There is no input node\n\t */\n\treadonly input: undefined;\n\n\t/**\n\t * A private placeholder for the units\n\t */\n\tprivate _units: UnitName = \"number\";\n\n\t/**\n\t * If the input value is converted using the [[units]]\n\t */\n\tconvert = true;\n\n\t/**\n\t * The frequency value of the LFO\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * @param frequency The frequency of the oscillation.\n\t * Typically, LFOs will be in the frequency range of 0.1 to 10 hertz.\n\t * @param min The minimum output value of the LFO.\n\t * @param max The maximum value of the LFO.\n\t */\n\tconstructor(frequency?: Frequency, min?: number, max?: number);\n\tconstructor(options?: Partial<LFOOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(LFO.getDefaults(), arguments, [\"frequency\", \"min\", \"max\"]));\n\t\tconst options = optionsFromArguments(LFO.getDefaults(), arguments, [\"frequency\", \"min\", \"max\"]);\n\n\t\tthis._oscillator = new Oscillator(options as ToneOscillatorConstructorOptions);\n\n\t\tthis.frequency = this._oscillator.frequency;\n\n\t\tthis._amplitudeGain = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.amplitude,\n\t\t\tunits: \"normalRange\",\n\t\t});\n\t\tthis.amplitude = this._amplitudeGain.gain;\n\t\tthis._stoppedSignal = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"audioRange\",\n\t\t\tvalue: 0,\n\t\t});\n\t\tthis._zeros = new Zero({ context: this.context });\n\t\tthis._a2g = new AudioToGain({ context: this.context });\n\t\tthis._scaler = this.output = new Scale({\n\t\t\tcontext: this.context,\n\t\t\tmax: options.max,\n\t\t\tmin: options.min,\n\t\t});\n\n\t\tthis.units = options.units;\n\t\tthis.min = options.min;\n\t\tthis.max = options.max;\n\n\t\t// connect it up\n\t\tthis._oscillator.chain(this._amplitudeGain, this._a2g, this._scaler);\n\t\tthis._zeros.connect(this._a2g);\n\t\tthis._stoppedSignal.connect(this._a2g);\n\t\treadOnly(this, [\"amplitude\", \"frequency\"]);\n\t\tthis.phase = options.phase;\n\t}\n\n\tstatic getDefaults(): LFOOptions {\n\t\treturn Object.assign(Oscillator.getDefaults(), {\n\t\t\tamplitude: 1,\n\t\t\tfrequency: \"4n\",\n\t\t\tmax: 1,\n\t\t\tmin: 0,\n\t\t\ttype: \"sine\",\n\t\t\tunits: \"number\" as UnitName,\n\t\t});\n\t}\n\n\t/**\n\t * Start the LFO.\n\t * @param time The time the LFO will start\n\t */\n\tstart(time?: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._stoppedSignal.setValueAtTime(0, time);\n\t\tthis._oscillator.start(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the LFO.\n\t * @param  time The time the LFO will stop\n\t */\n\tstop(time?: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._stoppedSignal.setValueAtTime(this._stoppedValue, time);\n\t\tthis._oscillator.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the start/stop/pause to the transport\n\t * and the frequency to the bpm of the transport\n\t * @example\n\t * const lfo = new Tone.LFO(\"8n\");\n\t * lfo.sync().start(0);\n\t * // the rate of the LFO will always be an eighth note, even as the tempo changes\n\t */\n\tsync(): this {\n\t\tthis._oscillator.sync();\n\t\tthis._oscillator.syncFrequency();\n\t\treturn this;\n\t}\n\n\t/**\n\t * unsync the LFO from transport control\n\t */\n\tunsync(): this {\n\t\tthis._oscillator.unsync();\n\t\tthis._oscillator.unsyncFrequency();\n\t\treturn this;\n\t}\n\n\t/**\n\t * After the oscillator waveform is updated, reset the `_stoppedSignal` value to match the updated waveform\n\t */\n\tprivate _setStoppedValue() {\n\t\tthis._stoppedValue = this._oscillator.getInitialValue();\n\t\tthis._stoppedSignal.value = this._stoppedValue;\n\t}\n\n\t/**\n\t * The minimum output of the LFO.\n\t */\n\tget min(): number {\n\t\treturn this._toType(this._scaler.min);\n\t}\n\tset min(min) {\n\t\tmin = this._fromType(min);\n\t\tthis._scaler.min = min;\n\t}\n\n\t/**\n\t * The maximum output of the LFO.\n\t */\n\tget max(): number {\n\t\treturn this._toType(this._scaler.max);\n\t}\n\tset max(max) {\n\t\tmax = this._fromType(max);\n\t\tthis._scaler.max = max;\n\t}\n\n\t/**\n\t * The type of the oscillator: See [[Oscillator.type]]\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._oscillator.type;\n\t}\n\tset type(type) {\n\t\tthis._oscillator.type = type;\n\t\tthis._setStoppedValue();\n\t}\n\n\t/**\n\t * The oscillator's partials array: See [[Oscillator.partials]]\n\t */\n\tget partials(): number[] {\n\t\treturn this._oscillator.partials;\n\t}\n\tset partials(partials) {\n\t\tthis._oscillator.partials = partials;\n\t\tthis._setStoppedValue();\n\t}\n\n\t/**\n\t * The phase of the LFO.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._oscillator.phase;\n\t}\n\tset phase(phase) {\n\t\tthis._oscillator.phase = phase;\n\t\tthis._setStoppedValue();\n\t}\n\n\t/**\n\t * The output units of the LFO.\n\t */\n\tget units(): UnitName {\n\t\treturn this._units;\n\t}\n\tset units(val) {\n\t\tconst currentMin = this.min;\n\t\tconst currentMax = this.max;\n\t\t// convert the min and the max\n\t\tthis._units = val;\n\t\tthis.min = currentMin;\n\t\tthis.max = currentMax;\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\" or \"stopped\".\n\t */\n\tget state(): BasicPlaybackState {\n\t\treturn this._oscillator.state;\n\t}\n\n\t/**\n\t * @param node the destination to connect to\n\t * @param outputNum the optional output number\n\t * @param inputNum the input number\n\t */\n\tconnect(node: InputNode, outputNum?: number, inputNum?: number): this {\n\t\tif (node instanceof Param || node instanceof Signal) {\n\t\t\tthis.convert = node.convert;\n\t\t\tthis.units = node.units;\n\t\t}\n\t\tconnectSignal(this, node, outputNum, inputNum);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Private methods borrowed from Param\n\t */\n\t// @ts-ignore\n\tprivate _fromType = Param.prototype._fromType;\n\t// @ts-ignore\n\tprivate _toType = Param.prototype._toType;\n\t// @ts-ignore\n\tprivate _is = Param.prototype._is;\n\t// @ts-ignore\n\tprivate _clampValue = Param.prototype._clampValue;\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._oscillator.dispose();\n\t\tthis._stoppedSignal.dispose();\n\t\tthis._zeros.dispose();\n\t\tthis._scaler.dispose();\n\t\tthis._a2g.dispose();\n\t\tthis._amplitudeGain.dispose();\n\t\tthis.amplitude.dispose();\n\t\treturn this;\n\t}\n}\n"],"mappings":"AAAA,SAASA,IAAI,QAAQ,yBAAyB;AAC9C,SAASC,KAAK,QAAQ,0BAA0B;AAChD,SAAgCC,aAAa,QAAQ,kCAAkC;AAEvF,SAASC,oBAAoB,QAAQ,0BAA0B;AAC/D,SAASC,QAAQ,QAAQ,2BAA2B;AAEpD,SAASC,WAAW,QAAQ,0BAA0B;AACtD,SAASC,KAAK,QAAQ,oBAAoB;AAC1C,SAASC,aAAa,EAAEC,MAAM,QAAQ,qBAAqB;AAC3D,SAASC,IAAI,QAAQ,mBAAmB;AACxC,SAASC,UAAU,QAA4B,cAAc;AAU7D;;;;;;;;;;;AAWA,OAAM,MAAOC,GAAI,SAAQT,aAAyB;EAiFjDU,YAAA;IAEC,KAAK,CAACT,oBAAoB,CAACQ,GAAG,CAACE,WAAW,EAAE,EAAEC,SAAS,EAAE,CAAC,WAAW,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC;IAjF9E,KAAAC,IAAI,GAAW,KAAK;IA+B7B;;;IAGQ,KAAAC,aAAa,GAAG,CAAC;IAsBzB;;;IAGQ,KAAAC,MAAM,GAAa,QAAQ;IAEnC;;;IAGA,KAAAC,OAAO,GAAG,IAAI;IAkNd;;;IAGA;IACQ,KAAAC,SAAS,GAAGlB,KAAK,CAACmB,SAAS,CAACD,SAAS;IAC7C;IACQ,KAAAE,OAAO,GAAGpB,KAAK,CAACmB,SAAS,CAACC,OAAO;IACzC;IACQ,KAAAC,GAAG,GAAGrB,KAAK,CAACmB,SAAS,CAACE,GAAG;IACjC;IACQ,KAAAC,WAAW,GAAGtB,KAAK,CAACmB,SAAS,CAACG,WAAW;IA1MhD,MAAMC,OAAO,GAAGrB,oBAAoB,CAACQ,GAAG,CAACE,WAAW,EAAE,EAAEC,SAAS,EAAE,CAAC,WAAW,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;IAE/F,IAAI,CAACW,WAAW,GAAG,IAAIf,UAAU,CAACc,OAA2C,CAAC;IAE9E,IAAI,CAACE,SAAS,GAAG,IAAI,CAACD,WAAW,CAACC,SAAS;IAE3C,IAAI,CAACC,cAAc,GAAG,IAAI3B,IAAI,CAAC;MAC9B4B,OAAO,EAAE,IAAI,CAACA,OAAO;MACrBC,IAAI,EAAEL,OAAO,CAACM,SAAS;MACvBC,KAAK,EAAE;KACP,CAAC;IACF,IAAI,CAACD,SAAS,GAAG,IAAI,CAACH,cAAc,CAACE,IAAI;IACzC,IAAI,CAACG,cAAc,GAAG,IAAIxB,MAAM,CAAC;MAChCoB,OAAO,EAAE,IAAI,CAACA,OAAO;MACrBG,KAAK,EAAE,YAAY;MACnBE,KAAK,EAAE;KACP,CAAC;IACF,IAAI,CAACC,MAAM,GAAG,IAAIzB,IAAI,CAAC;MAAEmB,OAAO,EAAE,IAAI,CAACA;IAAO,CAAE,CAAC;IACjD,IAAI,CAACO,IAAI,GAAG,IAAI9B,WAAW,CAAC;MAAEuB,OAAO,EAAE,IAAI,CAACA;IAAO,CAAE,CAAC;IACtD,IAAI,CAACQ,OAAO,GAAG,IAAI,CAACC,MAAM,GAAG,IAAI/B,KAAK,CAAC;MACtCsB,OAAO,EAAE,IAAI,CAACA,OAAO;MACrBU,GAAG,EAAEd,OAAO,CAACc,GAAG;MAChBC,GAAG,EAAEf,OAAO,CAACe;KACb,CAAC;IAEF,IAAI,CAACR,KAAK,GAAGP,OAAO,CAACO,KAAK;IAC1B,IAAI,CAACQ,GAAG,GAAGf,OAAO,CAACe,GAAG;IACtB,IAAI,CAACD,GAAG,GAAGd,OAAO,CAACc,GAAG;IAEtB;IACA,IAAI,CAACb,WAAW,CAACe,KAAK,CAAC,IAAI,CAACb,cAAc,EAAE,IAAI,CAACQ,IAAI,EAAE,IAAI,CAACC,OAAO,CAAC;IACpE,IAAI,CAACF,MAAM,CAACO,OAAO,CAAC,IAAI,CAACN,IAAI,CAAC;IAC9B,IAAI,CAACH,cAAc,CAACS,OAAO,CAAC,IAAI,CAACN,IAAI,CAAC;IACtC/B,QAAQ,CAAC,IAAI,EAAE,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC;IAC1C,IAAI,CAACsC,KAAK,GAAGlB,OAAO,CAACkB,KAAK;EAC3B;EAEA,OAAO7B,WAAWA,CAAA;IACjB,OAAO8B,MAAM,CAACC,MAAM,CAAClC,UAAU,CAACG,WAAW,EAAE,EAAE;MAC9CiB,SAAS,EAAE,CAAC;MACZJ,SAAS,EAAE,IAAI;MACfY,GAAG,EAAE,CAAC;MACNC,GAAG,EAAE,CAAC;MACNM,IAAI,EAAE,MAAM;MACZd,KAAK,EAAE;KACP,CAAC;EACH;EAEA;;;;EAIAe,KAAKA,CAACC,IAAW;IAChBA,IAAI,GAAG,IAAI,CAACC,SAAS,CAACD,IAAI,CAAC;IAC3B,IAAI,CAACf,cAAc,CAACiB,cAAc,CAAC,CAAC,EAAEF,IAAI,CAAC;IAC3C,IAAI,CAACtB,WAAW,CAACqB,KAAK,CAACC,IAAI,CAAC;IAC5B,OAAO,IAAI;EACZ;EAEA;;;;EAIAG,IAAIA,CAACH,IAAW;IACfA,IAAI,GAAG,IAAI,CAACC,SAAS,CAACD,IAAI,CAAC;IAC3B,IAAI,CAACf,cAAc,CAACiB,cAAc,CAAC,IAAI,CAACjC,aAAa,EAAE+B,IAAI,CAAC;IAC5D,IAAI,CAACtB,WAAW,CAACyB,IAAI,CAACH,IAAI,CAAC;IAC3B,OAAO,IAAI;EACZ;EAEA;;;;;;;;EAQAI,IAAIA,CAAA;IACH,IAAI,CAAC1B,WAAW,CAAC0B,IAAI,EAAE;IACvB,IAAI,CAAC1B,WAAW,CAAC2B,aAAa,EAAE;IAChC,OAAO,IAAI;EACZ;EAEA;;;EAGAC,MAAMA,CAAA;IACL,IAAI,CAAC5B,WAAW,CAAC4B,MAAM,EAAE;IACzB,IAAI,CAAC5B,WAAW,CAAC6B,eAAe,EAAE;IAClC,OAAO,IAAI;EACZ;EAEA;;;EAGQC,gBAAgBA,CAAA;IACvB,IAAI,CAACvC,aAAa,GAAG,IAAI,CAACS,WAAW,CAAC+B,eAAe,EAAE;IACvD,IAAI,CAACxB,cAAc,CAACC,KAAK,GAAG,IAAI,CAACjB,aAAa;EAC/C;EAEA;;;EAGA,IAAIuB,GAAGA,CAAA;IACN,OAAO,IAAI,CAAClB,OAAO,CAAC,IAAI,CAACe,OAAO,CAACG,GAAG,CAAC;EACtC;EACA,IAAIA,GAAGA,CAACA,GAAG;IACVA,GAAG,GAAG,IAAI,CAACpB,SAAS,CAACoB,GAAG,CAAC;IACzB,IAAI,CAACH,OAAO,CAACG,GAAG,GAAGA,GAAG;EACvB;EAEA;;;EAGA,IAAID,GAAGA,CAAA;IACN,OAAO,IAAI,CAACjB,OAAO,CAAC,IAAI,CAACe,OAAO,CAACE,GAAG,CAAC;EACtC;EACA,IAAIA,GAAGA,CAACA,GAAG;IACVA,GAAG,GAAG,IAAI,CAACnB,SAAS,CAACmB,GAAG,CAAC;IACzB,IAAI,CAACF,OAAO,CAACE,GAAG,GAAGA,GAAG;EACvB;EAEA;;;EAGA,IAAIO,IAAIA,CAAA;IACP,OAAO,IAAI,CAACpB,WAAW,CAACoB,IAAI;EAC7B;EACA,IAAIA,IAAIA,CAACA,IAAI;IACZ,IAAI,CAACpB,WAAW,CAACoB,IAAI,GAAGA,IAAI;IAC5B,IAAI,CAACU,gBAAgB,EAAE;EACxB;EAEA;;;EAGA,IAAIE,QAAQA,CAAA;IACX,OAAO,IAAI,CAAChC,WAAW,CAACgC,QAAQ;EACjC;EACA,IAAIA,QAAQA,CAACA,QAAQ;IACpB,IAAI,CAAChC,WAAW,CAACgC,QAAQ,GAAGA,QAAQ;IACpC,IAAI,CAACF,gBAAgB,EAAE;EACxB;EAEA;;;EAGA,IAAIb,KAAKA,CAAA;IACR,OAAO,IAAI,CAACjB,WAAW,CAACiB,KAAK;EAC9B;EACA,IAAIA,KAAKA,CAACA,KAAK;IACd,IAAI,CAACjB,WAAW,CAACiB,KAAK,GAAGA,KAAK;IAC9B,IAAI,CAACa,gBAAgB,EAAE;EACxB;EAEA;;;EAGA,IAAIxB,KAAKA,CAAA;IACR,OAAO,IAAI,CAACd,MAAM;EACnB;EACA,IAAIc,KAAKA,CAAC2B,GAAG;IACZ,MAAMC,UAAU,GAAG,IAAI,CAACpB,GAAG;IAC3B,MAAMqB,UAAU,GAAG,IAAI,CAACtB,GAAG;IAC3B;IACA,IAAI,CAACrB,MAAM,GAAGyC,GAAG;IACjB,IAAI,CAACnB,GAAG,GAAGoB,UAAU;IACrB,IAAI,CAACrB,GAAG,GAAGsB,UAAU;EACtB;EAEA;;;EAGA,IAAIC,KAAKA,CAAA;IACR,OAAO,IAAI,CAACpC,WAAW,CAACoC,KAAK;EAC9B;EAEA;;;;;EAKApB,OAAOA,CAACqB,IAAe,EAAEC,SAAkB,EAAEC,QAAiB;IAC7D,IAAIF,IAAI,YAAY7D,KAAK,IAAI6D,IAAI,YAAYtD,MAAM,EAAE;MACpD,IAAI,CAACU,OAAO,GAAG4C,IAAI,CAAC5C,OAAO;MAC3B,IAAI,CAACa,KAAK,GAAG+B,IAAI,CAAC/B,KAAK;;IAExBxB,aAAa,CAAC,IAAI,EAAEuD,IAAI,EAAEC,SAAS,EAAEC,QAAQ,CAAC;IAC9C,OAAO,IAAI;EACZ;EAcAC,OAAOA,CAAA;IACN,KAAK,CAACA,OAAO,EAAE;IACf,IAAI,CAACxC,WAAW,CAACwC,OAAO,EAAE;IAC1B,IAAI,CAACjC,cAAc,CAACiC,OAAO,EAAE;IAC7B,IAAI,CAAC/B,MAAM,CAAC+B,OAAO,EAAE;IACrB,IAAI,CAAC7B,OAAO,CAAC6B,OAAO,EAAE;IACtB,IAAI,CAAC9B,IAAI,CAAC8B,OAAO,EAAE;IACnB,IAAI,CAACtC,cAAc,CAACsC,OAAO,EAAE;IAC7B,IAAI,CAACnC,SAAS,CAACmC,OAAO,EAAE;IACxB,OAAO,IAAI;EACZ"},"metadata":{},"sourceType":"module","externalDependencies":[]}