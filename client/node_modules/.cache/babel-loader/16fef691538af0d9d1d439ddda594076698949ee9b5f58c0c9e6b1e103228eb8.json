{"ast":null,"code":"import { assert } from \"../core/util/Debug\";\nimport { clamp } from \"../core/util/Math\";\n/**\n * Start at the first value and go up to the last\n */\nfunction* upPatternGen(values) {\n  let index = 0;\n  while (index < values.length) {\n    index = clampToArraySize(index, values);\n    yield values[index];\n    index++;\n  }\n}\n/**\n * Start at the last value and go down to 0\n */\nfunction* downPatternGen(values) {\n  let index = values.length - 1;\n  while (index >= 0) {\n    index = clampToArraySize(index, values);\n    yield values[index];\n    index--;\n  }\n}\n/**\n * Infinitely yield the generator\n */\nfunction* infiniteGen(values, gen) {\n  while (true) {\n    yield* gen(values);\n  }\n}\n/**\n * Make sure that the index is in the given range\n */\nfunction clampToArraySize(index, values) {\n  return clamp(index, 0, values.length - 1);\n}\n/**\n * Alternate between two generators\n */\nfunction* alternatingGenerator(values, directionUp) {\n  let index = directionUp ? 0 : values.length - 1;\n  while (true) {\n    index = clampToArraySize(index, values);\n    yield values[index];\n    if (directionUp) {\n      index++;\n      if (index >= values.length - 1) {\n        directionUp = false;\n      }\n    } else {\n      index--;\n      if (index <= 0) {\n        directionUp = true;\n      }\n    }\n  }\n}\n/**\n * Starting from the bottom move up 2, down 1\n */\nfunction* jumpUp(values) {\n  let index = 0;\n  let stepIndex = 0;\n  while (index < values.length) {\n    index = clampToArraySize(index, values);\n    yield values[index];\n    stepIndex++;\n    index += stepIndex % 2 ? 2 : -1;\n  }\n}\n/**\n * Starting from the top move down 2, up 1\n */\nfunction* jumpDown(values) {\n  let index = values.length - 1;\n  let stepIndex = 0;\n  while (index >= 0) {\n    index = clampToArraySize(index, values);\n    yield values[index];\n    stepIndex++;\n    index += stepIndex % 2 ? -2 : 1;\n  }\n}\n/**\n * Choose a random index each time\n */\nfunction* randomGen(values) {\n  while (true) {\n    const randomIndex = Math.floor(Math.random() * values.length);\n    yield values[randomIndex];\n  }\n}\n/**\n * Randomly go through all of the values once before choosing a new random order\n */\nfunction* randomOnce(values) {\n  // create an array of indices\n  const copy = [];\n  for (let i = 0; i < values.length; i++) {\n    copy.push(i);\n  }\n  while (copy.length > 0) {\n    // random choose an index, and then remove it so it's not chosen again\n    const randVal = copy.splice(Math.floor(copy.length * Math.random()), 1);\n    const index = clampToArraySize(randVal[0], values);\n    yield values[index];\n  }\n}\n/**\n * Randomly choose to walk up or down 1 index in the values array\n */\nfunction* randomWalk(values) {\n  // randomly choose a starting index in the values array\n  let index = Math.floor(Math.random() * values.length);\n  while (true) {\n    if (index === 0) {\n      index++; // at bottom of array, so force upward step\n    } else if (index === values.length - 1) {\n      index--; // at top of array, so force downward step\n    } else if (Math.random() < 0.5) {\n      // else choose random downward or upward step\n      index--;\n    } else {\n      index++;\n    }\n    yield values[index];\n  }\n}\n/**\n * PatternGenerator returns a generator which will iterate over the given array\n * of values and yield the items according to the passed in pattern\n * @param values An array of values to iterate over\n * @param pattern The name of the pattern use when iterating over\n * @param index Where to start in the offset of the values array\n */\nexport function PatternGenerator(values) {\n  let pattern = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"up\";\n  let index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  return function* () {\n    // safeguards\n    assert(values.length > 0, \"The array must have more than one value in it\");\n    switch (pattern) {\n      case \"up\":\n        yield* infiniteGen(values, upPatternGen);\n      case \"down\":\n        yield* infiniteGen(values, downPatternGen);\n      case \"upDown\":\n        yield* alternatingGenerator(values, true);\n      case \"downUp\":\n        yield* alternatingGenerator(values, false);\n      case \"alternateUp\":\n        yield* infiniteGen(values, jumpUp);\n      case \"alternateDown\":\n        yield* infiniteGen(values, jumpDown);\n      case \"random\":\n        yield* randomGen(values);\n      case \"randomOnce\":\n        yield* infiniteGen(values, randomOnce);\n      case \"randomWalk\":\n        yield* randomWalk(values);\n    }\n  }();\n}","map":{"version":3,"names":["assert","clamp","upPatternGen","values","index","length","clampToArraySize","downPatternGen","infiniteGen","gen","alternatingGenerator","directionUp","jumpUp","stepIndex","jumpDown","randomGen","randomIndex","Math","floor","random","randomOnce","copy","i","push","randVal","splice","randomWalk","PatternGenerator","pattern","arguments","undefined"],"sources":["/Users/ianstrom/Development/code/Capstone/node_modules/tone/Tone/event/PatternGenerator.ts"],"sourcesContent":["import { assert } from \"../core/util/Debug\";\nimport { clamp } from \"../core/util/Math\";\n\n/**\n * The name of the patterns\n */\nexport type PatternName = \"up\" | \"down\" | \"upDown\" | \"downUp\" | \"alternateUp\" | \"alternateDown\" | \"random\" | \"randomOnce\" | \"randomWalk\";\n\n/**\n * Start at the first value and go up to the last\n */\nfunction* upPatternGen<T>(values: T[]): IterableIterator<T> {\n\tlet index = 0;\n\twhile (index < values.length) {\n\t\tindex = clampToArraySize(index, values);\n\t\tyield values[index];\n\t\tindex++;\n\t}\n}\n\n/**\n * Start at the last value and go down to 0\n */\nfunction* downPatternGen<T>(values: T[]): IterableIterator<T> {\n\tlet index = values.length - 1;\n\twhile (index >= 0) {\n\t\tindex = clampToArraySize(index, values);\n\t\tyield values[index];\n\t\tindex--;\n\t}\n}\n\n/**\n * Infinitely yield the generator\n */\nfunction* infiniteGen<T>(values: T[], gen: typeof upPatternGen): IterableIterator<T> {\n\twhile (true) {\n\t\tyield* gen(values);\n\t}\n}\n\n/**\n * Make sure that the index is in the given range\n */\nfunction clampToArraySize(index: number, values: any[]): number {\n\treturn clamp(index, 0, values.length - 1);\n}\n\n/**\n * Alternate between two generators\n */\nfunction* alternatingGenerator<T>(values: T[], directionUp: boolean): IterableIterator<T> {\n\tlet index = directionUp ? 0 : values.length - 1;\n\twhile (true) {\n\t\tindex = clampToArraySize(index, values);\n\t\tyield values[index];\n\t\tif (directionUp) {\n\t\t\tindex++;\n\t\t\tif (index >= values.length - 1) {\n\t\t\t\tdirectionUp = false;\n\t\t\t}\n\t\t} else {\n\t\t\tindex--;\n\t\t\tif (index <= 0) {\n\t\t\t\tdirectionUp = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Starting from the bottom move up 2, down 1\n */\nfunction* jumpUp<T>(values: T[]): IterableIterator<T> {\n\tlet index = 0;\n\tlet stepIndex = 0;\n\twhile (index < values.length) {\n\t\tindex = clampToArraySize(index, values);\n\t\tyield values[index];\n\t\tstepIndex++;\n\t\tindex += (stepIndex % 2 ? 2 : -1);\n\t}\n}\n\n/**\n * Starting from the top move down 2, up 1\n */\nfunction* jumpDown<T>(values: T[]): IterableIterator<T> {\n\tlet index = values.length - 1;\n\tlet stepIndex = 0;\n\twhile (index >= 0) {\n\t\tindex = clampToArraySize(index, values);\n\t\tyield values[index];\n\t\tstepIndex++;\n\t\tindex += (stepIndex % 2 ? -2 : 1);\n\t}\n}\n\n/**\n * Choose a random index each time\n */\nfunction* randomGen<T>(values: T[]): IterableIterator<T> {\n\twhile (true) {\n\t\tconst randomIndex = Math.floor(Math.random() * values.length);\n\t\tyield values[randomIndex];\n\t}\n}\n\n/**\n * Randomly go through all of the values once before choosing a new random order\n */\nfunction* randomOnce<T>(values: T[]): IterableIterator<T> {\n\t// create an array of indices\n\tconst copy: number[] = [];\n\tfor (let i = 0; i < values.length; i++) {\n\t\tcopy.push(i);\n\t}\n\twhile (copy.length > 0) {\n\t\t// random choose an index, and then remove it so it's not chosen again\n\t\tconst randVal = copy.splice(Math.floor(copy.length * Math.random()), 1);\n\t\tconst index = clampToArraySize(randVal[0], values);\n\t\tyield values[index];\n\t}\n}\n\n/**\n * Randomly choose to walk up or down 1 index in the values array\n */\nfunction* randomWalk<T>(values: T[]): IterableIterator<T> {\n\t// randomly choose a starting index in the values array\n\tlet index = Math.floor(Math.random() * values.length);\n\twhile (true) {\n\t\tif (index === 0) {\n\t\t\tindex++; // at bottom of array, so force upward step\n\t\t} else if (index === values.length - 1) {\n\t\t\tindex--; // at top of array, so force downward step\n\t\t} else if (Math.random() < 0.5) { // else choose random downward or upward step\n\t\t\tindex--;\n\t\t} else {\n\t\t\tindex++;\n\t\t}\n\t\tyield values[index];\n\t}\n}\n\n/**\n * PatternGenerator returns a generator which will iterate over the given array\n * of values and yield the items according to the passed in pattern\n * @param values An array of values to iterate over\n * @param pattern The name of the pattern use when iterating over\n * @param index Where to start in the offset of the values array\n */\nexport function* PatternGenerator<T>(values: T[], pattern: PatternName = \"up\", index = 0): Iterator<T> {\n\t// safeguards\n\tassert(values.length > 0, \"The array must have more than one value in it\");\n\tswitch (pattern) {\n\t\tcase \"up\" :\n\t\t\tyield* infiniteGen(values, upPatternGen);\n\t\tcase \"down\" :\n\t\t\tyield* infiniteGen(values, downPatternGen);\n\t\tcase \"upDown\" :\n\t\t\tyield* alternatingGenerator(values, true);\n\t\tcase \"downUp\" :\n\t\t\tyield* alternatingGenerator(values, false);\n\t\tcase \"alternateUp\":\n\t\t\tyield* infiniteGen(values, jumpUp);\n\t\tcase \"alternateDown\":\n\t\t\tyield* infiniteGen(values, jumpDown);\n\t\tcase \"random\":\n\t\t\tyield* randomGen(values);\n\t\tcase \"randomOnce\":\n\t\t\tyield* infiniteGen(values, randomOnce);\n\t\tcase \"randomWalk\":\n\t\t\tyield* randomWalk(values);\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}