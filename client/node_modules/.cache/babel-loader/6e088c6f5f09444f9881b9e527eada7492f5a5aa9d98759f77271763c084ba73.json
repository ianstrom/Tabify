{"ast":null,"code":"import { Gain } from \"../../core/context/Gain\";\nimport { connectSeries, ToneAudioNode } from \"../../core/context/ToneAudioNode\";\n/**\n * PhaseShiftAllpass is an very efficient implementation of a Hilbert Transform\n * using two Allpass filter banks whose outputs have a phase difference of 90째.\n * Here the `offset90` phase is offset by +90째 in relation to `output`.\n * Coefficients and structure was developed by Olli Niemitalo.\n * For more details see: http://yehar.com/blog/?p=368\n * @category Component\n */\nexport class PhaseShiftAllpass extends ToneAudioNode {\n  constructor(options) {\n    super(options);\n    this.name = \"PhaseShiftAllpass\";\n    this.input = new Gain({\n      context: this.context\n    });\n    /**\n     * The phase shifted output\n     */\n    this.output = new Gain({\n      context: this.context\n    });\n    /**\n     * The PhaseShifted allpass output\n     */\n    this.offset90 = new Gain({\n      context: this.context\n    });\n    const allpassBank1Values = [0.6923878, 0.9360654322959, 0.9882295226860, 0.9987488452737];\n    const allpassBank2Values = [0.4021921162426, 0.8561710882420, 0.9722909545651, 0.9952884791278];\n    this._bank0 = this._createAllPassFilterBank(allpassBank1Values);\n    this._bank1 = this._createAllPassFilterBank(allpassBank2Values);\n    this._oneSampleDelay = this.context.createIIRFilter([0.0, 1.0], [1.0, 0.0]);\n    // connect Allpass filter banks\n    connectSeries(this.input, ...this._bank0, this._oneSampleDelay, this.output);\n    connectSeries(this.input, ...this._bank1, this.offset90);\n  }\n  /**\n   * Create all of the IIR filters from an array of values using the coefficient calculation.\n   */\n  _createAllPassFilterBank(bankValues) {\n    const nodes = bankValues.map(value => {\n      const coefficients = [[value * value, 0, -1], [1, 0, -(value * value)]];\n      return this.context.createIIRFilter(coefficients[0], coefficients[1]);\n    });\n    return nodes;\n  }\n  dispose() {\n    super.dispose();\n    this.input.dispose();\n    this.output.dispose();\n    this.offset90.dispose();\n    this._bank0.forEach(f => f.disconnect());\n    this._bank1.forEach(f => f.disconnect());\n    this._oneSampleDelay.disconnect();\n    return this;\n  }\n}","map":{"version":3,"names":["Gain","connectSeries","ToneAudioNode","PhaseShiftAllpass","constructor","options","name","input","context","output","offset90","allpassBank1Values","allpassBank2Values","_bank0","_createAllPassFilterBank","_bank1","_oneSampleDelay","createIIRFilter","bankValues","nodes","map","value","coefficients","dispose","forEach","f","disconnect"],"sources":["/Users/ianstrom/Development/code/Capstone/node_modules/tone/Tone/component/filter/PhaseShiftAllpass.ts"],"sourcesContent":["import { Gain } from \"../../core/context/Gain\";\nimport { connectSeries, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\n\n/**\n * PhaseShiftAllpass is an very efficient implementation of a Hilbert Transform\n * using two Allpass filter banks whose outputs have a phase difference of 90째.\n * Here the `offset90` phase is offset by +90째 in relation to `output`.\n * Coefficients and structure was developed by Olli Niemitalo.\n * For more details see: http://yehar.com/blog/?p=368\n * @category Component\n */\nexport class PhaseShiftAllpass extends ToneAudioNode<ToneAudioNodeOptions> {\n\n\treadonly name: string = \"PhaseShiftAllpass\";\n\n\treadonly input = new Gain({ context: this.context });\n\n\t/**\n\t * The Allpass filter in the first bank\n\t */\n\tprivate _bank0: IIRFilterNode[];\n\n\t/**\n\t * The Allpass filter in the seconds bank\n\t */\n\tprivate _bank1: IIRFilterNode[];\n\n\t/**\n\t * A IIR filter implementing a delay by one sample used by the first bank\n\t */\n\tprivate _oneSampleDelay: IIRFilterNode;\n\n\t/**\n\t * The phase shifted output\n\t */\n\treadonly output = new Gain({ context: this.context });\n\n\t/**\n\t * The PhaseShifted allpass output\n\t */\n\treadonly offset90 = new Gain({ context: this.context });\n\n\tconstructor(options?: Partial<ToneAudioNodeOptions>) {\n\n\t\tsuper(options);\n\n\t\tconst allpassBank1Values = [0.6923878, 0.9360654322959, 0.9882295226860, 0.9987488452737];\n\t\tconst allpassBank2Values = [0.4021921162426, 0.8561710882420, 0.9722909545651, 0.9952884791278];\n\n\t\tthis._bank0 = this._createAllPassFilterBank(allpassBank1Values);\n\t\tthis._bank1 = this._createAllPassFilterBank(allpassBank2Values);\n\t\tthis._oneSampleDelay = this.context.createIIRFilter([0.0, 1.0], [1.0, 0.0]);\n\n\t\t// connect Allpass filter banks\n\t\tconnectSeries(this.input, ...this._bank0, this._oneSampleDelay, this.output);\n\t\tconnectSeries(this.input, ...this._bank1, this.offset90);\n\t}\n\n\t/**\n\t * Create all of the IIR filters from an array of values using the coefficient calculation.\n\t */\n\tprivate _createAllPassFilterBank(bankValues: number[]): IIRFilterNode[] {\n\t\tconst nodes: IIRFilterNode[] = bankValues.map(value => {\n\t\t\tconst coefficients = [[value * value, 0, -1], [1, 0, -(value * value)]];\n\t\t\treturn this.context.createIIRFilter(coefficients[0], coefficients[1]);\n\t\t});\n\n\t\treturn nodes;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis.output.dispose();\n\t\tthis.offset90.dispose();\n\t\tthis._bank0.forEach(f => f.disconnect());\n\t\tthis._bank1.forEach(f => f.disconnect());\n\t\tthis._oneSampleDelay.disconnect();\n\t\treturn this;\n\t}\n}\n"],"mappings":"AAAA,SAASA,IAAI,QAAQ,yBAAyB;AAC9C,SAASC,aAAa,EAAEC,aAAa,QAA8B,kCAAkC;AAErG;;;;;;;;AAQA,OAAM,MAAOC,iBAAkB,SAAQD,aAAmC;EA+BzEE,YAAYC,OAAuC;IAElD,KAAK,CAACA,OAAO,CAAC;IA/BN,KAAAC,IAAI,GAAW,mBAAmB;IAElC,KAAAC,KAAK,GAAG,IAAIP,IAAI,CAAC;MAAEQ,OAAO,EAAE,IAAI,CAACA;IAAO,CAAE,CAAC;IAiBpD;;;IAGS,KAAAC,MAAM,GAAG,IAAIT,IAAI,CAAC;MAAEQ,OAAO,EAAE,IAAI,CAACA;IAAO,CAAE,CAAC;IAErD;;;IAGS,KAAAE,QAAQ,GAAG,IAAIV,IAAI,CAAC;MAAEQ,OAAO,EAAE,IAAI,CAACA;IAAO,CAAE,CAAC;IAMtD,MAAMG,kBAAkB,GAAG,CAAC,SAAS,EAAE,eAAe,EAAE,eAAe,EAAE,eAAe,CAAC;IACzF,MAAMC,kBAAkB,GAAG,CAAC,eAAe,EAAE,eAAe,EAAE,eAAe,EAAE,eAAe,CAAC;IAE/F,IAAI,CAACC,MAAM,GAAG,IAAI,CAACC,wBAAwB,CAACH,kBAAkB,CAAC;IAC/D,IAAI,CAACI,MAAM,GAAG,IAAI,CAACD,wBAAwB,CAACF,kBAAkB,CAAC;IAC/D,IAAI,CAACI,eAAe,GAAG,IAAI,CAACR,OAAO,CAACS,eAAe,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;IAE3E;IACAhB,aAAa,CAAC,IAAI,CAACM,KAAK,EAAE,GAAG,IAAI,CAACM,MAAM,EAAE,IAAI,CAACG,eAAe,EAAE,IAAI,CAACP,MAAM,CAAC;IAC5ER,aAAa,CAAC,IAAI,CAACM,KAAK,EAAE,GAAG,IAAI,CAACQ,MAAM,EAAE,IAAI,CAACL,QAAQ,CAAC;EACzD;EAEA;;;EAGQI,wBAAwBA,CAACI,UAAoB;IACpD,MAAMC,KAAK,GAAoBD,UAAU,CAACE,GAAG,CAACC,KAAK,IAAG;MACrD,MAAMC,YAAY,GAAG,CAAC,CAACD,KAAK,GAAGA,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,EAAEA,KAAK,GAAGA,KAAK,CAAC,CAAC,CAAC;MACvE,OAAO,IAAI,CAACb,OAAO,CAACS,eAAe,CAACK,YAAY,CAAC,CAAC,CAAC,EAAEA,YAAY,CAAC,CAAC,CAAC,CAAC;IACtE,CAAC,CAAC;IAEF,OAAOH,KAAK;EACb;EAEAI,OAAOA,CAAA;IACN,KAAK,CAACA,OAAO,EAAE;IACf,IAAI,CAAChB,KAAK,CAACgB,OAAO,EAAE;IACpB,IAAI,CAACd,MAAM,CAACc,OAAO,EAAE;IACrB,IAAI,CAACb,QAAQ,CAACa,OAAO,EAAE;IACvB,IAAI,CAACV,MAAM,CAACW,OAAO,CAACC,CAAC,IAAIA,CAAC,CAACC,UAAU,EAAE,CAAC;IACxC,IAAI,CAACX,MAAM,CAACS,OAAO,CAACC,CAAC,IAAIA,CAAC,CAACC,UAAU,EAAE,CAAC;IACxC,IAAI,CAACV,eAAe,CAACU,UAAU,EAAE;IACjC,OAAO,IAAI;EACZ"},"metadata":{},"sourceType":"module","externalDependencies":[]}