{"ast":null,"code":"export function copyFromChannel(audioBuffer,\n// @todo There is currently no way to define something like { [ key: number | string ]: Float32Array }\nparent, key, channelNumber, bufferOffset) {\n  if (typeof audioBuffer.copyFromChannel === 'function') {\n    // The byteLength will be 0 when the ArrayBuffer was transferred.\n    if (parent[key].byteLength === 0) {\n      parent[key] = new Float32Array(128);\n    }\n    audioBuffer.copyFromChannel(parent[key], channelNumber, bufferOffset);\n    // Bug #5: Safari does not support copyFromChannel().\n  } else {\n    const channelData = audioBuffer.getChannelData(channelNumber);\n    // The byteLength will be 0 when the ArrayBuffer was transferred.\n    if (parent[key].byteLength === 0) {\n      parent[key] = channelData.slice(bufferOffset, bufferOffset + 128);\n    } else {\n      const slicedInput = new Float32Array(channelData.buffer, bufferOffset * Float32Array.BYTES_PER_ELEMENT, 128);\n      parent[key].set(slicedInput);\n    }\n  }\n}","map":{"version":3,"names":["copyFromChannel","audioBuffer","parent","key","channelNumber","bufferOffset","byteLength","Float32Array","channelData","getChannelData","slice","slicedInput","buffer","BYTES_PER_ELEMENT","set"],"sources":["/Users/ianstrom/Development/code/Capstone/node_modules/standardized-audio-context/src/helpers/copy-from-channel.ts"],"sourcesContent":["import { TNativeAudioBuffer } from '../types';\n\nexport function copyFromChannel(\n    audioBuffer: TNativeAudioBuffer,\n    parent: { [key: number]: Float32Array },\n    key: number,\n    channelNumber: number,\n    bufferOffset: number\n): void;\nexport function copyFromChannel(\n    audioBuffer: TNativeAudioBuffer,\n    parent: { [key: string]: Float32Array },\n    key: string,\n    channelNumber: number,\n    bufferOffset: number\n): void;\nexport function copyFromChannel(\n    audioBuffer: TNativeAudioBuffer,\n    // @todo There is currently no way to define something like { [ key: number | string ]: Float32Array }\n    parent: any,\n    key: number | string,\n    channelNumber: number,\n    bufferOffset: number\n): void {\n    if (typeof audioBuffer.copyFromChannel === 'function') {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength === 0) {\n            parent[key] = new Float32Array(128);\n        }\n\n        audioBuffer.copyFromChannel(parent[key], channelNumber, bufferOffset);\n\n        // Bug #5: Safari does not support copyFromChannel().\n    } else {\n        const channelData = audioBuffer.getChannelData(channelNumber);\n\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength === 0) {\n            parent[key] = channelData.slice(bufferOffset, bufferOffset + 128);\n        } else {\n            const slicedInput = new Float32Array(channelData.buffer, bufferOffset * Float32Array.BYTES_PER_ELEMENT, 128);\n\n            parent[key].set(slicedInput);\n        }\n    }\n}\n"],"mappings":"AAgBA,OAAM,SAAUA,eAAeA,CAC3BC,WAA+B;AAC/B;AACAC,MAAW,EACXC,GAAoB,EACpBC,aAAqB,EACrBC,YAAoB;EAEpB,IAAI,OAAOJ,WAAW,CAACD,eAAe,KAAK,UAAU,EAAE;IACnD;IACA,IAAIE,MAAM,CAACC,GAAG,CAAC,CAACG,UAAU,KAAK,CAAC,EAAE;MAC9BJ,MAAM,CAACC,GAAG,CAAC,GAAG,IAAII,YAAY,CAAC,GAAG,CAAC;;IAGvCN,WAAW,CAACD,eAAe,CAACE,MAAM,CAACC,GAAG,CAAC,EAAEC,aAAa,EAAEC,YAAY,CAAC;IAErE;GACH,MAAM;IACH,MAAMG,WAAW,GAAGP,WAAW,CAACQ,cAAc,CAACL,aAAa,CAAC;IAE7D;IACA,IAAIF,MAAM,CAACC,GAAG,CAAC,CAACG,UAAU,KAAK,CAAC,EAAE;MAC9BJ,MAAM,CAACC,GAAG,CAAC,GAAGK,WAAW,CAACE,KAAK,CAACL,YAAY,EAAEA,YAAY,GAAG,GAAG,CAAC;KACpE,MAAM;MACH,MAAMM,WAAW,GAAG,IAAIJ,YAAY,CAACC,WAAW,CAACI,MAAM,EAAEP,YAAY,GAAGE,YAAY,CAACM,iBAAiB,EAAE,GAAG,CAAC;MAE5GX,MAAM,CAACC,GAAG,CAAC,CAACW,GAAG,CAACH,WAAW,CAAC;;;AAGxC"},"metadata":{},"sourceType":"module","externalDependencies":[]}