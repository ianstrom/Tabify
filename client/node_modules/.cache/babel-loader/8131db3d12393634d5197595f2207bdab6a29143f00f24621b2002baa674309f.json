{"ast":null,"code":"import { ToneWithContext } from \"../context/ToneWithContext\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { StateTimeline } from \"../util/StateTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { TickSignal } from \"./TickSignal\";\nimport { EQ } from \"../util/Math\";\n/**\n * Uses [TickSignal](TickSignal) to track elapsed ticks with complex automation curves.\n */\nexport class TickSource extends ToneWithContext {\n  constructor() {\n    super(optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]));\n    this.name = \"TickSource\";\n    /**\n     * The state timeline\n     */\n    this._state = new StateTimeline();\n    /**\n     * The offset values of the ticks\n     */\n    this._tickOffset = new Timeline();\n    const options = optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]);\n    this.frequency = new TickSignal({\n      context: this.context,\n      units: options.units,\n      value: options.frequency\n    });\n    readOnly(this, \"frequency\");\n    // set the initial state\n    this._state.setStateAtTime(\"stopped\", 0);\n    // add the first event\n    this.setTicksAtTime(0, 0);\n  }\n  static getDefaults() {\n    return Object.assign({\n      frequency: 1,\n      units: \"hertz\"\n    }, ToneWithContext.getDefaults());\n  }\n  /**\n   * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n   */\n  get state() {\n    return this.getStateAtTime(this.now());\n  }\n  /**\n   * Start the clock at the given time. Optionally pass in an offset\n   * of where to start the tick counter from.\n   * @param  time    The time the clock should start\n   * @param offset The number of ticks to start the source at\n   */\n  start(time, offset) {\n    const computedTime = this.toSeconds(time);\n    if (this._state.getValueAtTime(computedTime) !== \"started\") {\n      this._state.setStateAtTime(\"started\", computedTime);\n      if (isDefined(offset)) {\n        this.setTicksAtTime(offset, computedTime);\n      }\n    }\n    return this;\n  }\n  /**\n   * Stop the clock. Stopping the clock resets the tick counter to 0.\n   * @param time The time when the clock should stop.\n   */\n  stop(time) {\n    const computedTime = this.toSeconds(time);\n    // cancel the previous stop\n    if (this._state.getValueAtTime(computedTime) === \"stopped\") {\n      const event = this._state.get(computedTime);\n      if (event && event.time > 0) {\n        this._tickOffset.cancel(event.time);\n        this._state.cancel(event.time);\n      }\n    }\n    this._state.cancel(computedTime);\n    this._state.setStateAtTime(\"stopped\", computedTime);\n    this.setTicksAtTime(0, computedTime);\n    return this;\n  }\n  /**\n   * Pause the clock. Pausing does not reset the tick counter.\n   * @param time The time when the clock should stop.\n   */\n  pause(time) {\n    const computedTime = this.toSeconds(time);\n    if (this._state.getValueAtTime(computedTime) === \"started\") {\n      this._state.setStateAtTime(\"paused\", computedTime);\n    }\n    return this;\n  }\n  /**\n   * Cancel start/stop/pause and setTickAtTime events scheduled after the given time.\n   * @param time When to clear the events after\n   */\n  cancel(time) {\n    time = this.toSeconds(time);\n    this._state.cancel(time);\n    this._tickOffset.cancel(time);\n    return this;\n  }\n  /**\n   * Get the elapsed ticks at the given time\n   * @param  time  When to get the tick value\n   * @return The number of ticks\n   */\n  getTicksAtTime(time) {\n    const computedTime = this.toSeconds(time);\n    const stopEvent = this._state.getLastState(\"stopped\", computedTime);\n    // this event allows forEachBetween to iterate until the current time\n    const tmpEvent = {\n      state: \"paused\",\n      time: computedTime\n    };\n    this._state.add(tmpEvent);\n    // keep track of the previous offset event\n    let lastState = stopEvent;\n    let elapsedTicks = 0;\n    // iterate through all the events since the last stop\n    this._state.forEachBetween(stopEvent.time, computedTime + this.sampleTime, e => {\n      let periodStartTime = lastState.time;\n      // if there is an offset event in this period use that\n      const offsetEvent = this._tickOffset.get(e.time);\n      if (offsetEvent && offsetEvent.time >= lastState.time) {\n        elapsedTicks = offsetEvent.ticks;\n        periodStartTime = offsetEvent.time;\n      }\n      if (lastState.state === \"started\" && e.state !== \"started\") {\n        elapsedTicks += this.frequency.getTicksAtTime(e.time) - this.frequency.getTicksAtTime(periodStartTime);\n      }\n      lastState = e;\n    });\n    // remove the temporary event\n    this._state.remove(tmpEvent);\n    // return the ticks\n    return elapsedTicks;\n  }\n  /**\n   * The number of times the callback was invoked. Starts counting at 0\n   * and increments after the callback was invoked. Returns -1 when stopped.\n   */\n  get ticks() {\n    return this.getTicksAtTime(this.now());\n  }\n  set ticks(t) {\n    this.setTicksAtTime(t, this.now());\n  }\n  /**\n   * The time since ticks=0 that the TickSource has been running. Accounts\n   * for tempo curves\n   */\n  get seconds() {\n    return this.getSecondsAtTime(this.now());\n  }\n  set seconds(s) {\n    const now = this.now();\n    const ticks = this.frequency.timeToTicks(s, now);\n    this.setTicksAtTime(ticks, now);\n  }\n  /**\n   * Return the elapsed seconds at the given time.\n   * @param  time  When to get the elapsed seconds\n   * @return  The number of elapsed seconds\n   */\n  getSecondsAtTime(time) {\n    time = this.toSeconds(time);\n    const stopEvent = this._state.getLastState(\"stopped\", time);\n    // this event allows forEachBetween to iterate until the current time\n    const tmpEvent = {\n      state: \"paused\",\n      time\n    };\n    this._state.add(tmpEvent);\n    // keep track of the previous offset event\n    let lastState = stopEvent;\n    let elapsedSeconds = 0;\n    // iterate through all the events since the last stop\n    this._state.forEachBetween(stopEvent.time, time + this.sampleTime, e => {\n      let periodStartTime = lastState.time;\n      // if there is an offset event in this period use that\n      const offsetEvent = this._tickOffset.get(e.time);\n      if (offsetEvent && offsetEvent.time >= lastState.time) {\n        elapsedSeconds = offsetEvent.seconds;\n        periodStartTime = offsetEvent.time;\n      }\n      if (lastState.state === \"started\" && e.state !== \"started\") {\n        elapsedSeconds += e.time - periodStartTime;\n      }\n      lastState = e;\n    });\n    // remove the temporary event\n    this._state.remove(tmpEvent);\n    // return the ticks\n    return elapsedSeconds;\n  }\n  /**\n   * Set the clock's ticks at the given time.\n   * @param  ticks The tick value to set\n   * @param  time  When to set the tick value\n   */\n  setTicksAtTime(ticks, time) {\n    time = this.toSeconds(time);\n    this._tickOffset.cancel(time);\n    this._tickOffset.add({\n      seconds: this.frequency.getDurationOfTicks(ticks, time),\n      ticks,\n      time\n    });\n    return this;\n  }\n  /**\n   * Returns the scheduled state at the given time.\n   * @param  time  The time to query.\n   */\n  getStateAtTime(time) {\n    time = this.toSeconds(time);\n    return this._state.getValueAtTime(time);\n  }\n  /**\n   * Get the time of the given tick. The second argument\n   * is when to test before. Since ticks can be set (with setTicksAtTime)\n   * there may be multiple times for a given tick value.\n   * @param  tick The tick number.\n   * @param  before When to measure the tick value from.\n   * @return The time of the tick\n   */\n  getTimeOfTick(tick) {\n    let before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.now();\n    const offset = this._tickOffset.get(before);\n    const event = this._state.get(before);\n    const startTime = Math.max(offset.time, event.time);\n    const absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;\n    return this.frequency.getTimeOfTick(absoluteTicks);\n  }\n  /**\n   * Invoke the callback event at all scheduled ticks between the\n   * start time and the end time\n   * @param  startTime  The beginning of the search range\n   * @param  endTime    The end of the search range\n   * @param  callback   The callback to invoke with each tick\n   */\n  forEachTickBetween(startTime, endTime, callback) {\n    // only iterate through the sections where it is \"started\"\n    let lastStateEvent = this._state.get(startTime);\n    this._state.forEachBetween(startTime, endTime, event => {\n      if (lastStateEvent && lastStateEvent.state === \"started\" && event.state !== \"started\") {\n        this.forEachTickBetween(Math.max(lastStateEvent.time, startTime), event.time - this.sampleTime, callback);\n      }\n      lastStateEvent = event;\n    });\n    let error = null;\n    if (lastStateEvent && lastStateEvent.state === \"started\") {\n      const maxStartTime = Math.max(lastStateEvent.time, startTime);\n      // figure out the difference between the frequency ticks and the\n      const startTicks = this.frequency.getTicksAtTime(maxStartTime);\n      const ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);\n      const diff = startTicks - ticksAtStart;\n      let offset = Math.ceil(diff) - diff;\n      // guard against floating point issues\n      offset = EQ(offset, 1) ? 0 : offset;\n      let nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);\n      while (nextTickTime < endTime) {\n        try {\n          callback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));\n        } catch (e) {\n          error = e;\n          break;\n        }\n        nextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);\n      }\n    }\n    if (error) {\n      throw error;\n    }\n    return this;\n  }\n  /**\n   * Clean up\n   */\n  dispose() {\n    super.dispose();\n    this._state.dispose();\n    this._tickOffset.dispose();\n    this.frequency.dispose();\n    return this;\n  }\n}","map":{"version":3,"names":["ToneWithContext","optionsFromArguments","readOnly","StateTimeline","Timeline","isDefined","TickSignal","EQ","TickSource","constructor","getDefaults","arguments","name","_state","_tickOffset","options","frequency","context","units","value","setStateAtTime","setTicksAtTime","Object","assign","state","getStateAtTime","now","start","time","offset","computedTime","toSeconds","getValueAtTime","stop","event","get","cancel","pause","getTicksAtTime","stopEvent","getLastState","tmpEvent","add","lastState","elapsedTicks","forEachBetween","sampleTime","e","periodStartTime","offsetEvent","ticks","remove","t","seconds","getSecondsAtTime","s","timeToTicks","elapsedSeconds","getDurationOfTicks","getTimeOfTick","tick","before","length","undefined","startTime","Math","max","absoluteTicks","forEachTickBetween","endTime","callback","lastStateEvent","error","maxStartTime","startTicks","ticksAtStart","diff","ceil","nextTickTime","round","dispose"],"sources":["/Users/ianstrom/Development/code/Capstone/node_modules/tone/Tone/core/clock/TickSource.ts"],"sourcesContent":["import { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { Seconds, Ticks, Time } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { PlaybackState, StateTimeline, StateTimelineEvent } from \"../util/StateTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { TickSignal } from \"./TickSignal\";\nimport { EQ } from \"../util/Math\";\n\ninterface TickSourceOptions extends ToneWithContextOptions {\n\tfrequency: number;\n\tunits: \"bpm\" | \"hertz\";\n}\n\ninterface TickSourceOffsetEvent {\n\tticks: number;\n\ttime: number;\n\tseconds: number;\n}\n\n/**\n * Uses [TickSignal](TickSignal) to track elapsed ticks with complex automation curves.\n */\nexport class TickSource<TypeName extends \"bpm\" | \"hertz\"> extends ToneWithContext<TickSourceOptions> {\n\n\treadonly name: string = \"TickSource\";\n\n\t/**\n\t * The frequency the callback function should be invoked.\n\t */\n\treadonly frequency: TickSignal<TypeName>;\n\n\t/**\n\t * The state timeline\n\t */\n\tprivate _state: StateTimeline = new StateTimeline();\n\n\t/**\n\t * The offset values of the ticks\n\t */\n\tprivate _tickOffset: Timeline<TickSourceOffsetEvent> = new Timeline();\n\n\t/**\n\t * @param frequency The initial frequency that the signal ticks at\n\t */\n\tconstructor(frequency?: number);\n\tconstructor(options?: Partial<TickSourceOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]));\n\t\tconst options = optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]);\n\n\t\tthis.frequency = new TickSignal({\n\t\t\tcontext: this.context,\n\t\t\tunits: options.units as TypeName,\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\treadOnly(this, \"frequency\");\n\n\t\t// set the initial state\n\t\tthis._state.setStateAtTime(\"stopped\", 0);\n\t\t// add the first event\n\t\tthis.setTicksAtTime(0, 0);\n\t}\n\n\tstatic getDefaults(): TickSourceOptions {\n\t\treturn Object.assign({\n\t\t\tfrequency: 1,\n\t\t\tunits: \"hertz\" as \"hertz\",\n\t\t}, ToneWithContext.getDefaults());\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n\t */\n\tget state(): PlaybackState {\n\t\treturn this.getStateAtTime(this.now());\n\t}\n\n\t/**\n\t * Start the clock at the given time. Optionally pass in an offset\n\t * of where to start the tick counter from.\n\t * @param  time    The time the clock should start\n\t * @param offset The number of ticks to start the source at\n\t */\n\tstart(time: Time, offset?: Ticks): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) !== \"started\") {\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tif (isDefined(offset)) {\n\t\t\t\tthis.setTicksAtTime(offset, computedTime);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the clock. Stopping the clock resets the tick counter to 0.\n\t * @param time The time when the clock should stop.\n\t */\n\tstop(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\t// cancel the previous stop\n\t\tif (this._state.getValueAtTime(computedTime) === \"stopped\") {\n\t\t\tconst event = this._state.get(computedTime);\n\t\t\tif (event && event.time > 0) {\n\t\t\t\tthis._tickOffset.cancel(event.time);\n\t\t\t\tthis._state.cancel(event.time);\n\t\t\t}\n\t\t}\n\t\tthis._state.cancel(computedTime);\n\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\tthis.setTicksAtTime(0, computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Pause the clock. Pausing does not reset the tick counter.\n\t * @param time The time when the clock should stop.\n\t */\n\tpause(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"paused\", computedTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel start/stop/pause and setTickAtTime events scheduled after the given time.\n\t * @param time When to clear the events after\n\t */\n\tcancel(time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._state.cancel(time);\n\t\tthis._tickOffset.cancel(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the elapsed ticks at the given time\n\t * @param  time  When to get the tick value\n\t * @return The number of ticks\n\t */\n\tgetTicksAtTime(time?: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst stopEvent = this._state.getLastState(\"stopped\", computedTime) as StateTimelineEvent;\n\t\t// this event allows forEachBetween to iterate until the current time\n\t\tconst tmpEvent: StateTimelineEvent = { state: \"paused\", time: computedTime };\n\t\tthis._state.add(tmpEvent);\n\n\t\t// keep track of the previous offset event\n\t\tlet lastState = stopEvent;\n\t\tlet elapsedTicks = 0;\n\n\t\t// iterate through all the events since the last stop\n\t\tthis._state.forEachBetween(stopEvent.time, computedTime + this.sampleTime, e => {\n\t\t\tlet periodStartTime = lastState.time;\n\t\t\t// if there is an offset event in this period use that\n\t\t\tconst offsetEvent = this._tickOffset.get(e.time);\n\t\t\tif (offsetEvent && offsetEvent.time >= lastState.time) {\n\t\t\t\telapsedTicks = offsetEvent.ticks;\n\t\t\t\tperiodStartTime = offsetEvent.time;\n\t\t\t}\n\t\t\tif (lastState.state === \"started\" && e.state !== \"started\") {\n\t\t\t\telapsedTicks += this.frequency.getTicksAtTime(e.time) - this.frequency.getTicksAtTime(periodStartTime);\n\t\t\t}\n\t\t\tlastState = e;\n\t\t});\n\n\t\t// remove the temporary event\n\t\tthis._state.remove(tmpEvent);\n\n\t\t// return the ticks\n\t\treturn elapsedTicks;\n\t}\n\n\t/**\n\t * The number of times the callback was invoked. Starts counting at 0\n\t * and increments after the callback was invoked. Returns -1 when stopped.\n\t */\n\tget ticks(): Ticks {\n\t\treturn this.getTicksAtTime(this.now());\n\t}\n\tset ticks(t: Ticks) {\n\t\tthis.setTicksAtTime(t, this.now());\n\t}\n\n\t/**\n\t * The time since ticks=0 that the TickSource has been running. Accounts\n\t * for tempo curves\n\t */\n\tget seconds(): Seconds {\n\t\treturn this.getSecondsAtTime(this.now());\n\t}\n\tset seconds(s: Seconds) {\n\t\tconst now = this.now();\n\t\tconst ticks = this.frequency.timeToTicks(s, now);\n\t\tthis.setTicksAtTime(ticks, now);\n\t}\n\n\t/**\n\t * Return the elapsed seconds at the given time.\n\t * @param  time  When to get the elapsed seconds\n\t * @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\ttime = this.toSeconds(time);\n\t\tconst stopEvent = this._state.getLastState(\"stopped\", time) as StateTimelineEvent;\n\t\t// this event allows forEachBetween to iterate until the current time\n\t\tconst tmpEvent: StateTimelineEvent = { state: \"paused\", time };\n\t\tthis._state.add(tmpEvent);\n\n\t\t// keep track of the previous offset event\n\t\tlet lastState = stopEvent;\n\t\tlet elapsedSeconds = 0;\n\n\t\t// iterate through all the events since the last stop\n\t\tthis._state.forEachBetween(stopEvent.time, time + this.sampleTime, e => {\n\t\t\tlet periodStartTime = lastState.time;\n\t\t\t// if there is an offset event in this period use that\n\t\t\tconst offsetEvent = this._tickOffset.get(e.time);\n\t\t\tif (offsetEvent && offsetEvent.time >= lastState.time) {\n\t\t\t\telapsedSeconds = offsetEvent.seconds;\n\t\t\t\tperiodStartTime = offsetEvent.time;\n\t\t\t}\n\t\t\tif (lastState.state === \"started\" && e.state !== \"started\") {\n\t\t\t\telapsedSeconds += e.time - periodStartTime;\n\t\t\t}\n\t\t\tlastState = e;\n\t\t});\n\n\t\t// remove the temporary event\n\t\tthis._state.remove(tmpEvent);\n\n\t\t// return the ticks\n\t\treturn elapsedSeconds;\n\t}\n\n\t/**\n\t * Set the clock's ticks at the given time.\n\t * @param  ticks The tick value to set\n\t * @param  time  When to set the tick value\n\t */\n\tsetTicksAtTime(ticks: Ticks, time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._tickOffset.cancel(time);\n\t\tthis._tickOffset.add({\n\t\t\tseconds: this.frequency.getDurationOfTicks(ticks, time),\n\t\t\tticks,\n\t\t\ttime,\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the scheduled state at the given time.\n\t * @param  time  The time to query.\n\t */\n\tgetStateAtTime(time: Time): PlaybackState {\n\t\ttime = this.toSeconds(time);\n\t\treturn this._state.getValueAtTime(time);\n\t}\n\n\t/**\n\t * Get the time of the given tick. The second argument\n\t * is when to test before. Since ticks can be set (with setTicksAtTime)\n\t * there may be multiple times for a given tick value.\n\t * @param  tick The tick number.\n\t * @param  before When to measure the tick value from.\n\t * @return The time of the tick\n\t */\n\tgetTimeOfTick(tick: Ticks, before = this.now()): Seconds {\n\t\tconst offset = this._tickOffset.get(before) as TickSourceOffsetEvent;\n\t\tconst event = this._state.get(before) as StateTimelineEvent;\n\t\tconst startTime = Math.max(offset.time, event.time);\n\t\tconst absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;\n\t\treturn this.frequency.getTimeOfTick(absoluteTicks);\n\t}\n\n\t/**\n\t * Invoke the callback event at all scheduled ticks between the\n\t * start time and the end time\n\t * @param  startTime  The beginning of the search range\n\t * @param  endTime    The end of the search range\n\t * @param  callback   The callback to invoke with each tick\n\t */\n\tforEachTickBetween(startTime: number, endTime: number, callback: (when: Seconds, ticks: Ticks) => void): this {\n\t\t// only iterate through the sections where it is \"started\"\n\t\tlet lastStateEvent = this._state.get(startTime);\n\t\tthis._state.forEachBetween(startTime, endTime, event => {\n\t\t\tif (lastStateEvent && lastStateEvent.state === \"started\" && event.state !== \"started\") {\n\t\t\t\tthis.forEachTickBetween(Math.max(lastStateEvent.time, startTime), event.time - this.sampleTime, callback);\n\t\t\t}\n\t\t\tlastStateEvent = event;\n\t\t});\n\n\t\tlet error: Error | null = null;\n\n\t\tif (lastStateEvent && lastStateEvent.state === \"started\") {\n\t\t\tconst maxStartTime = Math.max(lastStateEvent.time, startTime);\n\t\t\t// figure out the difference between the frequency ticks and the\n\t\t\tconst startTicks = this.frequency.getTicksAtTime(maxStartTime);\n\t\t\tconst ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);\n\t\t\tconst diff = startTicks - ticksAtStart;\n\t\t\tlet offset = Math.ceil(diff) - diff;\n\t\t\t// guard against floating point issues\n\t\t\toffset = EQ(offset, 1) ? 0 : offset;\n\t\t\tlet nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);\n\t\t\twhile (nextTickTime < endTime) {\n\t\t\t\ttry {\n\t\t\t\t\tcallback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));\n\t\t\t\t} catch (e) {\n\t\t\t\t\terror = e;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);\n\t\t\t}\n\t\t}\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._state.dispose();\n\t\tthis._tickOffset.dispose();\n\t\tthis.frequency.dispose();\n\t\treturn this;\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}