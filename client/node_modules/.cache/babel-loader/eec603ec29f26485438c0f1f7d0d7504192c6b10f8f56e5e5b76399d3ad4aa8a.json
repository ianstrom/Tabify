{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { deepEquals, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { generateWaveform } from \"./OscillatorInterface\";\nimport { ToneOscillatorNode } from \"./ToneOscillatorNode\";\nimport { assertRange } from \"../../core/util/Debug\";\nimport { clamp } from \"../../core/util/Math\";\n/**\n * Oscillator supports a number of features including\n * phase rotation, multiple oscillator types (see Oscillator.type),\n * and Transport syncing (see Oscillator.syncFrequency).\n *\n * @example\n * // make and start a 440hz sine tone\n * const osc = new Tone.Oscillator(440, \"sine\").toDestination().start();\n * @category Source\n */\nexport class Oscillator extends Source {\n  constructor() {\n    super(optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n    this.name = \"Oscillator\";\n    /**\n     * the main oscillator\n     */\n    this._oscillator = null;\n    const options = optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n    this.frequency = new Signal({\n      context: this.context,\n      units: \"frequency\",\n      value: options.frequency\n    });\n    readOnly(this, \"frequency\");\n    this.detune = new Signal({\n      context: this.context,\n      units: \"cents\",\n      value: options.detune\n    });\n    readOnly(this, \"detune\");\n    this._partials = options.partials;\n    this._partialCount = options.partialCount;\n    this._type = options.type;\n    if (options.partialCount && options.type !== \"custom\") {\n      this._type = this.baseType + options.partialCount.toString();\n    }\n    this.phase = options.phase;\n  }\n  static getDefaults() {\n    return Object.assign(Source.getDefaults(), {\n      detune: 0,\n      frequency: 440,\n      partialCount: 0,\n      partials: [],\n      phase: 0,\n      type: \"sine\"\n    });\n  }\n  /**\n   * start the oscillator\n   */\n  _start(time) {\n    const computedTime = this.toSeconds(time);\n    // new oscillator with previous values\n    const oscillator = new ToneOscillatorNode({\n      context: this.context,\n      onended: () => this.onstop(this)\n    });\n    this._oscillator = oscillator;\n    if (this._wave) {\n      this._oscillator.setPeriodicWave(this._wave);\n    } else {\n      this._oscillator.type = this._type;\n    }\n    // connect the control signal to the oscillator frequency & detune\n    this._oscillator.connect(this.output);\n    this.frequency.connect(this._oscillator.frequency);\n    this.detune.connect(this._oscillator.detune);\n    // start the oscillator\n    this._oscillator.start(computedTime);\n  }\n  /**\n   * stop the oscillator\n   */\n  _stop(time) {\n    const computedTime = this.toSeconds(time);\n    if (this._oscillator) {\n      this._oscillator.stop(computedTime);\n    }\n  }\n  /**\n   * Restart the oscillator. Does not stop the oscillator, but instead\n   * just cancels any scheduled 'stop' from being invoked.\n   */\n  _restart(time) {\n    const computedTime = this.toSeconds(time);\n    this.log(\"restart\", computedTime);\n    if (this._oscillator) {\n      this._oscillator.cancelStop();\n    }\n    this._state.cancel(computedTime);\n    return this;\n  }\n  /**\n   * Sync the signal to the Transport's bpm. Any changes to the transports bpm,\n   * will also affect the oscillators frequency.\n   * @example\n   * const osc = new Tone.Oscillator().toDestination().start();\n   * osc.frequency.value = 440;\n   * // the ratio between the bpm and the frequency will be maintained\n   * osc.syncFrequency();\n   * // double the tempo\n   * Tone.Transport.bpm.value *= 2;\n   * // the frequency of the oscillator is doubled to 880\n   */\n  syncFrequency() {\n    this.context.transport.syncSignal(this.frequency);\n    return this;\n  }\n  /**\n   * Unsync the oscillator's frequency from the Transport.\n   * See Oscillator.syncFrequency\n   */\n  unsyncFrequency() {\n    this.context.transport.unsyncSignal(this.frequency);\n    return this;\n  }\n  /**\n   * Get a cached periodic wave. Avoids having to recompute\n   * the oscillator values when they have already been computed\n   * with the same values.\n   */\n  _getCachedPeriodicWave() {\n    if (this._type === \"custom\") {\n      const oscProps = Oscillator._periodicWaveCache.find(description => {\n        return description.phase === this._phase && deepEquals(description.partials, this._partials);\n      });\n      return oscProps;\n    } else {\n      const oscProps = Oscillator._periodicWaveCache.find(description => {\n        return description.type === this._type && description.phase === this._phase;\n      });\n      this._partialCount = oscProps ? oscProps.partialCount : this._partialCount;\n      return oscProps;\n    }\n  }\n  get type() {\n    return this._type;\n  }\n  set type(type) {\n    this._type = type;\n    const isBasicType = [\"sine\", \"square\", \"sawtooth\", \"triangle\"].indexOf(type) !== -1;\n    if (this._phase === 0 && isBasicType) {\n      this._wave = undefined;\n      this._partialCount = 0;\n      // just go with the basic approach\n      if (this._oscillator !== null) {\n        // already tested that it's a basic type\n        this._oscillator.type = type;\n      }\n    } else {\n      // first check if the value is cached\n      const cache = this._getCachedPeriodicWave();\n      if (isDefined(cache)) {\n        const {\n          partials,\n          wave\n        } = cache;\n        this._wave = wave;\n        this._partials = partials;\n        if (this._oscillator !== null) {\n          this._oscillator.setPeriodicWave(this._wave);\n        }\n      } else {\n        const [real, imag] = this._getRealImaginary(type, this._phase);\n        const periodicWave = this.context.createPeriodicWave(real, imag);\n        this._wave = periodicWave;\n        if (this._oscillator !== null) {\n          this._oscillator.setPeriodicWave(this._wave);\n        }\n        // set the cache\n        Oscillator._periodicWaveCache.push({\n          imag,\n          partialCount: this._partialCount,\n          partials: this._partials,\n          phase: this._phase,\n          real,\n          type: this._type,\n          wave: this._wave\n        });\n        if (Oscillator._periodicWaveCache.length > 100) {\n          Oscillator._periodicWaveCache.shift();\n        }\n      }\n    }\n  }\n  get baseType() {\n    return this._type.replace(this.partialCount.toString(), \"\");\n  }\n  set baseType(baseType) {\n    if (this.partialCount && this._type !== \"custom\" && baseType !== \"custom\") {\n      this.type = baseType + this.partialCount;\n    } else {\n      this.type = baseType;\n    }\n  }\n  get partialCount() {\n    return this._partialCount;\n  }\n  set partialCount(p) {\n    assertRange(p, 0);\n    let type = this._type;\n    const partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(this._type);\n    if (partial) {\n      type = partial[1];\n    }\n    if (this._type !== \"custom\") {\n      if (p === 0) {\n        this.type = type;\n      } else {\n        this.type = type + p.toString();\n      }\n    } else {\n      // extend or shorten the partials array\n      const fullPartials = new Float32Array(p);\n      // copy over the partials array\n      this._partials.forEach((v, i) => fullPartials[i] = v);\n      this._partials = Array.from(fullPartials);\n      this.type = this._type;\n    }\n  }\n  /**\n   * Returns the real and imaginary components based\n   * on the oscillator type.\n   * @returns [real: Float32Array, imaginary: Float32Array]\n   */\n  _getRealImaginary(type, phase) {\n    const fftSize = 4096;\n    let periodicWaveSize = fftSize / 2;\n    const real = new Float32Array(periodicWaveSize);\n    const imag = new Float32Array(periodicWaveSize);\n    let partialCount = 1;\n    if (type === \"custom\") {\n      partialCount = this._partials.length + 1;\n      this._partialCount = this._partials.length;\n      periodicWaveSize = partialCount;\n      // if the partial count is 0, don't bother doing any computation\n      if (this._partials.length === 0) {\n        return [real, imag];\n      }\n    } else {\n      const partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(type);\n      if (partial) {\n        partialCount = parseInt(partial[2], 10) + 1;\n        this._partialCount = parseInt(partial[2], 10);\n        type = partial[1];\n        partialCount = Math.max(partialCount, 2);\n        periodicWaveSize = partialCount;\n      } else {\n        this._partialCount = 0;\n      }\n      this._partials = [];\n    }\n    for (let n = 1; n < periodicWaveSize; ++n) {\n      const piFactor = 2 / (n * Math.PI);\n      let b;\n      switch (type) {\n        case \"sine\":\n          b = n <= partialCount ? 1 : 0;\n          this._partials[n - 1] = b;\n          break;\n        case \"square\":\n          b = n & 1 ? 2 * piFactor : 0;\n          this._partials[n - 1] = b;\n          break;\n        case \"sawtooth\":\n          b = piFactor * (n & 1 ? 1 : -1);\n          this._partials[n - 1] = b;\n          break;\n        case \"triangle\":\n          if (n & 1) {\n            b = 2 * (piFactor * piFactor) * (n - 1 >> 1 & 1 ? -1 : 1);\n          } else {\n            b = 0;\n          }\n          this._partials[n - 1] = b;\n          break;\n        case \"custom\":\n          b = this._partials[n - 1];\n          break;\n        default:\n          throw new TypeError(\"Oscillator: invalid type: \" + type);\n      }\n      if (b !== 0) {\n        real[n] = -b * Math.sin(phase * n);\n        imag[n] = b * Math.cos(phase * n);\n      } else {\n        real[n] = 0;\n        imag[n] = 0;\n      }\n    }\n    return [real, imag];\n  }\n  /**\n   * Compute the inverse FFT for a given phase.\n   */\n  _inverseFFT(real, imag, phase) {\n    let sum = 0;\n    const len = real.length;\n    for (let i = 0; i < len; i++) {\n      sum += real[i] * Math.cos(i * phase) + imag[i] * Math.sin(i * phase);\n    }\n    return sum;\n  }\n  /**\n   * Returns the initial value of the oscillator when stopped.\n   * E.g. a \"sine\" oscillator with phase = 90 would return an initial value of -1.\n   */\n  getInitialValue() {\n    const [real, imag] = this._getRealImaginary(this._type, 0);\n    let maxValue = 0;\n    const twoPi = Math.PI * 2;\n    const testPositions = 32;\n    // check for peaks in 16 places\n    for (let i = 0; i < testPositions; i++) {\n      maxValue = Math.max(this._inverseFFT(real, imag, i / testPositions * twoPi), maxValue);\n    }\n    return clamp(-this._inverseFFT(real, imag, this._phase) / maxValue, -1, 1);\n  }\n  get partials() {\n    return this._partials.slice(0, this.partialCount);\n  }\n  set partials(partials) {\n    this._partials = partials;\n    this._partialCount = this._partials.length;\n    if (partials.length) {\n      this.type = \"custom\";\n    }\n  }\n  get phase() {\n    return this._phase * (180 / Math.PI);\n  }\n  set phase(phase) {\n    this._phase = phase * Math.PI / 180;\n    // reset the type\n    this.type = this._type;\n  }\n  asArray() {\n    let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1024;\n    return __awaiter(this, void 0, void 0, function* () {\n      return generateWaveform(this, length);\n    });\n  }\n  dispose() {\n    super.dispose();\n    if (this._oscillator !== null) {\n      this._oscillator.dispose();\n    }\n    this._wave = undefined;\n    this.frequency.dispose();\n    this.detune.dispose();\n    return this;\n  }\n}\n/**\n * Cache the periodic waves to avoid having to redo computations\n */\nOscillator._periodicWaveCache = [];","map":{"version":3,"names":["deepEquals","optionsFromArguments","readOnly","isDefined","Signal","Source","generateWaveform","ToneOscillatorNode","assertRange","clamp","Oscillator","constructor","getDefaults","arguments","name","_oscillator","options","frequency","context","units","value","detune","_partials","partials","_partialCount","partialCount","_type","type","baseType","toString","phase","Object","assign","_start","time","computedTime","toSeconds","oscillator","onended","onstop","_wave","setPeriodicWave","connect","output","start","_stop","stop","_restart","log","cancelStop","_state","cancel","syncFrequency","transport","syncSignal","unsyncFrequency","unsyncSignal","_getCachedPeriodicWave","oscProps","_periodicWaveCache","find","description","_phase","isBasicType","indexOf","undefined","cache","wave","real","imag","_getRealImaginary","periodicWave","createPeriodicWave","push","length","shift","replace","p","partial","exec","fullPartials","Float32Array","forEach","v","i","Array","from","fftSize","periodicWaveSize","parseInt","Math","max","n","piFactor","PI","b","TypeError","sin","cos","_inverseFFT","sum","len","getInitialValue","maxValue","twoPi","testPositions","slice","asArray","dispose"],"sources":["/Users/ianstrom/Development/code/Capstone/client/node_modules/tone/Tone/source/oscillator/Oscillator.ts"],"sourcesContent":["import { AudioRange, Degrees, Frequency, Radians, Time } from \"../../core/type/Units\";\nimport { deepEquals, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport {\n\tgenerateWaveform, ToneOscillatorConstructorOptions, ToneOscillatorInterface,\n\tToneOscillatorOptions, ToneOscillatorType\n} from \"./OscillatorInterface\";\nimport { ToneOscillatorNode } from \"./ToneOscillatorNode\";\nimport { assertRange } from \"../../core/util/Debug\";\nimport { clamp } from \"../../core/util/Math\";\nexport { ToneOscillatorOptions, ToneOscillatorType } from \"./OscillatorInterface\";\n/**\n * Oscillator supports a number of features including\n * phase rotation, multiple oscillator types (see Oscillator.type),\n * and Transport syncing (see Oscillator.syncFrequency).\n *\n * @example\n * // make and start a 440hz sine tone\n * const osc = new Tone.Oscillator(440, \"sine\").toDestination().start();\n * @category Source\n */\nexport class Oscillator extends Source<ToneOscillatorOptions> implements ToneOscillatorInterface {\n\n\treadonly name: string = \"Oscillator\";\n\n\t/**\n\t * the main oscillator\n\t */\n\tprivate _oscillator: ToneOscillatorNode | null = null;\n\n\t/**\n\t * The frequency control.\n\t */\n\tfrequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune control signal.\n\t */\n\tdetune: Signal<\"cents\">;\n\n\t/**\n\t * the periodic wave\n\t */\n\tprivate _wave?: PeriodicWave;\n\n\t/**\n\t * The partials of the oscillator\n\t */\n\tprivate _partials: number[];\n\n\t/**\n\t * The number of partials to limit or extend the periodic wave by\n\t */\n\tprivate _partialCount: number;\n\n\t/**\n\t * the phase of the oscillator between 0 - 360\n\t */\n\tprivate _phase!: Radians;\n\n\t/**\n\t * the type of the oscillator\n\t */\n\tprivate _type: ToneOscillatorType;\n\n\t/**\n\t * @param frequency Starting frequency\n\t * @param type The oscillator type. Read more about type below.\n\t */\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType);\n\tconstructor(options?: Partial<ToneOscillatorConstructorOptions>)\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n\t\tconst options = optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n\n\t\tthis.frequency = new Signal<\"frequency\">({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\treadOnly(this, \"frequency\");\n\n\t\tthis.detune = new Signal<\"cents\">({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\t\treadOnly(this, \"detune\");\n\n\t\tthis._partials = options.partials;\n\t\tthis._partialCount = options.partialCount;\n\t\tthis._type = options.type;\n\n\t\tif (options.partialCount && options.type !== \"custom\") {\n\t\t\tthis._type = this.baseType + options.partialCount.toString() as ToneOscillatorType;\n\t\t}\n\t\tthis.phase = options.phase;\n\t}\n\n\tstatic getDefaults(): ToneOscillatorOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\tpartialCount: 0,\n\t\t\tpartials: [],\n\t\t\tphase: 0,\n\t\t\ttype: \"sine\" as const,\n\t\t});\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time?: Time): void {\n\t\tconst computedTime = this.toSeconds(time);\n\t\t// new oscillator with previous values\n\t\tconst oscillator = new ToneOscillatorNode({\n\t\t\tcontext: this.context,\n\t\t\tonended: () => this.onstop(this),\n\t\t});\n\t\tthis._oscillator = oscillator;\n\t\tif (this._wave) {\n\t\t\tthis._oscillator.setPeriodicWave(this._wave);\n\t\t} else {\n\t\t\tthis._oscillator.type = this._type as OscillatorType;\n\t\t}\n\t\t// connect the control signal to the oscillator frequency & detune\n\t\tthis._oscillator.connect(this.output);\n\t\tthis.frequency.connect(this._oscillator.frequency);\n\t\tthis.detune.connect(this._oscillator.detune);\n\n\t\t// start the oscillator\n\t\tthis._oscillator.start(computedTime);\n\t}\n\n\t/**\n\t * stop the oscillator\n\t */\n\tprotected _stop(time?: Time): void {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._oscillator) {\n\t\t\tthis._oscillator.stop(computedTime);\n\t\t}\n\t}\n\n\t/**\n\t * Restart the oscillator. Does not stop the oscillator, but instead\n\t * just cancels any scheduled 'stop' from being invoked.\n\t */\n\tprotected _restart(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"restart\", computedTime);\n\t\tif (this._oscillator) {\n\t\t\tthis._oscillator.cancelStop();\n\t\t}\n\t\tthis._state.cancel(computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the signal to the Transport's bpm. Any changes to the transports bpm,\n\t * will also affect the oscillators frequency.\n\t * @example\n\t * const osc = new Tone.Oscillator().toDestination().start();\n\t * osc.frequency.value = 440;\n\t * // the ratio between the bpm and the frequency will be maintained\n\t * osc.syncFrequency();\n\t * // double the tempo\n\t * Tone.Transport.bpm.value *= 2;\n\t * // the frequency of the oscillator is doubled to 880\n\t */\n\tsyncFrequency(): this {\n\t\tthis.context.transport.syncSignal(this.frequency);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unsync the oscillator's frequency from the Transport.\n\t * See Oscillator.syncFrequency\n\t */\n\tunsyncFrequency(): this {\n\t\tthis.context.transport.unsyncSignal(this.frequency);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cache the periodic waves to avoid having to redo computations\n\t */\n\tprivate static _periodicWaveCache: Array<{\n\t\tpartials: number[];\n\t\tphase: number;\n\t\ttype: string;\n\t\tpartialCount: number;\n\t\treal: Float32Array;\n\t\timag: Float32Array;\n\t\twave: PeriodicWave;\n\t}> = [];\n\n\t/**\n\t * Get a cached periodic wave. Avoids having to recompute\n\t * the oscillator values when they have already been computed\n\t * with the same values.\n\t */\n\tprivate _getCachedPeriodicWave(): { real: Float32Array; imag: Float32Array; partials: number[]; wave: PeriodicWave } | undefined {\n\t\tif (this._type === \"custom\") {\n\t\t\tconst oscProps = Oscillator._periodicWaveCache.find(description => {\n\t\t\t\treturn description.phase === this._phase &&\n\t\t\t\t\tdeepEquals(description.partials, this._partials);\n\t\t\t});\n\t\t\treturn oscProps;\n\t\t} else {\n\t\t\tconst oscProps = Oscillator._periodicWaveCache.find(description => {\n\t\t\t\treturn description.type === this._type &&\n\t\t\t\t\tdescription.phase === this._phase;\n\t\t\t});\n\t\t\tthis._partialCount = oscProps ? oscProps.partialCount : this._partialCount;\n\t\t\treturn oscProps;\n\t\t}\n\t}\n\n\tget type(): ToneOscillatorType {\n\t\treturn this._type;\n\t}\n\tset type(type) {\n\t\tthis._type = type;\n\t\tconst isBasicType = [\"sine\", \"square\", \"sawtooth\", \"triangle\"].indexOf(type) !== -1;\n\t\tif (this._phase === 0 && isBasicType) {\n\t\t\tthis._wave = undefined;\n\t\t\tthis._partialCount = 0;\n\t\t\t// just go with the basic approach\n\t\t\tif (this._oscillator !== null) {\n\t\t\t\t// already tested that it's a basic type\n\t\t\t\tthis._oscillator.type = type as OscillatorType;\n\t\t\t}\n\t\t} else {\n\t\t\t// first check if the value is cached\n\t\t\tconst cache = this._getCachedPeriodicWave();\n\t\t\tif (isDefined(cache)) {\n\t\t\t\tconst { partials, wave } = cache;\n\t\t\t\tthis._wave = wave;\n\t\t\t\tthis._partials = partials;\n\t\t\t\tif (this._oscillator !== null) {\n\t\t\t\t\tthis._oscillator.setPeriodicWave(this._wave);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst [real, imag] = this._getRealImaginary(type, this._phase);\n\t\t\t\tconst periodicWave = this.context.createPeriodicWave(real, imag);\n\t\t\t\tthis._wave = periodicWave;\n\t\t\t\tif (this._oscillator !== null) {\n\t\t\t\t\tthis._oscillator.setPeriodicWave(this._wave);\n\t\t\t\t}\n\t\t\t\t// set the cache\n\t\t\t\tOscillator._periodicWaveCache.push({\n\t\t\t\t\timag,\n\t\t\t\t\tpartialCount: this._partialCount,\n\t\t\t\t\tpartials: this._partials,\n\t\t\t\t\tphase: this._phase,\n\t\t\t\t\treal,\n\t\t\t\t\ttype: this._type,\n\t\t\t\t\twave: this._wave,\n\t\t\t\t});\n\t\t\t\tif (Oscillator._periodicWaveCache.length > 100) {\n\t\t\t\t\tOscillator._periodicWaveCache.shift();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget baseType(): OscillatorType {\n\t\treturn (this._type as string).replace(this.partialCount.toString(), \"\") as OscillatorType;\n\t}\n\tset baseType(baseType) {\n\t\tif (this.partialCount && this._type !== \"custom\" && baseType !== \"custom\") {\n\t\t\tthis.type = baseType + this.partialCount as ToneOscillatorType;\n\t\t} else {\n\t\t\tthis.type = baseType;\n\t\t}\n\t}\n\n\tget partialCount(): number {\n\t\treturn this._partialCount;\n\t}\n\tset partialCount(p) {\n\t\tassertRange(p, 0);\n\t\tlet type = this._type;\n\t\tconst partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(this._type);\n\t\tif (partial) {\n\t\t\ttype = partial[1] as OscillatorType;\n\t\t}\n\t\tif (this._type !== \"custom\") {\n\t\t\tif (p === 0) {\n\t\t\t\tthis.type = type;\n\t\t\t} else {\n\t\t\t\tthis.type = type + p.toString() as ToneOscillatorType;\n\t\t\t}\n\t\t} else {\n\t\t\t// extend or shorten the partials array\n\t\t\tconst fullPartials = new Float32Array(p);\n\t\t\t// copy over the partials array\n\t\t\tthis._partials.forEach((v, i) => fullPartials[i] = v);\n\t\t\tthis._partials = Array.from(fullPartials);\n\t\t\tthis.type = this._type;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the real and imaginary components based\n\t * on the oscillator type.\n\t * @returns [real: Float32Array, imaginary: Float32Array]\n\t */\n\tprivate _getRealImaginary(type: ToneOscillatorType, phase: Radians): Float32Array[] {\n\t\tconst fftSize = 4096;\n\t\tlet periodicWaveSize = fftSize / 2;\n\n\t\tconst real = new Float32Array(periodicWaveSize);\n\t\tconst imag = new Float32Array(periodicWaveSize);\n\n\t\tlet partialCount = 1;\n\t\tif (type === \"custom\") {\n\t\t\tpartialCount = this._partials.length + 1;\n\t\t\tthis._partialCount = this._partials.length;\n\t\t\tperiodicWaveSize = partialCount;\n\t\t\t// if the partial count is 0, don't bother doing any computation\n\t\t\tif (this._partials.length === 0) {\n\t\t\t\treturn [real, imag];\n\t\t\t}\n\t\t} else {\n\t\t\tconst partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(type);\n\t\t\tif (partial) {\n\t\t\t\tpartialCount = parseInt(partial[2], 10) + 1;\n\t\t\t\tthis._partialCount = parseInt(partial[2], 10);\n\t\t\t\ttype = partial[1] as ToneOscillatorType;\n\t\t\t\tpartialCount = Math.max(partialCount, 2);\n\t\t\t\tperiodicWaveSize = partialCount;\n\t\t\t} else {\n\t\t\t\tthis._partialCount = 0;\n\t\t\t}\n\t\t\tthis._partials = [];\n\t\t}\n\n\t\tfor (let n = 1; n < periodicWaveSize; ++n) {\n\t\t\tconst piFactor = 2 / (n * Math.PI);\n\t\t\tlet b;\n\t\t\tswitch (type) {\n\t\t\t\tcase \"sine\":\n\t\t\t\t\tb = (n <= partialCount) ? 1 : 0;\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"square\":\n\t\t\t\t\tb = (n & 1) ? 2 * piFactor : 0;\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sawtooth\":\n\t\t\t\t\tb = piFactor * ((n & 1) ? 1 : -1);\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"triangle\":\n\t\t\t\t\tif (n & 1) {\n\t\t\t\t\t\tb = 2 * (piFactor * piFactor) * ((((n - 1) >> 1) & 1) ? -1 : 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tb = 0;\n\t\t\t\t\t}\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"custom\":\n\t\t\t\t\tb = this._partials[n - 1];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new TypeError(\"Oscillator: invalid type: \" + type);\n\t\t\t}\n\t\t\tif (b !== 0) {\n\t\t\t\treal[n] = -b * Math.sin(phase * n);\n\t\t\t\timag[n] = b * Math.cos(phase * n);\n\t\t\t} else {\n\t\t\t\treal[n] = 0;\n\t\t\t\timag[n] = 0;\n\t\t\t}\n\t\t}\n\t\treturn [real, imag];\n\t}\n\n\t/**\n\t * Compute the inverse FFT for a given phase.\n\t */\n\tprivate _inverseFFT(real: Float32Array, imag: Float32Array, phase: Radians): number {\n\t\tlet sum = 0;\n\t\tconst len = real.length;\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tsum += real[i] * Math.cos(i * phase) + imag[i] * Math.sin(i * phase);\n\t\t}\n\t\treturn sum;\n\t}\n\n\t/**\n\t * Returns the initial value of the oscillator when stopped.\n\t * E.g. a \"sine\" oscillator with phase = 90 would return an initial value of -1.\n\t */\n\tgetInitialValue(): AudioRange {\n\t\tconst [real, imag] = this._getRealImaginary(this._type, 0);\n\t\tlet maxValue = 0;\n\t\tconst twoPi = Math.PI * 2;\n\t\tconst testPositions = 32;\n\t\t// check for peaks in 16 places\n\t\tfor (let i = 0; i < testPositions; i++) {\n\t\t\tmaxValue = Math.max(this._inverseFFT(real, imag, (i / testPositions) * twoPi), maxValue);\n\t\t}\n\t\treturn clamp(-this._inverseFFT(real, imag, this._phase) / maxValue, -1, 1);\n\t}\n\n\tget partials(): number[] {\n\t\treturn this._partials.slice(0, this.partialCount);\n\t}\n\tset partials(partials) {\n\t\tthis._partials = partials;\n\t\tthis._partialCount = this._partials.length;\n\t\tif (partials.length) {\n\t\t\tthis.type = \"custom\";\n\t\t}\n\t}\n\n\tget phase(): Degrees {\n\t\treturn this._phase * (180 / Math.PI);\n\t}\n\tset phase(phase) {\n\t\tthis._phase = phase * Math.PI / 180;\n\t\t// reset the type\n\t\tthis.type = this._type;\n\t}\n\n\tasync asArray(length = 1024): Promise<Float32Array> {\n\t\treturn generateWaveform(this, length);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this._oscillator !== null) {\n\t\t\tthis._oscillator.dispose();\n\t\t}\n\t\tthis._wave = undefined;\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\treturn this;\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}