{"ast":null,"code":"import { AutomationEventList } from 'automation-events';\nexport const createAudioParamFactory = (addAudioParamConnections, audioParamAudioNodeStore, audioParamStore, createAudioParamRenderer, createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent, nativeAudioContextConstructor, setValueAtTimeUntilPossible) => {\n  return function (audioNode, isAudioParamOfOfflineAudioContext, nativeAudioParam) {\n    let maxValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    let minValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    // Bug #196 Only Safari sets the defaultValue to the initial value.\n    const defaultValue = nativeAudioParam.value;\n    const automationEventList = new AutomationEventList(defaultValue);\n    const audioParamRenderer = isAudioParamOfOfflineAudioContext ? createAudioParamRenderer(automationEventList) : null;\n    const audioParam = {\n      get defaultValue() {\n        return defaultValue;\n      },\n      get maxValue() {\n        return maxValue === null ? nativeAudioParam.maxValue : maxValue;\n      },\n      get minValue() {\n        return minValue === null ? nativeAudioParam.minValue : minValue;\n      },\n      get value() {\n        return nativeAudioParam.value;\n      },\n      set value(value) {\n        nativeAudioParam.value = value;\n        // Bug #98: Firefox & Safari do not yet treat the value setter like a call to setValueAtTime().\n        audioParam.setValueAtTime(value, audioNode.context.currentTime);\n      },\n      cancelAndHoldAtTime(cancelTime) {\n        // Bug #28: Firefox & Safari do not yet implement cancelAndHoldAtTime().\n        if (typeof nativeAudioParam.cancelAndHoldAtTime === 'function') {\n          if (audioParamRenderer === null) {\n            automationEventList.flush(audioNode.context.currentTime);\n          }\n          automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n          nativeAudioParam.cancelAndHoldAtTime(cancelTime);\n        } else {\n          const previousLastEvent = Array.from(automationEventList).pop();\n          if (audioParamRenderer === null) {\n            automationEventList.flush(audioNode.context.currentTime);\n          }\n          automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n          const currentLastEvent = Array.from(automationEventList).pop();\n          nativeAudioParam.cancelScheduledValues(cancelTime);\n          if (previousLastEvent !== currentLastEvent && currentLastEvent !== undefined) {\n            if (currentLastEvent.type === 'exponentialRampToValue') {\n              nativeAudioParam.exponentialRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n            } else if (currentLastEvent.type === 'linearRampToValue') {\n              nativeAudioParam.linearRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n            } else if (currentLastEvent.type === 'setValue') {\n              nativeAudioParam.setValueAtTime(currentLastEvent.value, currentLastEvent.startTime);\n            } else if (currentLastEvent.type === 'setValueCurve') {\n              nativeAudioParam.setValueCurveAtTime(currentLastEvent.values, currentLastEvent.startTime, currentLastEvent.duration);\n            }\n          }\n        }\n        return audioParam;\n      },\n      cancelScheduledValues(cancelTime) {\n        if (audioParamRenderer === null) {\n          automationEventList.flush(audioNode.context.currentTime);\n        }\n        automationEventList.add(createCancelScheduledValuesAutomationEvent(cancelTime));\n        nativeAudioParam.cancelScheduledValues(cancelTime);\n        return audioParam;\n      },\n      exponentialRampToValueAtTime(value, endTime) {\n        // Bug #45: Safari does not throw an error yet.\n        if (value === 0) {\n          throw new RangeError();\n        }\n        // Bug #187: Safari does not throw an error yet.\n        if (!Number.isFinite(endTime) || endTime < 0) {\n          throw new RangeError();\n        }\n        const currentTime = audioNode.context.currentTime;\n        if (audioParamRenderer === null) {\n          automationEventList.flush(currentTime);\n        }\n        // Bug #194: Firefox does not implicitly call setValueAtTime() if there is no previous event.\n        if (Array.from(automationEventList).length === 0) {\n          automationEventList.add(createSetValueAutomationEvent(defaultValue, currentTime));\n          nativeAudioParam.setValueAtTime(defaultValue, currentTime);\n        }\n        automationEventList.add(createExponentialRampToValueAutomationEvent(value, endTime));\n        nativeAudioParam.exponentialRampToValueAtTime(value, endTime);\n        return audioParam;\n      },\n      linearRampToValueAtTime(value, endTime) {\n        const currentTime = audioNode.context.currentTime;\n        if (audioParamRenderer === null) {\n          automationEventList.flush(currentTime);\n        }\n        // Bug #195: Firefox does not implicitly call setValueAtTime() if there is no previous event.\n        if (Array.from(automationEventList).length === 0) {\n          automationEventList.add(createSetValueAutomationEvent(defaultValue, currentTime));\n          nativeAudioParam.setValueAtTime(defaultValue, currentTime);\n        }\n        automationEventList.add(createLinearRampToValueAutomationEvent(value, endTime));\n        nativeAudioParam.linearRampToValueAtTime(value, endTime);\n        return audioParam;\n      },\n      setTargetAtTime(target, startTime, timeConstant) {\n        if (audioParamRenderer === null) {\n          automationEventList.flush(audioNode.context.currentTime);\n        }\n        automationEventList.add(createSetTargetAutomationEvent(target, startTime, timeConstant));\n        nativeAudioParam.setTargetAtTime(target, startTime, timeConstant);\n        return audioParam;\n      },\n      setValueAtTime(value, startTime) {\n        if (audioParamRenderer === null) {\n          automationEventList.flush(audioNode.context.currentTime);\n        }\n        automationEventList.add(createSetValueAutomationEvent(value, startTime));\n        nativeAudioParam.setValueAtTime(value, startTime);\n        return audioParam;\n      },\n      setValueCurveAtTime(values, startTime, duration) {\n        // Bug 183: Safari only accepts a Float32Array.\n        const convertedValues = values instanceof Float32Array ? values : new Float32Array(values);\n        /*\n         * Bug #152: Safari does not correctly interpolate the values of the curve.\n         * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the\n         * existence of the webkitAudioContext is used as a workaround here.\n         */\n        if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {\n          const endTime = startTime + duration;\n          const sampleRate = audioNode.context.sampleRate;\n          const firstSample = Math.ceil(startTime * sampleRate);\n          const lastSample = Math.floor(endTime * sampleRate);\n          const numberOfInterpolatedValues = lastSample - firstSample;\n          const interpolatedValues = new Float32Array(numberOfInterpolatedValues);\n          for (let i = 0; i < numberOfInterpolatedValues; i += 1) {\n            const theoreticIndex = (convertedValues.length - 1) / duration * ((firstSample + i) / sampleRate - startTime);\n            const lowerIndex = Math.floor(theoreticIndex);\n            const upperIndex = Math.ceil(theoreticIndex);\n            interpolatedValues[i] = lowerIndex === upperIndex ? convertedValues[lowerIndex] : (1 - (theoreticIndex - lowerIndex)) * convertedValues[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * convertedValues[upperIndex];\n          }\n          if (audioParamRenderer === null) {\n            automationEventList.flush(audioNode.context.currentTime);\n          }\n          automationEventList.add(createSetValueCurveAutomationEvent(interpolatedValues, startTime, duration));\n          nativeAudioParam.setValueCurveAtTime(interpolatedValues, startTime, duration);\n          const timeOfLastSample = lastSample / sampleRate;\n          if (timeOfLastSample < endTime) {\n            setValueAtTimeUntilPossible(audioParam, interpolatedValues[interpolatedValues.length - 1], timeOfLastSample);\n          }\n          setValueAtTimeUntilPossible(audioParam, convertedValues[convertedValues.length - 1], endTime);\n        } else {\n          if (audioParamRenderer === null) {\n            automationEventList.flush(audioNode.context.currentTime);\n          }\n          automationEventList.add(createSetValueCurveAutomationEvent(convertedValues, startTime, duration));\n          nativeAudioParam.setValueCurveAtTime(convertedValues, startTime, duration);\n        }\n        return audioParam;\n      }\n    };\n    audioParamStore.set(audioParam, nativeAudioParam);\n    audioParamAudioNodeStore.set(audioParam, audioNode);\n    addAudioParamConnections(audioParam, audioParamRenderer);\n    return audioParam;\n  };\n};","map":{"version":3,"names":["AutomationEventList","createAudioParamFactory","addAudioParamConnections","audioParamAudioNodeStore","audioParamStore","createAudioParamRenderer","createCancelAndHoldAutomationEvent","createCancelScheduledValuesAutomationEvent","createExponentialRampToValueAutomationEvent","createLinearRampToValueAutomationEvent","createSetTargetAutomationEvent","createSetValueAutomationEvent","createSetValueCurveAutomationEvent","nativeAudioContextConstructor","setValueAtTimeUntilPossible","audioNode","isAudioParamOfOfflineAudioContext","nativeAudioParam","maxValue","arguments","length","undefined","minValue","defaultValue","value","automationEventList","audioParamRenderer","audioParam","setValueAtTime","context","currentTime","cancelAndHoldAtTime","cancelTime","flush","add","previousLastEvent","Array","from","pop","currentLastEvent","cancelScheduledValues","type","exponentialRampToValueAtTime","endTime","linearRampToValueAtTime","startTime","setValueCurveAtTime","values","duration","RangeError","Number","isFinite","setTargetAtTime","target","timeConstant","convertedValues","Float32Array","name","sampleRate","firstSample","Math","ceil","lastSample","floor","numberOfInterpolatedValues","interpolatedValues","i","theoreticIndex","lowerIndex","upperIndex","timeOfLastSample","set"],"sources":["/Users/ianstrom/Development/code/Capstone/client/node_modules/standardized-audio-context/src/factories/audio-param-factory.ts"],"sourcesContent":["import { AutomationEventList } from 'automation-events';\nimport { IAudioNode, IAudioParam, IAudioParamRenderer, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TAudioParamFactoryFactory, TContext, TNativeAudioParam } from '../types';\n\nexport const createAudioParamFactory: TAudioParamFactoryFactory = (\n    addAudioParamConnections,\n    audioParamAudioNodeStore,\n    audioParamStore,\n    createAudioParamRenderer,\n    createCancelAndHoldAutomationEvent,\n    createCancelScheduledValuesAutomationEvent,\n    createExponentialRampToValueAutomationEvent,\n    createLinearRampToValueAutomationEvent,\n    createSetTargetAutomationEvent,\n    createSetValueAutomationEvent,\n    createSetValueCurveAutomationEvent,\n    nativeAudioContextConstructor,\n    setValueAtTimeUntilPossible\n) => {\n    return <T extends TContext>(\n        audioNode: IAudioNode<T>,\n        isAudioParamOfOfflineAudioContext: boolean,\n        nativeAudioParam: TNativeAudioParam,\n        maxValue: null | number = null,\n        minValue: null | number = null\n    ): IAudioParam => {\n        // Bug #196 Only Safari sets the defaultValue to the initial value.\n        const defaultValue = nativeAudioParam.value;\n        const automationEventList = new AutomationEventList(defaultValue);\n        const audioParamRenderer = isAudioParamOfOfflineAudioContext ? createAudioParamRenderer(automationEventList) : null;\n        const audioParam = {\n            get defaultValue(): number {\n                return defaultValue;\n            },\n            get maxValue(): number {\n                return maxValue === null ? nativeAudioParam.maxValue : maxValue;\n            },\n            get minValue(): number {\n                return minValue === null ? nativeAudioParam.minValue : minValue;\n            },\n            get value(): number {\n                return nativeAudioParam.value;\n            },\n            set value(value) {\n                nativeAudioParam.value = value;\n\n                // Bug #98: Firefox & Safari do not yet treat the value setter like a call to setValueAtTime().\n                audioParam.setValueAtTime(value, audioNode.context.currentTime);\n            },\n            cancelAndHoldAtTime(cancelTime: number): IAudioParam {\n                // Bug #28: Firefox & Safari do not yet implement cancelAndHoldAtTime().\n                if (typeof nativeAudioParam.cancelAndHoldAtTime === 'function') {\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n\n                    automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n                    nativeAudioParam.cancelAndHoldAtTime(cancelTime);\n                } else {\n                    const previousLastEvent = Array.from(automationEventList).pop();\n\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n\n                    automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n\n                    const currentLastEvent = Array.from(automationEventList).pop();\n\n                    nativeAudioParam.cancelScheduledValues(cancelTime);\n\n                    if (previousLastEvent !== currentLastEvent && currentLastEvent !== undefined) {\n                        if (currentLastEvent.type === 'exponentialRampToValue') {\n                            nativeAudioParam.exponentialRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n                        } else if (currentLastEvent.type === 'linearRampToValue') {\n                            nativeAudioParam.linearRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n                        } else if (currentLastEvent.type === 'setValue') {\n                            nativeAudioParam.setValueAtTime(currentLastEvent.value, currentLastEvent.startTime);\n                        } else if (currentLastEvent.type === 'setValueCurve') {\n                            nativeAudioParam.setValueCurveAtTime(\n                                currentLastEvent.values,\n                                currentLastEvent.startTime,\n                                currentLastEvent.duration\n                            );\n                        }\n                    }\n                }\n\n                return audioParam;\n            },\n            cancelScheduledValues(cancelTime: number): IAudioParam {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n\n                automationEventList.add(createCancelScheduledValuesAutomationEvent(cancelTime));\n                nativeAudioParam.cancelScheduledValues(cancelTime);\n\n                return audioParam;\n            },\n            exponentialRampToValueAtTime(value: number, endTime: number): IAudioParam {\n                // Bug #45: Safari does not throw an error yet.\n                if (value === 0) {\n                    throw new RangeError();\n                }\n\n                // Bug #187: Safari does not throw an error yet.\n                if (!Number.isFinite(endTime) || endTime < 0) {\n                    throw new RangeError();\n                }\n\n                const currentTime = audioNode.context.currentTime;\n\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(currentTime);\n                }\n\n                // Bug #194: Firefox does not implicitly call setValueAtTime() if there is no previous event.\n                if (Array.from(automationEventList).length === 0) {\n                    automationEventList.add(createSetValueAutomationEvent(defaultValue, currentTime));\n                    nativeAudioParam.setValueAtTime(defaultValue, currentTime);\n                }\n\n                automationEventList.add(createExponentialRampToValueAutomationEvent(value, endTime));\n                nativeAudioParam.exponentialRampToValueAtTime(value, endTime);\n\n                return audioParam;\n            },\n            linearRampToValueAtTime(value: number, endTime: number): IAudioParam {\n                const currentTime = audioNode.context.currentTime;\n\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(currentTime);\n                }\n\n                // Bug #195: Firefox does not implicitly call setValueAtTime() if there is no previous event.\n                if (Array.from(automationEventList).length === 0) {\n                    automationEventList.add(createSetValueAutomationEvent(defaultValue, currentTime));\n                    nativeAudioParam.setValueAtTime(defaultValue, currentTime);\n                }\n\n                automationEventList.add(createLinearRampToValueAutomationEvent(value, endTime));\n                nativeAudioParam.linearRampToValueAtTime(value, endTime);\n\n                return audioParam;\n            },\n            setTargetAtTime(target: number, startTime: number, timeConstant: number): IAudioParam {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n\n                automationEventList.add(createSetTargetAutomationEvent(target, startTime, timeConstant));\n                nativeAudioParam.setTargetAtTime(target, startTime, timeConstant);\n\n                return audioParam;\n            },\n            setValueAtTime(value: number, startTime: number): IAudioParam {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n\n                automationEventList.add(createSetValueAutomationEvent(value, startTime));\n                nativeAudioParam.setValueAtTime(value, startTime);\n\n                return audioParam;\n            },\n            setValueCurveAtTime(values: Iterable<number>, startTime: number, duration: number): IAudioParam {\n                // Bug 183: Safari only accepts a Float32Array.\n                const convertedValues = values instanceof Float32Array ? values : new Float32Array(values);\n                /*\n                 * Bug #152: Safari does not correctly interpolate the values of the curve.\n                 * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the\n                 * existence of the webkitAudioContext is used as a workaround here.\n                 */\n                if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {\n                    const endTime = startTime + duration;\n                    const sampleRate = audioNode.context.sampleRate;\n                    const firstSample = Math.ceil(startTime * sampleRate);\n                    const lastSample = Math.floor(endTime * sampleRate);\n                    const numberOfInterpolatedValues = lastSample - firstSample;\n                    const interpolatedValues = new Float32Array(numberOfInterpolatedValues);\n\n                    for (let i = 0; i < numberOfInterpolatedValues; i += 1) {\n                        const theoreticIndex = ((convertedValues.length - 1) / duration) * ((firstSample + i) / sampleRate - startTime);\n                        const lowerIndex = Math.floor(theoreticIndex);\n                        const upperIndex = Math.ceil(theoreticIndex);\n\n                        interpolatedValues[i] =\n                            lowerIndex === upperIndex\n                                ? convertedValues[lowerIndex]\n                                : (1 - (theoreticIndex - lowerIndex)) * convertedValues[lowerIndex] +\n                                  (1 - (upperIndex - theoreticIndex)) * convertedValues[upperIndex];\n                    }\n\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n\n                    automationEventList.add(createSetValueCurveAutomationEvent(interpolatedValues, startTime, duration));\n                    nativeAudioParam.setValueCurveAtTime(interpolatedValues, startTime, duration);\n\n                    const timeOfLastSample = lastSample / sampleRate;\n\n                    if (timeOfLastSample < endTime) {\n                        setValueAtTimeUntilPossible(audioParam, interpolatedValues[interpolatedValues.length - 1], timeOfLastSample);\n                    }\n\n                    setValueAtTimeUntilPossible(audioParam, convertedValues[convertedValues.length - 1], endTime);\n                } else {\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n\n                    automationEventList.add(createSetValueCurveAutomationEvent(convertedValues, startTime, duration));\n                    nativeAudioParam.setValueCurveAtTime(convertedValues, startTime, duration);\n                }\n\n                return audioParam;\n            }\n        };\n\n        audioParamStore.set(audioParam, nativeAudioParam);\n        audioParamAudioNodeStore.set(audioParam, audioNode);\n\n        addAudioParamConnections(\n            audioParam,\n            <T extends IMinimalOfflineAudioContext | IOfflineAudioContext ? IAudioParamRenderer : null>audioParamRenderer\n        );\n\n        return audioParam;\n    };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}