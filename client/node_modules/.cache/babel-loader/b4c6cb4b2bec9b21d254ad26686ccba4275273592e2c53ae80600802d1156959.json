{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { isNumber, isString } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { AMOscillator } from \"./AMOscillator\";\nimport { FatOscillator } from \"./FatOscillator\";\nimport { FMOscillator } from \"./FMOscillator\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform } from \"./OscillatorInterface\";\nimport { PulseOscillator } from \"./PulseOscillator\";\nimport { PWMOscillator } from \"./PWMOscillator\";\nconst OmniOscillatorSourceMap = {\n  am: AMOscillator,\n  fat: FatOscillator,\n  fm: FMOscillator,\n  oscillator: Oscillator,\n  pulse: PulseOscillator,\n  pwm: PWMOscillator\n};\n/**\n * OmniOscillator aggregates all of the oscillator types into one.\n * @example\n * return Tone.Offline(() => {\n * \tconst omniOsc = new Tone.OmniOscillator(\"C#4\", \"pwm\").toDestination().start();\n * }, 0.1, 1);\n * @category Source\n */\nexport class OmniOscillator extends Source {\n  constructor() {\n    super(optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n    this.name = \"OmniOscillator\";\n    const options = optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n    this.frequency = new Signal({\n      context: this.context,\n      units: \"frequency\",\n      value: options.frequency\n    });\n    this.detune = new Signal({\n      context: this.context,\n      units: \"cents\",\n      value: options.detune\n    });\n    readOnly(this, [\"frequency\", \"detune\"]);\n    // set the options\n    this.set(options);\n  }\n  static getDefaults() {\n    return Object.assign(Oscillator.getDefaults(), FMOscillator.getDefaults(), AMOscillator.getDefaults(), FatOscillator.getDefaults(), PulseOscillator.getDefaults(), PWMOscillator.getDefaults());\n  }\n  /**\n   * start the oscillator\n   */\n  _start(time) {\n    this._oscillator.start(time);\n  }\n  /**\n   * start the oscillator\n   */\n  _stop(time) {\n    this._oscillator.stop(time);\n  }\n  _restart(time) {\n    this._oscillator.restart(time);\n    return this;\n  }\n  /**\n   * The type of the oscillator. Can be any of the basic types: sine, square, triangle, sawtooth. Or\n   * prefix the basic types with \"fm\", \"am\", or \"fat\" to use the FMOscillator, AMOscillator or FatOscillator\n   * types. The oscillator could also be set to \"pwm\" or \"pulse\". All of the parameters of the\n   * oscillator's class are accessible when the oscillator is set to that type, but throws an error\n   * when it's not.\n   * @example\n   * const omniOsc = new Tone.OmniOscillator().toDestination().start();\n   * omniOsc.type = \"pwm\";\n   * // modulationFrequency is parameter which is available\n   * // only when the type is \"pwm\".\n   * omniOsc.modulationFrequency.value = 0.5;\n   */\n  get type() {\n    let prefix = \"\";\n    if ([\"am\", \"fm\", \"fat\"].some(p => this._sourceType === p)) {\n      prefix = this._sourceType;\n    }\n    return prefix + this._oscillator.type;\n  }\n  set type(type) {\n    if (type.substr(0, 2) === \"fm\") {\n      this._createNewOscillator(\"fm\");\n      this._oscillator = this._oscillator;\n      this._oscillator.type = type.substr(2);\n    } else if (type.substr(0, 2) === \"am\") {\n      this._createNewOscillator(\"am\");\n      this._oscillator = this._oscillator;\n      this._oscillator.type = type.substr(2);\n    } else if (type.substr(0, 3) === \"fat\") {\n      this._createNewOscillator(\"fat\");\n      this._oscillator = this._oscillator;\n      this._oscillator.type = type.substr(3);\n    } else if (type === \"pwm\") {\n      this._createNewOscillator(\"pwm\");\n      this._oscillator = this._oscillator;\n    } else if (type === \"pulse\") {\n      this._createNewOscillator(\"pulse\");\n    } else {\n      this._createNewOscillator(\"oscillator\");\n      this._oscillator = this._oscillator;\n      this._oscillator.type = type;\n    }\n  }\n  /**\n   * The value is an empty array when the type is not \"custom\".\n   * This is not available on \"pwm\" and \"pulse\" oscillator types.\n   * See [[Oscillator.partials]]\n   */\n  get partials() {\n    return this._oscillator.partials;\n  }\n  set partials(partials) {\n    if (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n      this._oscillator.partials = partials;\n    }\n  }\n  get partialCount() {\n    return this._oscillator.partialCount;\n  }\n  set partialCount(partialCount) {\n    if (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n      this._oscillator.partialCount = partialCount;\n    }\n  }\n  set(props) {\n    // make sure the type is set first\n    if (Reflect.has(props, \"type\") && props.type) {\n      this.type = props.type;\n    }\n    // then set the rest\n    super.set(props);\n    return this;\n  }\n  /**\n   * connect the oscillator to the frequency and detune signals\n   */\n  _createNewOscillator(oscType) {\n    if (oscType !== this._sourceType) {\n      this._sourceType = oscType;\n      const OscConstructor = OmniOscillatorSourceMap[oscType];\n      // short delay to avoid clicks on the change\n      const now = this.now();\n      if (this._oscillator) {\n        const oldOsc = this._oscillator;\n        oldOsc.stop(now);\n        // dispose the old one\n        this.context.setTimeout(() => oldOsc.dispose(), this.blockTime);\n      }\n      this._oscillator = new OscConstructor({\n        context: this.context\n      });\n      this.frequency.connect(this._oscillator.frequency);\n      this.detune.connect(this._oscillator.detune);\n      this._oscillator.connect(this.output);\n      this._oscillator.onstop = () => this.onstop(this);\n      if (this.state === \"started\") {\n        this._oscillator.start(now);\n      }\n    }\n  }\n  get phase() {\n    return this._oscillator.phase;\n  }\n  set phase(phase) {\n    this._oscillator.phase = phase;\n  }\n  /**\n   * The source type of the oscillator.\n   * @example\n   * const omniOsc = new Tone.OmniOscillator(440, \"fmsquare\");\n   * console.log(omniOsc.sourceType); // 'fm'\n   */\n  get sourceType() {\n    return this._sourceType;\n  }\n  set sourceType(sType) {\n    // the basetype defaults to sine\n    let baseType = \"sine\";\n    if (this._oscillator.type !== \"pwm\" && this._oscillator.type !== \"pulse\") {\n      baseType = this._oscillator.type;\n    }\n    // set the type\n    if (sType === \"fm\") {\n      this.type = \"fm\" + baseType;\n    } else if (sType === \"am\") {\n      this.type = \"am\" + baseType;\n    } else if (sType === \"fat\") {\n      this.type = \"fat\" + baseType;\n    } else if (sType === \"oscillator\") {\n      this.type = baseType;\n    } else if (sType === \"pulse\") {\n      this.type = \"pulse\";\n    } else if (sType === \"pwm\") {\n      this.type = \"pwm\";\n    }\n  }\n  _getOscType(osc, sourceType) {\n    return osc instanceof OmniOscillatorSourceMap[sourceType];\n  }\n  /**\n   * The base type of the oscillator. See [[Oscillator.baseType]]\n   * @example\n   * const omniOsc = new Tone.OmniOscillator(440, \"fmsquare4\");\n   * console.log(omniOsc.sourceType, omniOsc.baseType, omniOsc.partialCount);\n   */\n  get baseType() {\n    return this._oscillator.baseType;\n  }\n  set baseType(baseType) {\n    if (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\") && baseType !== \"pulse\" && baseType !== \"pwm\") {\n      this._oscillator.baseType = baseType;\n    }\n  }\n  /**\n   * The width of the oscillator when sourceType === \"pulse\".\n   * See [[PWMOscillator.width]]\n   */\n  get width() {\n    if (this._getOscType(this._oscillator, \"pulse\")) {\n      return this._oscillator.width;\n    } else {\n      return undefined;\n    }\n  }\n  /**\n   * The number of detuned oscillators when sourceType === \"fat\".\n   * See [[FatOscillator.count]]\n   */\n  get count() {\n    if (this._getOscType(this._oscillator, \"fat\")) {\n      return this._oscillator.count;\n    } else {\n      return undefined;\n    }\n  }\n  set count(count) {\n    if (this._getOscType(this._oscillator, \"fat\") && isNumber(count)) {\n      this._oscillator.count = count;\n    }\n  }\n  /**\n   * The detune spread between the oscillators when sourceType === \"fat\".\n   * See [[FatOscillator.count]]\n   */\n  get spread() {\n    if (this._getOscType(this._oscillator, \"fat\")) {\n      return this._oscillator.spread;\n    } else {\n      return undefined;\n    }\n  }\n  set spread(spread) {\n    if (this._getOscType(this._oscillator, \"fat\") && isNumber(spread)) {\n      this._oscillator.spread = spread;\n    }\n  }\n  /**\n   * The type of the modulator oscillator. Only if the oscillator is set to \"am\" or \"fm\" types.\n   * See [[AMOscillator]] or [[FMOscillator]]\n   */\n  get modulationType() {\n    if (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n      return this._oscillator.modulationType;\n    } else {\n      return undefined;\n    }\n  }\n  set modulationType(mType) {\n    if ((this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) && isString(mType)) {\n      this._oscillator.modulationType = mType;\n    }\n  }\n  /**\n   * The modulation index when the sourceType === \"fm\"\n   * See [[FMOscillator]].\n   */\n  get modulationIndex() {\n    if (this._getOscType(this._oscillator, \"fm\")) {\n      return this._oscillator.modulationIndex;\n    } else {\n      return undefined;\n    }\n  }\n  /**\n   * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n   * See [[AMOscillator]] or [[FMOscillator]]\n   */\n  get harmonicity() {\n    if (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n      return this._oscillator.harmonicity;\n    } else {\n      return undefined;\n    }\n  }\n  /**\n   * The modulationFrequency Signal of the oscillator when sourceType === \"pwm\"\n   * see [[PWMOscillator]]\n   * @min 0.1\n   * @max 5\n   */\n  get modulationFrequency() {\n    if (this._getOscType(this._oscillator, \"pwm\")) {\n      return this._oscillator.modulationFrequency;\n    } else {\n      return undefined;\n    }\n  }\n  asArray() {\n    let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1024;\n    return __awaiter(this, void 0, void 0, function* () {\n      return generateWaveform(this, length);\n    });\n  }\n  dispose() {\n    super.dispose();\n    this.detune.dispose();\n    this.frequency.dispose();\n    this._oscillator.dispose();\n    return this;\n  }\n}","map":{"version":3,"names":["optionsFromArguments","readOnly","isNumber","isString","Signal","Source","AMOscillator","FatOscillator","FMOscillator","Oscillator","generateWaveform","PulseOscillator","PWMOscillator","OmniOscillatorSourceMap","am","fat","fm","oscillator","pulse","pwm","OmniOscillator","constructor","getDefaults","arguments","name","options","frequency","context","units","value","detune","set","Object","assign","_start","time","_oscillator","start","_stop","stop","_restart","restart","type","prefix","some","p","_sourceType","substr","_createNewOscillator","partials","_getOscType","partialCount","props","Reflect","has","oscType","OscConstructor","now","oldOsc","setTimeout","dispose","blockTime","connect","output","onstop","state","phase","sourceType","sType","baseType","osc","width","undefined","count","spread","modulationType","mType","modulationIndex","harmonicity","modulationFrequency","asArray","length"],"sources":["/Users/ianstrom/Development/code/Capstone/node_modules/tone/Tone/source/oscillator/OmniOscillator.ts"],"sourcesContent":["import { Cents, Degrees, Frequency, Seconds, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { isNumber, isString } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { AMOscillator } from \"./AMOscillator\";\nimport { FatOscillator } from \"./FatOscillator\";\nimport { FMOscillator } from \"./FMOscillator\";\nimport { Oscillator } from \"./Oscillator\";\nimport {\n\tgenerateWaveform,\n\tOmniOscillatorOptions, \n\tOmniOscillatorType, ToneOscillatorInterface, ToneOscillatorType\n} from \"./OscillatorInterface\";\nimport { PulseOscillator } from \"./PulseOscillator\";\nimport { PWMOscillator } from \"./PWMOscillator\";\n\nexport { OmniOscillatorOptions } from \"./OscillatorInterface\";\n\n/**\n * All of the oscillator types that OmniOscillator can take on\n */\ntype AnyOscillator = Oscillator | PWMOscillator | PulseOscillator | FatOscillator | AMOscillator | FMOscillator;\n\n/**\n * All of the Oscillator constructor types mapped to their name.\n */\ninterface OmniOscillatorSource {\n\t\"fm\": FMOscillator;\n\t\"am\": AMOscillator;\n\t\"pwm\": PWMOscillator;\n\t\"pulse\": PulseOscillator;\n\t\"oscillator\": Oscillator;\n\t\"fat\": FatOscillator;\n}\n\n/**\n * The available oscillator types.\n */\nexport type OmniOscSourceType = keyof OmniOscillatorSource;\n\n// Conditional Types\ntype IsAmOrFmOscillator<Osc, Ret> = Osc extends AMOscillator ? Ret : Osc extends FMOscillator ? Ret : undefined;\ntype IsFatOscillator<Osc, Ret> = Osc extends FatOscillator ? Ret : undefined;\ntype IsPWMOscillator<Osc, Ret> = Osc extends PWMOscillator ? Ret : undefined;\ntype IsPulseOscillator<Osc, Ret> = Osc extends PulseOscillator ? Ret : undefined;\ntype IsFMOscillator<Osc, Ret> = Osc extends FMOscillator ? Ret : undefined;\n\ntype AnyOscillatorConstructor = new (...args: any[]) => AnyOscillator;\n\nconst OmniOscillatorSourceMap: {\n\t[key in OmniOscSourceType]: AnyOscillatorConstructor\n} = {\n\tam: AMOscillator,\n\tfat: FatOscillator,\n\tfm: FMOscillator,\n\toscillator: Oscillator,\n\tpulse: PulseOscillator,\n\tpwm: PWMOscillator,\n};\n\n/**\n * OmniOscillator aggregates all of the oscillator types into one. \n * @example\n * return Tone.Offline(() => {\n * \tconst omniOsc = new Tone.OmniOscillator(\"C#4\", \"pwm\").toDestination().start();\n * }, 0.1, 1);\n * @category Source\n */\nexport class OmniOscillator<OscType extends AnyOscillator>\n\textends Source<OmniOscillatorOptions>\n\timplements Omit<ToneOscillatorInterface, \"type\"> {\n\n\treadonly name: string = \"OmniOscillator\";\n\n\treadonly frequency: Signal<\"frequency\">;\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The oscillator that can switch types\n\t */\n\tprivate _oscillator!: AnyOscillator;\n\n\t/**\n\t * the type of the oscillator source\n\t */\n\tprivate _sourceType!: OmniOscSourceType;\n\n\t/**\n\t * @param frequency The initial frequency of the oscillator.\n\t * @param type The type of the oscillator.\n\t */\n\tconstructor(frequency?: Frequency, type?: OmniOscillatorType);\n\tconstructor(options?: Partial<OmniOscillatorOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n\t\tconst options = optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\t\treadOnly(this, [\"frequency\", \"detune\"]);\n\n\t\t// set the options\n\t\tthis.set(options);\n\t}\n\n\tstatic getDefaults(): OmniOscillatorOptions {\n\t\treturn Object.assign(\n\t\t\tOscillator.getDefaults(),\n\t\t\tFMOscillator.getDefaults(),\n\t\t\tAMOscillator.getDefaults(),\n\t\t\tFatOscillator.getDefaults(),\n\t\t\tPulseOscillator.getDefaults(),\n\t\t\tPWMOscillator.getDefaults(),\n\t\t);\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\tthis._oscillator.start(time);\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\tthis._oscillator.stop(time);\n\t}\n\n\tprotected _restart(time: Seconds): this {\n\t\tthis._oscillator.restart(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The type of the oscillator. Can be any of the basic types: sine, square, triangle, sawtooth. Or\n\t * prefix the basic types with \"fm\", \"am\", or \"fat\" to use the FMOscillator, AMOscillator or FatOscillator\n\t * types. The oscillator could also be set to \"pwm\" or \"pulse\". All of the parameters of the\n\t * oscillator's class are accessible when the oscillator is set to that type, but throws an error\n\t * when it's not. \n\t * @example\n\t * const omniOsc = new Tone.OmniOscillator().toDestination().start();\n\t * omniOsc.type = \"pwm\";\n\t * // modulationFrequency is parameter which is available\n\t * // only when the type is \"pwm\".\n\t * omniOsc.modulationFrequency.value = 0.5;\n\t */\n\tget type(): OmniOscillatorType {\n\t\tlet prefix = \"\";\n\t\tif ([\"am\", \"fm\", \"fat\"].some(p => this._sourceType === p)) {\n\t\t\tprefix = this._sourceType;\n\t\t}\n\t\treturn prefix + this._oscillator.type as OmniOscillatorType;\n\t}\n\tset type(type) {\n\t\tif (type.substr(0, 2) === \"fm\") {\n\t\t\tthis._createNewOscillator(\"fm\");\n\t\t\tthis._oscillator = this._oscillator as FMOscillator;\n\t\t\tthis._oscillator.type = type.substr(2) as ToneOscillatorType;\n\t\t} else if (type.substr(0, 2) === \"am\") {\n\t\t\tthis._createNewOscillator(\"am\");\n\t\t\tthis._oscillator = this._oscillator as AMOscillator;\n\t\t\tthis._oscillator.type = type.substr(2) as ToneOscillatorType;\n\t\t} else if (type.substr(0, 3) === \"fat\") {\n\t\t\tthis._createNewOscillator(\"fat\");\n\t\t\tthis._oscillator = this._oscillator as FatOscillator;\n\t\t\tthis._oscillator.type = type.substr(3) as ToneOscillatorType;\n\t\t} else if (type === \"pwm\") {\n\t\t\tthis._createNewOscillator(\"pwm\");\n\t\t\tthis._oscillator = this._oscillator as PWMOscillator;\n\t\t} else if (type === \"pulse\") {\n\t\t\tthis._createNewOscillator(\"pulse\");\n\t\t} else {\n\t\t\tthis._createNewOscillator(\"oscillator\");\n\t\t\tthis._oscillator = this._oscillator as Oscillator;\n\t\t\tthis._oscillator.type = (type as ToneOscillatorType);\n\t\t}\n\t}\n\n\t/**\n\t * The value is an empty array when the type is not \"custom\".\n\t * This is not available on \"pwm\" and \"pulse\" oscillator types.\n\t * See [[Oscillator.partials]]\n\t */\n\tget partials(): number[] {\n\t\treturn this._oscillator.partials;\n\t}\n\tset partials(partials) {\n\t\tif (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n\t\t\tthis._oscillator.partials = partials;\n\t\t}\n\t}\n\n\tget partialCount(): number {\n\t\treturn this._oscillator.partialCount;\n\t}\n\tset partialCount(partialCount) {\n\t\tif (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n\t\t\tthis._oscillator.partialCount = partialCount;\n\t\t}\n\t}\n\n\tset(props: Partial<OmniOscillatorOptions>): this {\n\t\t// make sure the type is set first\n\t\tif (Reflect.has(props, \"type\") && props.type) {\n\t\t\tthis.type = props.type;\n\t\t}\n\t\t// then set the rest\n\t\tsuper.set(props);\n\t\treturn this;\n\t}\n\n\t/**\n\t * connect the oscillator to the frequency and detune signals\n\t */\n\tprivate _createNewOscillator(oscType: OmniOscSourceType): void {\n\t\tif (oscType !== this._sourceType) {\n\t\t\tthis._sourceType = oscType;\n\t\t\tconst OscConstructor = OmniOscillatorSourceMap[oscType];\n\t\t\t// short delay to avoid clicks on the change\n\t\t\tconst now = this.now();\n\t\t\tif (this._oscillator) {\n\t\t\t\tconst oldOsc = this._oscillator;\n\t\t\t\toldOsc.stop(now);\n\t\t\t\t// dispose the old one\n\t\t\t\tthis.context.setTimeout(() => oldOsc.dispose(), this.blockTime);\n\t\t\t}\n\t\t\tthis._oscillator = new OscConstructor({\n\t\t\t\tcontext: this.context,\n\t\t\t});\n\t\t\tthis.frequency.connect(this._oscillator.frequency);\n\t\t\tthis.detune.connect(this._oscillator.detune);\n\t\t\tthis._oscillator.connect(this.output);\n\t\t\tthis._oscillator.onstop = () => this.onstop(this);\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tthis._oscillator.start(now);\n\t\t\t}\n\t\t}\n\t}\n\n\tget phase(): Degrees {\n\t\treturn this._oscillator.phase;\n\t}\n\tset phase(phase) {\n\t\tthis._oscillator.phase = phase;\n\t}\n\n\t/**\n\t * The source type of the oscillator.\n\t * @example\n\t * const omniOsc = new Tone.OmniOscillator(440, \"fmsquare\");\n\t * console.log(omniOsc.sourceType); // 'fm'\n\t */\n\tget sourceType(): OmniOscSourceType {\n\t\treturn this._sourceType;\n\t}\n\tset sourceType(sType) {\n\t\t// the basetype defaults to sine\n\t\tlet baseType = \"sine\";\n\t\tif (this._oscillator.type !== \"pwm\" && this._oscillator.type !== \"pulse\") {\n\t\t\tbaseType = this._oscillator.type;\n\t\t}\n\n\t\t// set the type\n\t\tif (sType === \"fm\") {\n\t\t\tthis.type = \"fm\" + baseType as OmniOscillatorType;\n\t\t} else if (sType === \"am\") {\n\t\t\tthis.type = \"am\" + baseType as OmniOscillatorType;\n\t\t} else if (sType === \"fat\") {\n\t\t\tthis.type = \"fat\" + baseType as OmniOscillatorType;\n\t\t} else if (sType === \"oscillator\") {\n\t\t\tthis.type = baseType as OmniOscillatorType;\n\t\t} else if (sType === \"pulse\") {\n\t\t\tthis.type = \"pulse\";\n\t\t} else if (sType === \"pwm\") {\n\t\t\tthis.type = \"pwm\";\n\t\t}\n\t}\n\n\tprivate _getOscType<SourceType extends OmniOscSourceType>(\n\t\tosc: AnyOscillator,\n\t\tsourceType: SourceType,\n\t): osc is OmniOscillatorSource[SourceType] {\n\t\treturn osc instanceof OmniOscillatorSourceMap[sourceType];\n\t}\n\n\t/**\n\t * The base type of the oscillator. See [[Oscillator.baseType]]\n\t * @example\n\t * const omniOsc = new Tone.OmniOscillator(440, \"fmsquare4\");\n\t * console.log(omniOsc.sourceType, omniOsc.baseType, omniOsc.partialCount);\n\t */\n\tget baseType(): OscillatorType | \"pwm\" | \"pulse\" {\n\t\treturn this._oscillator.baseType;\n\t}\n\tset baseType(baseType) {\n\t\tif (!this._getOscType(this._oscillator, \"pulse\") &&\n\t\t\t!this._getOscType(this._oscillator, \"pwm\") &&\n\t\t\tbaseType !== \"pulse\" && baseType !== \"pwm\") {\n\t\t\tthis._oscillator.baseType = baseType;\n\t\t}\n\t}\n\n\t/**\n\t * The width of the oscillator when sourceType === \"pulse\".\n\t * See [[PWMOscillator.width]]\n\t */\n\tget width(): IsPulseOscillator<OscType, Signal<\"audioRange\">> {\n\t\tif (this._getOscType(this._oscillator, \"pulse\")) {\n\t\t\treturn this._oscillator.width as IsPulseOscillator<OscType, Signal<\"audioRange\">>;\n\t\t} else {\n\t\t\treturn undefined as IsPulseOscillator<OscType, Signal<\"audioRange\">>;\n\t\t}\n\t}\n\n\t/**\n\t * The number of detuned oscillators when sourceType === \"fat\".\n\t * See [[FatOscillator.count]]\n\t */\n\tget count(): IsFatOscillator<OscType, number> {\n\t\tif (this._getOscType(this._oscillator, \"fat\")) {\n\t\t\treturn this._oscillator.count as IsFatOscillator<OscType, number>;\n\t\t} else {\n\t\t\treturn undefined as IsFatOscillator<OscType, number>;\n\t\t}\n\t}\n\tset count(count) {\n\t\tif (this._getOscType(this._oscillator, \"fat\") && isNumber(count)) {\n\t\t\tthis._oscillator.count = count;\n\t\t}\n\t}\n\n\t/**\n\t * The detune spread between the oscillators when sourceType === \"fat\".\n\t * See [[FatOscillator.count]]\n\t */\n\tget spread(): IsFatOscillator<OscType, Cents> {\n\t\tif (this._getOscType(this._oscillator, \"fat\")) {\n\t\t\treturn this._oscillator.spread as IsFatOscillator<OscType, Cents>;\n\t\t} else {\n\t\t\treturn undefined as IsFatOscillator<OscType, Cents>;\n\t\t}\n\t}\n\tset spread(spread) {\n\t\tif (this._getOscType(this._oscillator, \"fat\") && isNumber(spread)) {\n\t\t\tthis._oscillator.spread = spread;\n\t\t}\n\t}\n\n\t/**\n\t * The type of the modulator oscillator. Only if the oscillator is set to \"am\" or \"fm\" types. \n\t * See [[AMOscillator]] or [[FMOscillator]]\n\t */\n\tget modulationType(): IsAmOrFmOscillator<OscType, ToneOscillatorType> {\n\t\tif (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n\t\t\treturn this._oscillator.modulationType as IsAmOrFmOscillator<OscType, ToneOscillatorType>;\n\t\t} else {\n\t\t\treturn undefined as IsAmOrFmOscillator<OscType, ToneOscillatorType>;\n\t\t}\n\t}\n\tset modulationType(mType) {\n\t\tif ((this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) && isString(mType)) {\n\t\t\tthis._oscillator.modulationType = mType;\n\t\t}\n\t}\n\n\t/**\n\t * The modulation index when the sourceType === \"fm\"\n\t * See [[FMOscillator]].\n\t */\n\tget modulationIndex(): IsFMOscillator<OscType, Signal<\"positive\">> {\n\t\tif (this._getOscType(this._oscillator, \"fm\")) {\n\t\t\treturn this._oscillator.modulationIndex as IsFMOscillator<OscType, Signal<\"positive\">>;\n\t\t} else {\n\t\t\treturn undefined as IsFMOscillator<OscType, Signal<\"positive\">>;\n\t\t}\n\t}\n\n\t/**\n\t * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n\t * See [[AMOscillator]] or [[FMOscillator]]\n\t */\n\tget harmonicity(): IsAmOrFmOscillator<OscType, Signal<\"positive\">> {\n\t\tif (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n\t\t\treturn this._oscillator.harmonicity as IsAmOrFmOscillator<OscType, Signal<\"positive\">>;\n\t\t} else {\n\t\t\treturn undefined as IsAmOrFmOscillator<OscType, Signal<\"positive\">>;\n\t\t}\n\t}\n\n\t/**\n\t * The modulationFrequency Signal of the oscillator when sourceType === \"pwm\"\n\t * see [[PWMOscillator]]\n\t * @min 0.1\n\t * @max 5\n\t */\n\tget modulationFrequency(): IsPWMOscillator<OscType, Signal<\"frequency\">> {\n\t\tif (this._getOscType(this._oscillator, \"pwm\")) {\n\t\t\treturn this._oscillator.modulationFrequency as IsPWMOscillator<OscType, Signal<\"frequency\">>;\n\t\t} else {\n\t\t\treturn undefined as IsPWMOscillator<OscType, Signal<\"frequency\">>;\n\t\t}\n\t}\n\n\tasync asArray(length = 1024): Promise<Float32Array> {\n\t\treturn generateWaveform(this, length);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.detune.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis._oscillator.dispose();\n\t\treturn this;\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}