{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { getContext } from \"../Global\";\nimport { Tone } from \"../Tone\";\nimport { isAudioBuffer } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { noOp } from \"../util/Interface\";\nimport { isArray, isNumber, isString } from \"../util/TypeCheck\";\nimport { assert } from \"../util/Debug\";\n/**\n * AudioBuffer loading and storage. ToneAudioBuffer is used internally by all\n * classes that make requests for audio files such as Tone.Player,\n * Tone.Sampler and Tone.Convolver.\n * @example\n * const buffer = new Tone.ToneAudioBuffer(\"https://tonejs.github.io/audio/casio/A1.mp3\", () => {\n * \tconsole.log(\"loaded\");\n * });\n * @category Core\n */\nexport class ToneAudioBuffer extends Tone {\n  constructor() {\n    super();\n    this.name = \"ToneAudioBuffer\";\n    /**\n     * Callback when the buffer is loaded.\n     */\n    this.onload = noOp;\n    const options = optionsFromArguments(ToneAudioBuffer.getDefaults(), arguments, [\"url\", \"onload\", \"onerror\"]);\n    this.reverse = options.reverse;\n    this.onload = options.onload;\n    if (options.url && isAudioBuffer(options.url) || options.url instanceof ToneAudioBuffer) {\n      this.set(options.url);\n    } else if (isString(options.url)) {\n      // initiate the download\n      this.load(options.url).catch(options.onerror);\n    }\n  }\n  static getDefaults() {\n    return {\n      onerror: noOp,\n      onload: noOp,\n      reverse: false\n    };\n  }\n  /**\n   * The sample rate of the AudioBuffer\n   */\n  get sampleRate() {\n    if (this._buffer) {\n      return this._buffer.sampleRate;\n    } else {\n      return getContext().sampleRate;\n    }\n  }\n  /**\n   * Pass in an AudioBuffer or ToneAudioBuffer to set the value of this buffer.\n   */\n  set(buffer) {\n    if (buffer instanceof ToneAudioBuffer) {\n      // if it's loaded, set it\n      if (buffer.loaded) {\n        this._buffer = buffer.get();\n      } else {\n        // otherwise when it's loaded, invoke it's callback\n        buffer.onload = () => {\n          this.set(buffer);\n          this.onload(this);\n        };\n      }\n    } else {\n      this._buffer = buffer;\n    }\n    // reverse it initially\n    if (this._reversed) {\n      this._reverse();\n    }\n    return this;\n  }\n  /**\n   * The audio buffer stored in the object.\n   */\n  get() {\n    return this._buffer;\n  }\n  /**\n   * Makes an fetch request for the selected url then decodes the file as an audio buffer.\n   * Invokes the callback once the audio buffer loads.\n   * @param url The url of the buffer to load. filetype support depends on the browser.\n   * @returns A Promise which resolves with this ToneAudioBuffer\n   */\n  load(url) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const doneLoading = ToneAudioBuffer.load(url).then(audioBuffer => {\n        this.set(audioBuffer);\n        // invoke the onload method\n        this.onload(this);\n      });\n      ToneAudioBuffer.downloads.push(doneLoading);\n      try {\n        yield doneLoading;\n      } finally {\n        // remove the downloaded file\n        const index = ToneAudioBuffer.downloads.indexOf(doneLoading);\n        ToneAudioBuffer.downloads.splice(index, 1);\n      }\n      return this;\n    });\n  }\n  /**\n   * clean up\n   */\n  dispose() {\n    super.dispose();\n    this._buffer = undefined;\n    return this;\n  }\n  /**\n   * Set the audio buffer from the array.\n   * To create a multichannel AudioBuffer, pass in a multidimensional array.\n   * @param array The array to fill the audio buffer\n   */\n  fromArray(array) {\n    const isMultidimensional = isArray(array) && array[0].length > 0;\n    const channels = isMultidimensional ? array.length : 1;\n    const len = isMultidimensional ? array[0].length : array.length;\n    const context = getContext();\n    const buffer = context.createBuffer(channels, len, context.sampleRate);\n    const multiChannelArray = !isMultidimensional && channels === 1 ? [array] : array;\n    for (let c = 0; c < channels; c++) {\n      buffer.copyToChannel(multiChannelArray[c], c);\n    }\n    this._buffer = buffer;\n    return this;\n  }\n  /**\n   * Sums multiple channels into 1 channel\n   * @param chanNum Optionally only copy a single channel from the array.\n   */\n  toMono(chanNum) {\n    if (isNumber(chanNum)) {\n      this.fromArray(this.toArray(chanNum));\n    } else {\n      let outputArray = new Float32Array(this.length);\n      const numChannels = this.numberOfChannels;\n      for (let channel = 0; channel < numChannels; channel++) {\n        const channelArray = this.toArray(channel);\n        for (let i = 0; i < channelArray.length; i++) {\n          outputArray[i] += channelArray[i];\n        }\n      }\n      // divide by the number of channels\n      outputArray = outputArray.map(sample => sample / numChannels);\n      this.fromArray(outputArray);\n    }\n    return this;\n  }\n  /**\n   * Get the buffer as an array. Single channel buffers will return a 1-dimensional\n   * Float32Array, and multichannel buffers will return multidimensional arrays.\n   * @param channel Optionally only copy a single channel from the array.\n   */\n  toArray(channel) {\n    if (isNumber(channel)) {\n      return this.getChannelData(channel);\n    } else if (this.numberOfChannels === 1) {\n      return this.toArray(0);\n    } else {\n      const ret = [];\n      for (let c = 0; c < this.numberOfChannels; c++) {\n        ret[c] = this.getChannelData(c);\n      }\n      return ret;\n    }\n  }\n  /**\n   * Returns the Float32Array representing the PCM audio data for the specific channel.\n   * @param  channel  The channel number to return\n   * @return The audio as a TypedArray\n   */\n  getChannelData(channel) {\n    if (this._buffer) {\n      return this._buffer.getChannelData(channel);\n    } else {\n      return new Float32Array(0);\n    }\n  }\n  /**\n   * Cut a subsection of the array and return a buffer of the\n   * subsection. Does not modify the original buffer\n   * @param start The time to start the slice\n   * @param end The end time to slice. If none is given will default to the end of the buffer\n   */\n  slice(start) {\n    let end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.duration;\n    const startSamples = Math.floor(start * this.sampleRate);\n    const endSamples = Math.floor(end * this.sampleRate);\n    assert(startSamples < endSamples, \"The start time must be less than the end time\");\n    const length = endSamples - startSamples;\n    const retBuffer = getContext().createBuffer(this.numberOfChannels, length, this.sampleRate);\n    for (let channel = 0; channel < this.numberOfChannels; channel++) {\n      retBuffer.copyToChannel(this.getChannelData(channel).subarray(startSamples, endSamples), channel);\n    }\n    return new ToneAudioBuffer(retBuffer);\n  }\n  /**\n   * Reverse the buffer.\n   */\n  _reverse() {\n    if (this.loaded) {\n      for (let i = 0; i < this.numberOfChannels; i++) {\n        this.getChannelData(i).reverse();\n      }\n    }\n    return this;\n  }\n  /**\n   * If the buffer is loaded or not\n   */\n  get loaded() {\n    return this.length > 0;\n  }\n  /**\n   * The duration of the buffer in seconds.\n   */\n  get duration() {\n    if (this._buffer) {\n      return this._buffer.duration;\n    } else {\n      return 0;\n    }\n  }\n  /**\n   * The length of the buffer in samples\n   */\n  get length() {\n    if (this._buffer) {\n      return this._buffer.length;\n    } else {\n      return 0;\n    }\n  }\n  /**\n   * The number of discrete audio channels. Returns 0 if no buffer is loaded.\n   */\n  get numberOfChannels() {\n    if (this._buffer) {\n      return this._buffer.numberOfChannels;\n    } else {\n      return 0;\n    }\n  }\n  /**\n   * Reverse the buffer.\n   */\n  get reverse() {\n    return this._reversed;\n  }\n  set reverse(rev) {\n    if (this._reversed !== rev) {\n      this._reversed = rev;\n      this._reverse();\n    }\n  }\n  /**\n   * Create a ToneAudioBuffer from the array. To create a multichannel AudioBuffer,\n   * pass in a multidimensional array.\n   * @param array The array to fill the audio buffer\n   * @return A ToneAudioBuffer created from the array\n   */\n  static fromArray(array) {\n    return new ToneAudioBuffer().fromArray(array);\n  }\n  /**\n   * Creates a ToneAudioBuffer from a URL, returns a promise which resolves to a ToneAudioBuffer\n   * @param  url The url to load.\n   * @return A promise which resolves to a ToneAudioBuffer\n   */\n  static fromUrl(url) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const buffer = new ToneAudioBuffer();\n      return yield buffer.load(url);\n    });\n  }\n  /**\n   * Loads a url using fetch and returns the AudioBuffer.\n   */\n  static load(url) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // test if the url contains multiple extensions\n      const matches = url.match(/\\[([^\\]\\[]+\\|.+)\\]$/);\n      if (matches) {\n        const extensions = matches[1].split(\"|\");\n        let extension = extensions[0];\n        for (const ext of extensions) {\n          if (ToneAudioBuffer.supportsType(ext)) {\n            extension = ext;\n            break;\n          }\n        }\n        url = url.replace(matches[0], extension);\n      }\n      // make sure there is a slash between the baseUrl and the url\n      const baseUrl = ToneAudioBuffer.baseUrl === \"\" || ToneAudioBuffer.baseUrl.endsWith(\"/\") ? ToneAudioBuffer.baseUrl : ToneAudioBuffer.baseUrl + \"/\";\n      const response = yield fetch(baseUrl + url);\n      if (!response.ok) {\n        throw new Error(`could not load url: ${url}`);\n      }\n      const arrayBuffer = yield response.arrayBuffer();\n      const audioBuffer = yield getContext().decodeAudioData(arrayBuffer);\n      return audioBuffer;\n    });\n  }\n  /**\n   * Checks a url's extension to see if the current browser can play that file type.\n   * @param url The url/extension to test\n   * @return If the file extension can be played\n   * @static\n   * @example\n   * Tone.ToneAudioBuffer.supportsType(\"wav\"); // returns true\n   * Tone.ToneAudioBuffer.supportsType(\"path/to/file.wav\"); // returns true\n   */\n  static supportsType(url) {\n    const extensions = url.split(\".\");\n    const extension = extensions[extensions.length - 1];\n    const response = document.createElement(\"audio\").canPlayType(\"audio/\" + extension);\n    return response !== \"\";\n  }\n  /**\n   * Returns a Promise which resolves when all of the buffers have loaded\n   */\n  static loaded() {\n    return __awaiter(this, void 0, void 0, function* () {\n      // this makes sure that the function is always async\n      yield Promise.resolve();\n      while (ToneAudioBuffer.downloads.length) {\n        yield ToneAudioBuffer.downloads[0];\n      }\n    });\n  }\n}\n//-------------------------------------\n// STATIC METHODS\n//-------------------------------------\n/**\n * A path which is prefixed before every url.\n */\nToneAudioBuffer.baseUrl = \"\";\n/**\n * All of the downloads\n */\nToneAudioBuffer.downloads = [];","map":{"version":3,"names":["getContext","Tone","isAudioBuffer","optionsFromArguments","noOp","isArray","isNumber","isString","assert","ToneAudioBuffer","constructor","name","onload","options","getDefaults","arguments","reverse","url","set","load","catch","onerror","sampleRate","_buffer","buffer","loaded","get","_reversed","_reverse","doneLoading","then","audioBuffer","downloads","push","index","indexOf","splice","dispose","undefined","fromArray","array","isMultidimensional","length","channels","len","context","createBuffer","multiChannelArray","c","copyToChannel","toMono","chanNum","toArray","outputArray","Float32Array","numChannels","numberOfChannels","channel","channelArray","i","map","sample","getChannelData","ret","slice","start","end","duration","startSamples","Math","floor","endSamples","retBuffer","subarray","rev","fromUrl","matches","match","extensions","split","extension","ext","supportsType","replace","baseUrl","endsWith","response","fetch","ok","Error","arrayBuffer","decodeAudioData","document","createElement","canPlayType","Promise","resolve"],"sources":["/Users/ianstrom/Development/code/Capstone/client/node_modules/tone/Tone/core/context/ToneAudioBuffer.ts"],"sourcesContent":["import { getContext } from \"../Global\";\nimport { Tone } from \"../Tone\";\nimport { Samples, Seconds } from \"../type/Units\";\nimport { isAudioBuffer } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { noOp } from \"../util/Interface\";\nimport { isArray, isNumber, isString } from \"../util/TypeCheck\";\nimport { assert } from \"../util/Debug\";\n\ninterface ToneAudioBufferOptions {\n\turl?: string | AudioBuffer | ToneAudioBuffer;\n\treverse: boolean;\n\tonload: (buffer?: ToneAudioBuffer) => void;\n\tonerror: (error: Error) => void;\n}\n\n/**\n * AudioBuffer loading and storage. ToneAudioBuffer is used internally by all\n * classes that make requests for audio files such as Tone.Player,\n * Tone.Sampler and Tone.Convolver.\n * @example\n * const buffer = new Tone.ToneAudioBuffer(\"https://tonejs.github.io/audio/casio/A1.mp3\", () => {\n * \tconsole.log(\"loaded\");\n * });\n * @category Core\n */\nexport class ToneAudioBuffer extends Tone {\n\n\treadonly name: string = \"ToneAudioBuffer\";\n\n\t/**\n\t * stores the loaded AudioBuffer\n\t */\n\tprivate _buffer?: AudioBuffer;\n\n\t/**\n\t * indicates if the buffer should be reversed or not\n\t */\n\tprivate _reversed!: boolean;\n\n\t/**\n\t * Callback when the buffer is loaded.\n\t */\n\tonload: (buffer: ToneAudioBuffer) => void = noOp;\n\n\t/**\n\t *\n\t * @param url The url to load, or the audio buffer to set.\n\t * @param onload A callback which is invoked after the buffer is loaded.\n\t *                           It's recommended to use `ToneAudioBuffer.on('load', callback)` instead\n\t *                           since it will give you a callback when _all_ buffers are loaded.\n\t * @param onerror The callback to invoke if there is an error\n\t */\n\tconstructor(\n\t\turl?: string | ToneAudioBuffer | AudioBuffer,\n\t\tonload?: (buffer: ToneAudioBuffer) => void,\n\t\tonerror?: (error: Error) => void,\n\t);\n\tconstructor(options?: Partial<ToneAudioBufferOptions>);\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tconst options = optionsFromArguments(ToneAudioBuffer.getDefaults(), arguments, [\"url\", \"onload\", \"onerror\"]);\n\n\t\tthis.reverse = options.reverse;\n\t\tthis.onload = options.onload;\n\n\t\tif (options.url && isAudioBuffer(options.url) || options.url instanceof ToneAudioBuffer) {\n\t\t\tthis.set(options.url);\n\t\t} else if (isString(options.url)) {\n\t\t\t// initiate the download\n\t\t\tthis.load(options.url).catch(options.onerror);\n\t\t}\n\t}\n\n\tstatic getDefaults(): ToneAudioBufferOptions {\n\t\treturn {\n\t\t\tonerror: noOp,\n\t\t\tonload: noOp,\n\t\t\treverse: false,\n\t\t};\n\t}\n\n\t/**\n\t * The sample rate of the AudioBuffer\n\t */\n\tget sampleRate(): number {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.sampleRate;\n\t\t} else {\n\t\t\treturn getContext().sampleRate;\n\t\t}\n\t}\n\n\t/**\n\t * Pass in an AudioBuffer or ToneAudioBuffer to set the value of this buffer.\n\t */\n\tset(buffer: AudioBuffer | ToneAudioBuffer): this {\n\t\tif (buffer instanceof ToneAudioBuffer) {\n\t\t\t// if it's loaded, set it\n\t\t\tif (buffer.loaded) {\n\t\t\t\tthis._buffer = buffer.get();\n\t\t\t} else {\n\t\t\t\t// otherwise when it's loaded, invoke it's callback\n\t\t\t\tbuffer.onload = () => {\n\t\t\t\t\tthis.set(buffer);\n\t\t\t\t\tthis.onload(this);\n\t\t\t\t};\n\t\t\t}\n\t\t} else {\n\t\t\tthis._buffer = buffer;\n\t\t}\n\t\t// reverse it initially\n\t\tif (this._reversed) {\n\t\t\tthis._reverse();\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * The audio buffer stored in the object.\n\t */\n\tget(): AudioBuffer | undefined {\n\t\treturn this._buffer;\n\t}\n\n\t/**\n\t * Makes an fetch request for the selected url then decodes the file as an audio buffer.\n\t * Invokes the callback once the audio buffer loads.\n\t * @param url The url of the buffer to load. filetype support depends on the browser.\n\t * @returns A Promise which resolves with this ToneAudioBuffer\n\t */\n\tasync load(url: string): Promise<this> {\n\t\tconst doneLoading: Promise<void> = ToneAudioBuffer.load(url).then(audioBuffer => {\n\t\t\tthis.set(audioBuffer);\n\t\t\t// invoke the onload method\n\t\t\tthis.onload(this);\n\t\t});\n\t\tToneAudioBuffer.downloads.push(doneLoading);\n\t\ttry {\n\t\t\tawait doneLoading;\n\t\t} finally {\n\t\t\t// remove the downloaded file\n\t\t\tconst index = ToneAudioBuffer.downloads.indexOf(doneLoading);\n\t\t\tToneAudioBuffer.downloads.splice(index, 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._buffer = undefined;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the audio buffer from the array.\n\t * To create a multichannel AudioBuffer, pass in a multidimensional array.\n\t * @param array The array to fill the audio buffer\n\t */\n\tfromArray(array: Float32Array | Float32Array[]): this {\n\t\tconst isMultidimensional = isArray(array) && array[0].length > 0;\n\t\tconst channels = isMultidimensional ? array.length : 1;\n\t\tconst len = isMultidimensional ? (array[0] as Float32Array).length : array.length;\n\t\tconst context = getContext();\n\t\tconst buffer = context.createBuffer(channels, len, context.sampleRate);\n\t\tconst multiChannelArray: Float32Array[] = !isMultidimensional && channels === 1 ?\n\t\t\t[array as Float32Array] : array as Float32Array[];\n\n\t\tfor (let c = 0; c < channels; c++) {\n\t\t\tbuffer.copyToChannel(multiChannelArray[c], c);\n\t\t}\n\t\tthis._buffer = buffer;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sums multiple channels into 1 channel\n\t * @param chanNum Optionally only copy a single channel from the array.\n\t */\n\ttoMono(chanNum?: number): this {\n\t\tif (isNumber(chanNum)) {\n\t\t\tthis.fromArray(this.toArray(chanNum));\n\t\t} else {\n\t\t\tlet outputArray = new Float32Array(this.length as number);\n\t\t\tconst numChannels = this.numberOfChannels;\n\t\t\tfor (let channel = 0; channel < numChannels; channel++) {\n\t\t\t\tconst channelArray = this.toArray(channel) as Float32Array;\n\t\t\t\tfor (let i = 0; i < channelArray.length; i++) {\n\t\t\t\t\toutputArray[i] += channelArray[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// divide by the number of channels\n\t\t\toutputArray = outputArray.map(sample => sample / numChannels);\n\t\t\tthis.fromArray(outputArray);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the buffer as an array. Single channel buffers will return a 1-dimensional\n\t * Float32Array, and multichannel buffers will return multidimensional arrays.\n\t * @param channel Optionally only copy a single channel from the array.\n\t */\n\ttoArray(channel?: number): Float32Array | Float32Array[] {\n\t\tif (isNumber(channel)) {\n\t\t\treturn this.getChannelData(channel);\n\t\t} else if (this.numberOfChannels === 1) {\n\t\t\treturn this.toArray(0);\n\t\t} else {\n\t\t\tconst ret: Float32Array[] = [];\n\t\t\tfor (let c = 0; c < this.numberOfChannels; c++) {\n\t\t\t\tret[c] = this.getChannelData(c);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the Float32Array representing the PCM audio data for the specific channel.\n\t * @param  channel  The channel number to return\n\t * @return The audio as a TypedArray\n\t */\n\tgetChannelData(channel: number): Float32Array {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.getChannelData(channel);\n\t\t} else {\n\t\t\treturn new Float32Array(0);\n\t\t}\n\t}\n\n\t/**\n\t * Cut a subsection of the array and return a buffer of the\n\t * subsection. Does not modify the original buffer\n\t * @param start The time to start the slice\n\t * @param end The end time to slice. If none is given will default to the end of the buffer\n\t */\n\tslice(start: Seconds, end: Seconds = this.duration): ToneAudioBuffer {\n\t\tconst startSamples = Math.floor(start * this.sampleRate);\n\t\tconst endSamples = Math.floor(end * this.sampleRate);\n\t\tassert(startSamples < endSamples, \"The start time must be less than the end time\");\n\t\tconst length = endSamples - startSamples;\n\t\tconst retBuffer = getContext().createBuffer(this.numberOfChannels, length, this.sampleRate);\n\t\tfor (let channel = 0; channel < this.numberOfChannels; channel++) {\n\t\t\tretBuffer.copyToChannel(this.getChannelData(channel).subarray(startSamples, endSamples), channel);\n\t\t}\n\t\treturn new ToneAudioBuffer(retBuffer);\n\t}\n\n\t/**\n\t * Reverse the buffer.\n\t */\n\tprivate _reverse(): this {\n\t\tif (this.loaded) {\n\t\t\tfor (let i = 0; i < this.numberOfChannels; i++) {\n\t\t\t\tthis.getChannelData(i).reverse();\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * If the buffer is loaded or not\n\t */\n\tget loaded(): boolean {\n\t\treturn this.length > 0;\n\t}\n\n\t/**\n\t * The duration of the buffer in seconds.\n\t */\n\tget duration(): Seconds {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.duration;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The length of the buffer in samples\n\t */\n\tget length(): Samples {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.length;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The number of discrete audio channels. Returns 0 if no buffer is loaded.\n\t */\n\tget numberOfChannels(): number {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.numberOfChannels;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * Reverse the buffer.\n\t */\n\tget reverse(): boolean {\n\t\treturn this._reversed;\n\t}\n\tset reverse(rev: boolean) {\n\t\tif (this._reversed !== rev) {\n\t\t\tthis._reversed = rev;\n\t\t\tthis._reverse();\n\t\t}\n\t}\n\n\t//-------------------------------------\n\t// STATIC METHODS\n\t//-------------------------------------\n\n\t/**\n\t * A path which is prefixed before every url.\n\t */\n\tstatic baseUrl = \"\";\n\n\t/**\n\t * Create a ToneAudioBuffer from the array. To create a multichannel AudioBuffer,\n\t * pass in a multidimensional array.\n\t * @param array The array to fill the audio buffer\n\t * @return A ToneAudioBuffer created from the array\n\t */\n\tstatic fromArray(array: Float32Array | Float32Array[]): ToneAudioBuffer {\n\t\treturn (new ToneAudioBuffer()).fromArray(array);\n\t}\n\n\t/**\n\t * Creates a ToneAudioBuffer from a URL, returns a promise which resolves to a ToneAudioBuffer\n\t * @param  url The url to load.\n\t * @return A promise which resolves to a ToneAudioBuffer\n\t */\n\tstatic async fromUrl(url: string): Promise<ToneAudioBuffer> {\n\t\tconst buffer = new ToneAudioBuffer();\n\t\treturn await buffer.load(url);\n\t}\n\n\t/**\n\t * All of the downloads\n\t */\n\tstatic downloads: Array<Promise<void>> = [];\n\n\t/**\n\t * Loads a url using fetch and returns the AudioBuffer.\n\t */\n\tstatic async load(url: string): Promise<AudioBuffer> {\n\n\t\t// test if the url contains multiple extensions\n\t\tconst matches = url.match(/\\[([^\\]\\[]+\\|.+)\\]$/);\n\t\tif (matches) {\n\t\t\tconst extensions = matches[1].split(\"|\");\n\t\t\tlet extension = extensions[0];\n\t\t\tfor (const ext of extensions) {\n\t\t\t\tif (ToneAudioBuffer.supportsType(ext)) {\n\t\t\t\t\textension = ext;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\turl = url.replace(matches[0], extension);\n\t\t}\n\n\t\t// make sure there is a slash between the baseUrl and the url\n\t\tconst baseUrl = ToneAudioBuffer.baseUrl === \"\" || ToneAudioBuffer.baseUrl.endsWith(\"/\") ? ToneAudioBuffer.baseUrl : ToneAudioBuffer.baseUrl + \"/\";\n\t\tconst response = await fetch(baseUrl + url);\n\t\tif (!response.ok) {\n\t\t\tthrow new Error(`could not load url: ${url}`);\n\t\t}\n\t\tconst arrayBuffer = await response.arrayBuffer();\n\n\t\tconst audioBuffer = await getContext().decodeAudioData(arrayBuffer);\n\n\t\treturn audioBuffer;\n\t}\n\n\t/**\n\t * Checks a url's extension to see if the current browser can play that file type.\n\t * @param url The url/extension to test\n\t * @return If the file extension can be played\n\t * @static\n\t * @example\n\t * Tone.ToneAudioBuffer.supportsType(\"wav\"); // returns true\n\t * Tone.ToneAudioBuffer.supportsType(\"path/to/file.wav\"); // returns true\n\t */\n\tstatic supportsType(url: string): boolean {\n\t\tconst extensions = url.split(\".\");\n\t\tconst extension = extensions[extensions.length - 1];\n\t\tconst response = document.createElement(\"audio\").canPlayType(\"audio/\" + extension);\n\t\treturn response !== \"\";\n\t}\n\n\t/**\n\t * Returns a Promise which resolves when all of the buffers have loaded\n\t */\n\tstatic async loaded(): Promise<void> {\n\t\t// this makes sure that the function is always async\n\t\tawait Promise.resolve();\n\t\twhile (ToneAudioBuffer.downloads.length) {\n\t\t\tawait ToneAudioBuffer.downloads[0];\n\t\t}\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}